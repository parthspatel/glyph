---
phase: 3.1-style-guideline
plan: 02
type: execute
wave: 2
depends_on: ["3.1-01"]
files_modified:
  - apps/web/src/index.css
  - apps/web/src/components/theme-provider.tsx
  - apps/web/index.html
autonomous: true

must_haves:
  truths:
    - "Design tokens defined in OKLCH format for both light and dark modes"
    - "Purple primary color (#7C3AED range) configured as primary"
    - "Dark mode uses pure black backgrounds"
    - "No flash of wrong theme on initial page load"
  artifacts:
    - path: "apps/web/src/index.css"
      provides: "Tailwind imports and CSS custom properties"
      contains: "@import \"tailwindcss\""
    - path: "apps/web/src/components/theme-provider.tsx"
      provides: "Theme context and toggle functionality"
      exports: ["ThemeProvider", "useTheme"]
    - path: "apps/web/index.html"
      provides: "FOWT prevention script"
      contains: "glyph-ui-theme"
  key_links:
    - from: "apps/web/src/index.css"
      to: "tailwindcss"
      via: "@import directive"
      pattern: "@import \"tailwindcss\""
    - from: "apps/web/index.html"
      to: ".dark class"
      via: "inline script"
      pattern: "classList.add\\(\"dark\"\\)"
---

<objective>
Create design tokens, theming infrastructure, and FOWT prevention

Purpose: Establish the color palette, typography, and theme switching foundation
Output: Complete theming system with OKLCH tokens, ThemeProvider, and flash prevention
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-style-guideline/03.1-CONTEXT.md
@.planning/phases/03.1-style-guideline/03.1-RESEARCH.md
@.planning/phases/03.1-style-guideline/3.1-01-SUMMARY.md
@apps/web/src/index.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace index.css with Tailwind and design tokens</name>
  <files>apps/web/src/index.css</files>
  <action>
Replace the entire apps/web/src/index.css with Tailwind imports and design tokens.

IMPORTANT: The existing ~900 lines of vanilla CSS will be replaced. This is intentional - the design system replaces the old approach.

Create new index.css with:
1. Tailwind import
2. Inter font import
3. @theme inline block mapping CSS variables to Tailwind theme
4. :root variables for light mode (Stone base + purple primary)
5. .dark variables for dark mode (pure black surfaces + purple primary)
6. Base body styles

Key color decisions (from CONTEXT.md):
- Primary: Purple 500 range (oklch(0.627 0.265 303.9))
- Neutrals: Stone palette with warm undertones
- Dark surfaces: Pure black (oklch(0 0 0))
- Same purple primary for both modes (no adaptation)
- Border radius: 0.375rem (6px) - subtle, Linear-like

```css
@import "tailwindcss";
@import "@fontsource-variable/inter";
@import "tw-animate-css";

@theme inline {
  --font-sans: "Inter Variable", ui-sans-serif, system-ui, sans-serif;
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-success: var(--success);
  --color-success-foreground: var(--success-foreground);
  --color-warning: var(--warning);
  --color-warning-foreground: var(--warning-foreground);
  --color-info: var(--info);
  --color-info-foreground: var(--info-foreground);
}

/* Light mode - Stone base with vibrant purple primary */
:root {
  --background: oklch(0.99 0.002 106.423);
  --foreground: oklch(0.216 0.006 56.043);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.216 0.006 56.043);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.216 0.006 56.043);
  --primary: oklch(0.627 0.265 303.9);
  --primary-foreground: oklch(0.977 0.014 308.299);
  --secondary: oklch(0.95 0.004 106.589);
  --secondary-foreground: oklch(0.216 0.006 56.043);
  --muted: oklch(0.95 0.004 106.589);
  --muted-foreground: oklch(0.553 0.013 58.071);
  --accent: oklch(0.95 0.004 106.589);
  --accent-foreground: oklch(0.216 0.006 56.043);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.977 0.014 308.299);
  --border: oklch(0.902 0.006 106.589);
  --input: oklch(0.902 0.006 106.589);
  --ring: oklch(0.714 0.203 305.504);
  --radius: 0.375rem;
  
  /* Semantic colors */
  --success: oklch(0.627 0.194 142.495);
  --success-foreground: oklch(0.977 0.014 308.299);
  --warning: oklch(0.769 0.188 70.08);
  --warning-foreground: oklch(0.216 0.006 56.043);
  --info: oklch(0.623 0.214 259.815);
  --info-foreground: oklch(0.977 0.014 308.299);
}

/* Dark mode - Pure black surfaces with vibrant purple primary */
.dark {
  --background: oklch(0 0 0);
  --foreground: oklch(0.97 0.001 106.424);
  --card: oklch(0.1 0.002 106.423);
  --card-foreground: oklch(0.97 0.001 106.424);
  --popover: oklch(0.1 0.002 106.423);
  --popover-foreground: oklch(0.97 0.001 106.424);
  --primary: oklch(0.627 0.265 303.9);
  --primary-foreground: oklch(0.977 0.014 308.299);
  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.97 0.001 106.424);
  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 106.423);
  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.97 0.001 106.424);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.977 0.014 308.299);
  --border: oklch(0.268 0.007 34.298);
  --input: oklch(0.268 0.007 34.298);
  --ring: oklch(0.714 0.203 305.504);
  
  /* Semantic colors */
  --success: oklch(0.627 0.194 142.495);
  --success-foreground: oklch(0.977 0.014 308.299);
  --warning: oklch(0.769 0.188 70.08);
  --warning-foreground: oklch(0.216 0.006 56.043);
  --info: oklch(0.623 0.214 259.815);
  --info-foreground: oklch(0.977 0.014 308.299);
}

body {
  font-family: var(--font-sans);
  background-color: var(--color-background);
  color: var(--color-foreground);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border-color: var(--color-border);
}
```
  </action>
  <verify>`cat apps/web/src/index.css | grep -E "@import \"tailwindcss\"|--primary:|\.dark"` shows all three patterns</verify>
  <done>index.css contains Tailwind import, OKLCH design tokens for both light and dark modes</done>
</task>

<task type="auto">
  <name>Task 2: Create ThemeProvider component</name>
  <files>apps/web/src/components/theme-provider.tsx</files>
  <action>
Create apps/web/src/components/theme-provider.tsx with theme context and hook:

```typescript
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
};

type ThemeProviderState = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "glyph-ui-theme",
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  );

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove("light", "dark");

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light";
      root.classList.add(systemTheme);
      return;
    }

    root.classList.add(theme);
  }, [theme]);

  // Listen for system theme changes when in system mode
  useEffect(() => {
    if (theme !== "system") return;

    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    
    const handleChange = () => {
      const root = window.document.documentElement;
      root.classList.remove("light", "dark");
      root.classList.add(mediaQuery.matches ? "dark" : "light");
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [theme]);

  const value = {
    theme,
    setTheme: (newTheme: Theme) => {
      localStorage.setItem(storageKey, newTheme);
      setTheme(newTheme);
    },
  };

  return (
    <ThemeProviderContext.Provider value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeProviderContext);

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider");

  return context;
}
```

Key features:
- Supports "dark", "light", and "system" modes
- Persists preference to localStorage with key "glyph-ui-theme"
- Listens for OS theme changes when in system mode
- Uses .dark class on documentElement for CSS variable switching
  </action>
  <verify>`cat apps/web/src/components/theme-provider.tsx | grep -E "export function ThemeProvider|export function useTheme"` shows both exports</verify>
  <done>ThemeProvider and useTheme are exported and handle theme switching with localStorage persistence</done>
</task>

<task type="auto">
  <name>Task 3: Add FOWT prevention script to index.html</name>
  <files>apps/web/index.html</files>
  <action>
Update apps/web/index.html to add a FOWT (Flash of Wrong Theme) prevention script in the head, before the module script loads:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Glyph - Data Annotation Platform</title>
    <script>
      (function() {
        const theme = localStorage.getItem('glyph-ui-theme') || 'system';
        const isDark = theme === 'dark' || 
          (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);
        if (isDark) document.documentElement.classList.add('dark');
      })();
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

This inline script:
1. Runs synchronously before React renders
2. Reads theme from localStorage (same key as ThemeProvider)
3. Applies .dark class immediately if needed
4. Prevents any flash of light mode when user prefers dark
  </action>
  <verify>`cat apps/web/index.html | grep "glyph-ui-theme"` shows the localStorage key in script</verify>
  <done>index.html contains inline script that prevents flash of wrong theme on page load</done>
</task>

</tasks>

<verification>
1. index.css starts with `@import "tailwindcss"`
2. index.css contains `:root` and `.dark` blocks with OKLCH variables
3. ThemeProvider component exports ThemeProvider and useTheme
4. ThemeProvider uses "glyph-ui-theme" localStorage key
5. index.html contains FOWT prevention script with matching localStorage key
</verification>

<success_criteria>
- Design tokens defined in OKLCH format for light and dark modes
- Purple primary color (oklch(0.627 0.265 303.9)) consistently used
- Dark mode uses pure black backgrounds (oklch(0 0 0))
- ThemeProvider handles system/dark/light modes with persistence
- No flash of wrong theme on page load
</success_criteria>
