---
phase: 04-user-team-management
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/routes/teams.rs
  - apps/api/src/routes/mod.rs
  - libs/db/src/repo/pg_team.rs
  - libs/db/src/repo/traits.rs
  - libs/db/src/repo/mod.rs
autonomous: true

must_haves:
  truths:
    - "Teams can be created with optional parent for hierarchy"
    - "Team hierarchy is queryable via recursive CTE"
    - "Teams can be listed with sub-team counts"
    - "Team details include member summary"
  artifacts:
    - path: "apps/api/src/routes/teams.rs"
      provides: "Team CRUD endpoints"
      exports: ["routes"]
    - path: "libs/db/src/repo/pg_team.rs"
      provides: "PostgreSQL team repository with hierarchy queries"
      exports: ["PgTeamRepository"]
  key_links:
    - from: "apps/api/src/routes/teams.rs"
      to: "libs/db/src/repo/pg_team.rs"
      via: "repository calls"
      pattern: "TeamRepository"
---

<objective>
Implement Team CRUD API with hierarchical structure support.

Purpose: Enable team management with parent-child relationships, supporting the cascading leadership model.
Output: Working team endpoints with hierarchy queries.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-user-team-management/04-CONTEXT.md
@.planning/phases/04-user-team-management/04-RESEARCH.md
@migrations/0007_create_teams.sql
@libs/domain/src/team.rs
@libs/db/src/repo/traits.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PostgreSQL team repository with hierarchy</name>
  <files>libs/db/src/repo/pg_team.rs, libs/db/src/repo/traits.rs, libs/db/src/repo/mod.rs</files>
  <action>
Update libs/db/src/repo/traits.rs to extend TeamRepository:
```rust
use glyph_domain::{Team, TeamId, TeamMembership, TeamRole, UserId};
use crate::pagination::{Page, Pagination};
use crate::repo::errors::*;

/// Input for creating a new team
#[derive(Debug, Clone)]
pub struct NewTeam {
    pub name: String,
    pub description: Option<String>,
    pub parent_team_id: Option<TeamId>,
    pub capacity: Option<i32>,
    pub specializations: Vec<String>,
    pub initial_leader_id: Option<UserId>,  // Optional initial leader
}

/// Input for updating a team
#[derive(Debug, Clone, Default)]
pub struct TeamUpdate {
    pub name: Option<String>,
    pub description: Option<String>,
    pub status: Option<TeamStatus>,
    pub capacity: Option<i32>,
    pub specializations: Option<Vec<String>>,
}

/// Team node in hierarchy tree
#[derive(Debug, Clone, Serialize)]
pub struct TeamTreeNode {
    pub team: Team,
    pub depth: i32,
    pub member_count: i64,
    pub sub_team_count: i64,
}

/// Extended team repository with hierarchy support
#[async_trait::async_trait]
pub trait TeamRepository: Send + Sync {
    // Basic CRUD
    async fn find_by_id(&self, id: &TeamId) -> Result<Option<Team>, FindTeamError>;
    async fn create(&self, team: &NewTeam) -> Result<Team, CreateTeamError>;
    async fn update(&self, id: &TeamId, update: &TeamUpdate) -> Result<Team, UpdateTeamError>;
    async fn list(&self, pagination: Pagination) -> Result<Page<Team>, sqlx::Error>;
    async fn soft_delete(&self, id: &TeamId) -> Result<(), UpdateTeamError>;
    
    // Hierarchy methods
    async fn get_sub_teams(&self, team_id: &TeamId) -> Result<Vec<Team>, FindTeamError>;
    async fn get_team_tree(&self, team_id: &TeamId) -> Result<Vec<TeamTreeNode>, FindTeamError>;
    async fn get_root_teams(&self, pagination: Pagination) -> Result<Page<Team>, sqlx::Error>;
    
    // Membership methods
    async fn add_member(&self, team_id: &TeamId, user_id: &UserId, role: TeamRole, allocation: Option<i32>) -> Result<TeamMembership, TeamMembershipError>;
    async fn remove_member(&self, team_id: &TeamId, user_id: &UserId) -> Result<(), TeamMembershipError>;
    async fn update_member(&self, team_id: &TeamId, user_id: &UserId, role: Option<TeamRole>, allocation: Option<i32>) -> Result<TeamMembership, TeamMembershipError>;
    async fn list_members(&self, team_id: &TeamId, pagination: Pagination) -> Result<Page<TeamMembershipWithUser>, FindTeamError>;
    async fn get_member_count(&self, team_id: &TeamId) -> Result<i64, sqlx::Error>;
}

/// Team membership with user details
#[derive(Debug, Clone)]
pub struct TeamMembershipWithUser {
    pub team_id: TeamId,
    pub user_id: UserId,
    pub role: TeamRole,
    pub allocation_percentage: Option<i32>,
    pub joined_at: chrono::DateTime<chrono::Utc>,
    pub display_name: String,
    pub email: String,
}
```

Create/update libs/db/src/repo/pg_team.rs:
```rust
//! PostgreSQL implementation of TeamRepository

use async_trait::async_trait;
use sqlx::PgPool;

use glyph_domain::{Team, TeamId, TeamMembership, TeamRole, TeamStatus, UserId};
use crate::audit::{AuditAction, AuditActorType, AuditEvent, AuditWriter, SYSTEM_ACTOR_ID};
use crate::pagination::{Page, Pagination};
use crate::repo::errors::*;
use crate::repo::traits::*;

pub struct PgTeamRepository {
    pool: PgPool,
    audit: AuditWriter,
}

impl PgTeamRepository {
    pub fn new(pool: PgPool) -> Self {
        let audit = AuditWriter::new(pool.clone());
        Self { pool, audit }
    }
}

#[async_trait]
impl TeamRepository for PgTeamRepository {
    async fn find_by_id(&self, id: &TeamId) -> Result<Option<Team>, FindTeamError> {
        let row = sqlx::query_as::<_, TeamRow>(
            r#"
            SELECT team_id, parent_team_id, name, description, status,
                   capacity, specializations, created_at, updated_at
            FROM teams
            WHERE team_id = $1 AND status != 'deleted'
            "#
        )
        .bind(id.to_string())
        .fetch_optional(&self.pool)
        .await
        .map_err(FindTeamError::Database)?;
        
        row.map(|r| r.try_into())
            .transpose()
            .map_err(|_| FindTeamError::NotFound(id.clone()))
    }
    
    async fn create(&self, team: &NewTeam) -> Result<Team, CreateTeamError> {
        let mut tx = self.pool.begin().await.map_err(CreateTeamError::Database)?;
        
        let id = TeamId::new();
        let row = sqlx::query_as::<_, TeamRow>(
            r#"
            INSERT INTO teams (team_id, parent_team_id, name, description, capacity, specializations)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING team_id, parent_team_id, name, description, status,
                      capacity, specializations, created_at, updated_at
            "#
        )
        .bind(id.to_string())
        .bind(team.parent_team_id.as_ref().map(|p| p.to_string()))
        .bind(&team.name)
        .bind(&team.description)
        .bind(team.capacity)
        .bind(serde_json::to_value(&team.specializations).unwrap_or_default())
        .fetch_one(&mut *tx)
        .await
        .map_err(CreateTeamError::Database)?;
        
        // Add initial leader if provided
        if let Some(leader_id) = &team.initial_leader_id {
            sqlx::query(
                "INSERT INTO team_memberships (team_id, user_id, role) VALUES ($1, $2, 'leader')"
            )
            .bind(id.to_string())
            .bind(leader_id.to_string())
            .execute(&mut *tx)
            .await
            .map_err(CreateTeamError::Database)?;
        }
        
        tx.commit().await.map_err(CreateTeamError::Database)?;
        
        let result: Team = row.try_into()
            .map_err(|_| CreateTeamError::Database(sqlx::Error::RowNotFound))?;
        
        // Record audit
        self.audit.record_best_effort(AuditEvent {
            entity_type: "team",
            entity_id: result.team_id.to_string(),
            action: AuditAction::Create,
            actor_id: SYSTEM_ACTOR_ID.to_string(),
            actor_type: AuditActorType::System,
            data_snapshot: serde_json::to_value(&result).unwrap_or_default(),
            changes: None,
            request_id: None,
        }).await;
        
        Ok(result)
    }
    
    async fn update(&self, id: &TeamId, update: &TeamUpdate) -> Result<Team, UpdateTeamError> {
        let row = sqlx::query_as::<_, TeamRow>(
            r#"
            UPDATE teams SET
                name = COALESCE($2, name),
                description = COALESCE($3, description),
                status = COALESCE($4, status),
                capacity = COALESCE($5, capacity),
                specializations = COALESCE($6, specializations),
                updated_at = NOW()
            WHERE team_id = $1 AND status != 'deleted'
            RETURNING team_id, parent_team_id, name, description, status,
                      capacity, specializations, created_at, updated_at
            "#
        )
        .bind(id.to_string())
        .bind(&update.name)
        .bind(&update.description)
        .bind(update.status.map(|s| format!("{:?}", s).to_lowercase()))
        .bind(update.capacity)
        .bind(update.specializations.as_ref().and_then(|s| serde_json::to_value(s).ok()))
        .fetch_optional(&self.pool)
        .await
        .map_err(UpdateTeamError::Database)?
        .ok_or_else(|| UpdateTeamError::NotFound(id.clone()))?;
        
        row.try_into().map_err(|_| UpdateTeamError::Database(sqlx::Error::RowNotFound))
    }
    
    async fn list(&self, pagination: Pagination) -> Result<Page<Team>, sqlx::Error> {
        let total = sqlx::query_scalar::<_, i64>(
            "SELECT COUNT(*) FROM teams WHERE status != 'deleted'"
        )
        .fetch_one(&self.pool)
        .await?;
        
        let rows = sqlx::query_as::<_, TeamRow>(
            r#"
            SELECT team_id, parent_team_id, name, description, status,
                   capacity, specializations, created_at, updated_at
            FROM teams
            WHERE status != 'deleted'
            ORDER BY name
            LIMIT $1 OFFSET $2
            "#
        )
        .bind(pagination.clamped_limit())
        .bind(pagination.offset)
        .fetch_all(&self.pool)
        .await?;
        
        let teams = rows.into_iter().filter_map(|r| r.try_into().ok()).collect();
        Ok(Page::new(teams, total, &pagination))
    }
    
    async fn soft_delete(&self, id: &TeamId) -> Result<(), UpdateTeamError> {
        let result = sqlx::query(
            "UPDATE teams SET status = 'deleted', updated_at = NOW() WHERE team_id = $1"
        )
        .bind(id.to_string())
        .execute(&self.pool)
        .await
        .map_err(UpdateTeamError::Database)?;
        
        if result.rows_affected() == 0 {
            return Err(UpdateTeamError::NotFound(id.clone()));
        }
        
        Ok(())
    }
    
    async fn get_sub_teams(&self, team_id: &TeamId) -> Result<Vec<Team>, FindTeamError> {
        let rows = sqlx::query_as::<_, TeamRow>(
            r#"
            SELECT team_id, parent_team_id, name, description, status,
                   capacity, specializations, created_at, updated_at
            FROM teams
            WHERE parent_team_id = $1 AND status != 'deleted'
            ORDER BY name
            "#
        )
        .bind(team_id.to_string())
        .fetch_all(&self.pool)
        .await
        .map_err(FindTeamError::Database)?;
        
        Ok(rows.into_iter().filter_map(|r| r.try_into().ok()).collect())
    }
    
    async fn get_team_tree(&self, team_id: &TeamId) -> Result<Vec<TeamTreeNode>, FindTeamError> {
        let rows = sqlx::query_as::<_, TeamTreeRow>(
            r#"
            WITH RECURSIVE team_tree AS (
                SELECT t.team_id, t.parent_team_id, t.name, t.description, 
                       t.status, t.capacity, t.specializations, t.created_at, t.updated_at,
                       0 as depth
                FROM teams t
                WHERE t.team_id = $1 AND t.status != 'deleted'
                
                UNION ALL
                
                SELECT t.team_id, t.parent_team_id, t.name, t.description,
                       t.status, t.capacity, t.specializations, t.created_at, t.updated_at,
                       tt.depth + 1
                FROM teams t
                JOIN team_tree tt ON t.parent_team_id = tt.team_id
                WHERE t.status != 'deleted'
            )
            SELECT 
                tt.*,
                (SELECT COUNT(*) FROM team_memberships tm WHERE tm.team_id = tt.team_id) as member_count,
                (SELECT COUNT(*) FROM teams t WHERE t.parent_team_id = tt.team_id AND t.status != 'deleted') as sub_team_count
            FROM team_tree tt
            ORDER BY tt.depth, tt.name
            "#
        )
        .bind(team_id.to_string())
        .fetch_all(&self.pool)
        .await
        .map_err(FindTeamError::Database)?;
        
        Ok(rows.into_iter().filter_map(|r| r.try_into().ok()).collect())
    }
    
    async fn get_root_teams(&self, pagination: Pagination) -> Result<Page<Team>, sqlx::Error> {
        let total = sqlx::query_scalar::<_, i64>(
            "SELECT COUNT(*) FROM teams WHERE parent_team_id IS NULL AND status != 'deleted'"
        )
        .fetch_one(&self.pool)
        .await?;
        
        let rows = sqlx::query_as::<_, TeamRow>(
            r#"
            SELECT team_id, parent_team_id, name, description, status,
                   capacity, specializations, created_at, updated_at
            FROM teams
            WHERE parent_team_id IS NULL AND status != 'deleted'
            ORDER BY name
            LIMIT $1 OFFSET $2
            "#
        )
        .bind(pagination.clamped_limit())
        .bind(pagination.offset)
        .fetch_all(&self.pool)
        .await?;
        
        let teams = rows.into_iter().filter_map(|r| r.try_into().ok()).collect();
        Ok(Page::new(teams, total, &pagination))
    }
    
    async fn add_member(&self, team_id: &TeamId, user_id: &UserId, role: TeamRole, allocation: Option<i32>) -> Result<TeamMembership, TeamMembershipError> {
        let row = sqlx::query_as::<_, TeamMembershipRow>(
            r#"
            INSERT INTO team_memberships (team_id, user_id, role, allocation_percentage)
            VALUES ($1, $2, $3, $4)
            RETURNING team_id, user_id, role, allocation_percentage, joined_at
            "#
        )
        .bind(team_id.to_string())
        .bind(user_id.to_string())
        .bind(format!("{:?}", role).to_lowercase())
        .bind(allocation)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| {
            if let sqlx::Error::Database(ref db_err) = e {
                if db_err.constraint() == Some("team_memberships_pkey") {
                    return TeamMembershipError::AlreadyMember;
                }
            }
            TeamMembershipError::Database(e)
        })?;
        
        row.try_into().map_err(|_| TeamMembershipError::Database(sqlx::Error::RowNotFound))
    }
    
    async fn remove_member(&self, team_id: &TeamId, user_id: &UserId) -> Result<(), TeamMembershipError> {
        let result = sqlx::query(
            "DELETE FROM team_memberships WHERE team_id = $1 AND user_id = $2"
        )
        .bind(team_id.to_string())
        .bind(user_id.to_string())
        .execute(&self.pool)
        .await
        .map_err(TeamMembershipError::Database)?;
        
        if result.rows_affected() == 0 {
            return Err(TeamMembershipError::NotMember);
        }
        
        Ok(())
    }
    
    async fn update_member(&self, team_id: &TeamId, user_id: &UserId, role: Option<TeamRole>, allocation: Option<i32>) -> Result<TeamMembership, TeamMembershipError> {
        let row = sqlx::query_as::<_, TeamMembershipRow>(
            r#"
            UPDATE team_memberships SET
                role = COALESCE($3, role),
                allocation_percentage = COALESCE($4, allocation_percentage)
            WHERE team_id = $1 AND user_id = $2
            RETURNING team_id, user_id, role, allocation_percentage, joined_at
            "#
        )
        .bind(team_id.to_string())
        .bind(user_id.to_string())
        .bind(role.map(|r| format!("{:?}", r).to_lowercase()))
        .bind(allocation)
        .fetch_optional(&self.pool)
        .await
        .map_err(TeamMembershipError::Database)?
        .ok_or(TeamMembershipError::NotMember)?;
        
        row.try_into().map_err(|_| TeamMembershipError::Database(sqlx::Error::RowNotFound))
    }
    
    async fn list_members(&self, team_id: &TeamId, pagination: Pagination) -> Result<Page<TeamMembershipWithUser>, FindTeamError> {
        let total = sqlx::query_scalar::<_, i64>(
            "SELECT COUNT(*) FROM team_memberships WHERE team_id = $1"
        )
        .bind(team_id.to_string())
        .fetch_one(&self.pool)
        .await
        .map_err(FindTeamError::Database)?;
        
        let rows = sqlx::query_as::<_, TeamMemberWithUserRow>(
            r#"
            SELECT tm.team_id, tm.user_id, tm.role, tm.allocation_percentage, tm.joined_at,
                   u.display_name, u.email
            FROM team_memberships tm
            JOIN users u ON tm.user_id = u.user_id::text
            WHERE tm.team_id = $1
            ORDER BY tm.role DESC, u.display_name
            LIMIT $2 OFFSET $3
            "#
        )
        .bind(team_id.to_string())
        .bind(pagination.clamped_limit())
        .bind(pagination.offset)
        .fetch_all(&self.pool)
        .await
        .map_err(FindTeamError::Database)?;
        
        let members = rows.into_iter().filter_map(|r| r.try_into().ok()).collect();
        Ok(Page::new(members, total, &pagination))
    }
    
    async fn get_member_count(&self, team_id: &TeamId) -> Result<i64, sqlx::Error> {
        sqlx::query_scalar::<_, i64>(
            "SELECT COUNT(*) FROM team_memberships WHERE team_id = $1"
        )
        .bind(team_id.to_string())
        .fetch_one(&self.pool)
        .await
    }
}

// Row types
#[derive(sqlx::FromRow)]
struct TeamRow {
    team_id: String,
    parent_team_id: Option<String>,
    name: String,
    description: Option<String>,
    status: String,
    capacity: Option<i32>,
    specializations: serde_json::Value,
    created_at: chrono::DateTime<chrono::Utc>,
    updated_at: chrono::DateTime<chrono::Utc>,
}

impl TryFrom<TeamRow> for Team {
    type Error = glyph_domain::IdParseError;
    
    fn try_from(r: TeamRow) -> Result<Self, Self::Error> {
        Ok(Self {
            team_id: r.team_id.parse()?,
            parent_team_id: r.parent_team_id.map(|s| s.parse()).transpose()?,
            name: r.name,
            description: r.description,
            status: parse_team_status(&r.status),
            capacity: r.capacity,
            specializations: serde_json::from_value(r.specializations).unwrap_or_default(),
            created_at: r.created_at,
            updated_at: r.updated_at,
        })
    }
}

#[derive(sqlx::FromRow)]
struct TeamTreeRow {
    team_id: String,
    parent_team_id: Option<String>,
    name: String,
    description: Option<String>,
    status: String,
    capacity: Option<i32>,
    specializations: serde_json::Value,
    created_at: chrono::DateTime<chrono::Utc>,
    updated_at: chrono::DateTime<chrono::Utc>,
    depth: i32,
    member_count: i64,
    sub_team_count: i64,
}

impl TryFrom<TeamTreeRow> for TeamTreeNode {
    type Error = glyph_domain::IdParseError;
    
    fn try_from(r: TeamTreeRow) -> Result<Self, Self::Error> {
        Ok(Self {
            team: Team {
                team_id: r.team_id.parse()?,
                parent_team_id: r.parent_team_id.map(|s| s.parse()).transpose()?,
                name: r.name,
                description: r.description,
                status: parse_team_status(&r.status),
                capacity: r.capacity,
                specializations: serde_json::from_value(r.specializations).unwrap_or_default(),
                created_at: r.created_at,
                updated_at: r.updated_at,
            },
            depth: r.depth,
            member_count: r.member_count,
            sub_team_count: r.sub_team_count,
        })
    }
}

#[derive(sqlx::FromRow)]
struct TeamMembershipRow {
    team_id: String,
    user_id: String,
    role: String,
    allocation_percentage: Option<i32>,
    joined_at: chrono::DateTime<chrono::Utc>,
}

impl TryFrom<TeamMembershipRow> for TeamMembership {
    type Error = glyph_domain::IdParseError;
    
    fn try_from(r: TeamMembershipRow) -> Result<Self, Self::Error> {
        Ok(Self {
            team_id: r.team_id.parse()?,
            user_id: r.user_id.parse()?,
            role: parse_team_role(&r.role),
            allocation_percentage: r.allocation_percentage,
            joined_at: r.joined_at,
        })
    }
}

#[derive(sqlx::FromRow)]
struct TeamMemberWithUserRow {
    team_id: String,
    user_id: String,
    role: String,
    allocation_percentage: Option<i32>,
    joined_at: chrono::DateTime<chrono::Utc>,
    display_name: String,
    email: String,
}

impl TryFrom<TeamMemberWithUserRow> for TeamMembershipWithUser {
    type Error = glyph_domain::IdParseError;
    
    fn try_from(r: TeamMemberWithUserRow) -> Result<Self, Self::Error> {
        Ok(Self {
            team_id: r.team_id.parse()?,
            user_id: r.user_id.parse()?,
            role: parse_team_role(&r.role),
            allocation_percentage: r.allocation_percentage,
            joined_at: r.joined_at,
            display_name: r.display_name,
            email: r.email,
        })
    }
}

fn parse_team_status(s: &str) -> TeamStatus {
    match s {
        "active" => TeamStatus::Active,
        "inactive" => TeamStatus::Inactive,
        "deleted" => TeamStatus::Deleted,
        _ => TeamStatus::Active,
    }
}

fn parse_team_role(s: &str) -> TeamRole {
    match s {
        "leader" => TeamRole::Leader,
        "member" => TeamRole::Member,
        _ => TeamRole::Member,
    }
}
```
  </action>
  <verify>`cargo check -p glyph-db` compiles. Repository methods compile with sqlx.</verify>
  <done>Team repository implements hierarchy queries via recursive CTE</done>
</task>

<task type="auto">
  <name>Task 2: Create team CRUD endpoints</name>
  <files>apps/api/src/routes/teams.rs, apps/api/src/routes/mod.rs</files>
  <action>
Create apps/api/src/routes/teams.rs:

```rust
//! Team management endpoints

use std::sync::Arc;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use glyph_db::{Pagination, TeamRepository, NewTeam, TeamUpdate, TeamTreeNode, TeamMembershipWithUser};
use glyph_domain::{TeamId, Team, TeamStatus};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::{error::ApiError, extractors::{CurrentUser, RequireAdmin}};

// Response types
#[derive(Debug, Serialize, ToSchema)]
pub struct TeamListResponse {
    pub items: Vec<TeamSummary>,
    pub total: i64,
    pub limit: i64,
    pub offset: i64,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct TeamSummary {
    pub team_id: String,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub parent_team_id: Option<String>,
    pub member_count: i64,
    pub sub_team_count: i64,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct TeamDetailResponse {
    pub team_id: String,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub parent_team_id: Option<String>,
    pub capacity: Option<i32>,
    pub specializations: Vec<String>,
    pub member_count: i64,
    pub leader_count: i64,
    pub sub_teams: Vec<TeamSummary>,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct TeamTreeResponse {
    pub items: Vec<TeamTreeNodeResponse>,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct TeamTreeNodeResponse {
    pub team_id: String,
    pub name: String,
    pub description: Option<String>,
    pub status: String,
    pub depth: i32,
    pub member_count: i64,
    pub sub_team_count: i64,
}

impl From<TeamTreeNode> for TeamTreeNodeResponse {
    fn from(n: TeamTreeNode) -> Self {
        Self {
            team_id: n.team.team_id.to_string(),
            name: n.team.name,
            description: n.team.description,
            status: format!("{:?}", n.team.status).to_lowercase(),
            depth: n.depth,
            member_count: n.member_count,
            sub_team_count: n.sub_team_count,
        }
    }
}

// Request types
#[derive(Debug, Deserialize, ToSchema)]
pub struct CreateTeamRequest {
    pub name: String,
    pub description: Option<String>,
    pub parent_team_id: Option<String>,
    pub capacity: Option<i32>,
    #[serde(default)]
    pub specializations: Vec<String>,
    pub initial_leader_id: Option<String>,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct UpdateTeamRequest {
    pub name: Option<String>,
    pub description: Option<String>,
    pub status: Option<String>,
    pub capacity: Option<i32>,
    pub specializations: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
pub struct ListTeamsParams {
    pub limit: Option<i64>,
    pub offset: Option<i64>,
    pub root_only: Option<bool>,
}

// Handlers
#[utoipa::path(
    get,
    path = "/teams",
    tag = "teams",
    params(
        ("limit" = Option<i64>, Query, description = "Max results per page"),
        ("offset" = Option<i64>, Query, description = "Number of items to skip"),
        ("root_only" = Option<bool>, Query, description = "Only return root teams (no parent)")
    ),
    responses(
        (status = 200, description = "List of teams", body = TeamListResponse)
    )
)]
pub async fn list_teams(
    _user: CurrentUser,
    Query(params): Query<ListTeamsParams>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
) -> Result<Json<TeamListResponse>, ApiError> {
    let pagination = Pagination {
        limit: params.limit,
        offset: params.offset.unwrap_or(0),
    };
    
    let page = if params.root_only.unwrap_or(false) {
        repo.get_root_teams(pagination).await
    } else {
        repo.list(pagination).await
    }.map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    // Get counts for each team
    let mut items = Vec::with_capacity(page.items.len());
    for team in page.items {
        let member_count = repo.get_member_count(&team.team_id).await.unwrap_or(0);
        let sub_teams = repo.get_sub_teams(&team.team_id).await.unwrap_or_default();
        items.push(TeamSummary {
            team_id: team.team_id.to_string(),
            name: team.name,
            description: team.description,
            status: format!("{:?}", team.status).to_lowercase(),
            parent_team_id: team.parent_team_id.map(|id| id.to_string()),
            member_count,
            sub_team_count: sub_teams.len() as i64,
        });
    }
    
    Ok(Json(TeamListResponse {
        items,
        total: page.total,
        limit: page.limit,
        offset: page.offset,
    }))
}

#[utoipa::path(
    get,
    path = "/teams/{team_id}",
    tag = "teams",
    params(("team_id" = String, Path, description = "Team ID")),
    responses(
        (status = 200, description = "Team found", body = TeamDetailResponse),
        (status = 404, description = "Team not found")
    )
)]
pub async fn get_team(
    _user: CurrentUser,
    Path(team_id): Path<String>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
) -> Result<Json<TeamDetailResponse>, ApiError> {
    let id: TeamId = team_id.parse()?;
    
    let team = repo.find_by_id(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::not_found("team", team_id.clone()))?;
    
    let sub_teams = repo.get_sub_teams(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    let members = repo.list_members(&id, Pagination::default()).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    let leader_count = members.items.iter()
        .filter(|m| m.role == glyph_domain::TeamRole::Leader)
        .count() as i64;
    
    Ok(Json(TeamDetailResponse {
        team_id: team.team_id.to_string(),
        name: team.name,
        description: team.description,
        status: format!("{:?}", team.status).to_lowercase(),
        parent_team_id: team.parent_team_id.map(|id| id.to_string()),
        capacity: team.capacity,
        specializations: team.specializations,
        member_count: members.total,
        leader_count,
        sub_teams: sub_teams.into_iter().map(|t| TeamSummary {
            team_id: t.team_id.to_string(),
            name: t.name,
            description: t.description,
            status: format!("{:?}", t.status).to_lowercase(),
            parent_team_id: t.parent_team_id.map(|id| id.to_string()),
            member_count: 0,  // Not loading nested counts
            sub_team_count: 0,
        }).collect(),
        created_at: team.created_at.to_rfc3339(),
        updated_at: team.updated_at.to_rfc3339(),
    }))
}

#[utoipa::path(
    get,
    path = "/teams/{team_id}/tree",
    tag = "teams",
    params(("team_id" = String, Path, description = "Team ID")),
    responses(
        (status = 200, description = "Team hierarchy tree", body = TeamTreeResponse)
    )
)]
pub async fn get_team_tree(
    _user: CurrentUser,
    Path(team_id): Path<String>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
) -> Result<Json<TeamTreeResponse>, ApiError> {
    let id: TeamId = team_id.parse()?;
    let tree = repo.get_team_tree(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    Ok(Json(TeamTreeResponse {
        items: tree.into_iter().map(TeamTreeNodeResponse::from).collect(),
    }))
}

#[utoipa::path(
    post,
    path = "/teams",
    tag = "teams",
    request_body = CreateTeamRequest,
    responses(
        (status = 201, description = "Team created", body = TeamDetailResponse),
        (status = 400, description = "Invalid request"),
        (status = 403, description = "Admin only")
    )
)]
pub async fn create_team(
    RequireAdmin(_admin): RequireAdmin,
    Json(body): Json<CreateTeamRequest>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
) -> Result<(StatusCode, Json<TeamDetailResponse>), ApiError> {
    // Validate parent exists if provided
    let parent_team_id = if let Some(ref parent_id_str) = body.parent_team_id {
        let parent_id: TeamId = parent_id_str.parse()?;
        let _ = repo.find_by_id(&parent_id).await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
            .ok_or_else(|| ApiError::bad_request("team.parent.not_found", "Parent team not found"))?;
        Some(parent_id)
    } else {
        None
    };
    
    let initial_leader_id = body.initial_leader_id
        .map(|s| s.parse())
        .transpose()?;
    
    let new_team = NewTeam {
        name: body.name,
        description: body.description,
        parent_team_id,
        capacity: body.capacity,
        specializations: body.specializations,
        initial_leader_id,
    };
    
    let team = repo.create(&new_team).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    Ok((StatusCode::CREATED, Json(TeamDetailResponse {
        team_id: team.team_id.to_string(),
        name: team.name,
        description: team.description,
        status: format!("{:?}", team.status).to_lowercase(),
        parent_team_id: team.parent_team_id.map(|id| id.to_string()),
        capacity: team.capacity,
        specializations: team.specializations,
        member_count: if initial_leader_id.is_some() { 1 } else { 0 },
        leader_count: if initial_leader_id.is_some() { 1 } else { 0 },
        sub_teams: vec![],
        created_at: team.created_at.to_rfc3339(),
        updated_at: team.updated_at.to_rfc3339(),
    })))
}

#[utoipa::path(
    patch,
    path = "/teams/{team_id}",
    tag = "teams",
    params(("team_id" = String, Path, description = "Team ID")),
    request_body = UpdateTeamRequest,
    responses(
        (status = 200, description = "Team updated", body = TeamDetailResponse),
        (status = 404, description = "Team not found"),
        (status = 403, description = "Requires team leadership or admin")
    )
)]
pub async fn update_team(
    current_user: CurrentUser,
    Path(team_id): Path<String>,
    Json(body): Json<UpdateTeamRequest>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
    State(permission_service): State<Arc<crate::services::PermissionService>>,
) -> Result<Json<TeamDetailResponse>, ApiError> {
    let id: TeamId = team_id.parse()?;
    
    // Check permission: admin or team leader
    if !current_user.has_role("admin") {
        let is_leader = permission_service.check_team_leadership_cascade(&current_user.user_id, &id).await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
        if !is_leader {
            return Err(ApiError::Forbidden {
                permission: format!("team:lead({}) or role:admin", id),
            });
        }
    }
    
    let update = TeamUpdate {
        name: body.name,
        description: body.description,
        status: body.status.and_then(|s| parse_team_status_opt(&s)),
        capacity: body.capacity,
        specializations: body.specializations,
    };
    
    let team = repo.update(&id, &update).await
        .map_err(|e| match e {
            glyph_db::UpdateTeamError::NotFound(id) => ApiError::not_found("team", id.to_string()),
            glyph_db::UpdateTeamError::Database(e) => ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    Ok(Json(TeamDetailResponse {
        team_id: team.team_id.to_string(),
        name: team.name,
        description: team.description,
        status: format!("{:?}", team.status).to_lowercase(),
        parent_team_id: team.parent_team_id.map(|id| id.to_string()),
        capacity: team.capacity,
        specializations: team.specializations,
        member_count: 0,  // Not reloading
        leader_count: 0,
        sub_teams: vec![],
        created_at: team.created_at.to_rfc3339(),
        updated_at: team.updated_at.to_rfc3339(),
    }))
}

#[utoipa::path(
    delete,
    path = "/teams/{team_id}",
    tag = "teams",
    params(("team_id" = String, Path, description = "Team ID")),
    responses(
        (status = 204, description = "Team deleted"),
        (status = 404, description = "Team not found"),
        (status = 403, description = "Admin only")
    )
)]
pub async fn delete_team(
    RequireAdmin(_admin): RequireAdmin,
    Path(team_id): Path<String>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
) -> Result<StatusCode, ApiError> {
    let id: TeamId = team_id.parse()?;
    repo.soft_delete(&id).await
        .map_err(|e| match e {
            glyph_db::UpdateTeamError::NotFound(id) => ApiError::not_found("team", id.to_string()),
            glyph_db::UpdateTeamError::Database(e) => ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    Ok(StatusCode::NO_CONTENT)
}

fn parse_team_status_opt(s: &str) -> Option<TeamStatus> {
    match s.to_lowercase().as_str() {
        "active" => Some(TeamStatus::Active),
        "inactive" => Some(TeamStatus::Inactive),
        _ => None,
    }
}

pub fn routes() -> axum::Router {
    use axum::routing::{get, post, patch, delete};
    
    axum::Router::new()
        .route("/", get(list_teams).post(create_team))
        .route("/{team_id}", get(get_team).patch(update_team).delete(delete_team))
        .route("/{team_id}/tree", get(get_team_tree))
}
```

Update apps/api/src/routes/mod.rs:
- Add `pub mod teams;`
- Update api_v1_routes: `.nest("/teams", teams::routes())`
  </action>
  <verify>`cargo check -p glyph-api` compiles.</verify>
  <done>Team CRUD endpoints with hierarchy support created</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for hierarchy queries</name>
  <files>libs/db/src/repo/pg_team.rs</files>
  <action>
Add tests for hierarchy functionality:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_team_status_parsing() {
        assert_eq!(parse_team_status("active"), TeamStatus::Active);
        assert_eq!(parse_team_status("inactive"), TeamStatus::Inactive);
        assert_eq!(parse_team_status("deleted"), TeamStatus::Deleted);
        assert_eq!(parse_team_status("unknown"), TeamStatus::Active); // Default
    }
    
    #[test]
    fn test_team_role_parsing() {
        assert_eq!(parse_team_role("leader"), TeamRole::Leader);
        assert_eq!(parse_team_role("member"), TeamRole::Member);
        assert_eq!(parse_team_role("unknown"), TeamRole::Member); // Default
    }
}
```

Integration tests would require database setup - these can be added as part of CI.
  </action>
  <verify>`cargo test -p glyph-db` passes.</verify>
  <done>Team hierarchy parsing tests added</done>
</task>

</tasks>

<verification>
- `cargo check` passes for all crates
- GET /api/v1/teams returns paginated team list
- GET /api/v1/teams?root_only=true returns only root teams
- GET /api/v1/teams/{id} returns team details with sub-teams
- GET /api/v1/teams/{id}/tree returns full team hierarchy
- POST /api/v1/teams creates team with optional parent (admin only)
- PATCH /api/v1/teams/{id} updates team (team leader or admin)
- DELETE /api/v1/teams/{id} soft-deletes team (admin only)
</verification>

<success_criteria>
- Teams can be created with parent_team_id for hierarchy
- Team tree query returns all descendants with depth
- Root teams can be queried separately
- Team updates require team leadership or admin
- Team deletion is soft-delete only
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-team-management/04-05-SUMMARY.md`
</output>
