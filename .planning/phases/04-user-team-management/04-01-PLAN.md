---
phase: 04-user-team-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - migrations/0007_create_teams.sql
  - migrations/0008_create_skills.sql
  - migrations/0001_create_enums.sql
  - libs/domain/src/team.rs
  - libs/domain/src/user.rs
  - libs/domain/src/ids.rs
  - libs/domain/src/lib.rs
  - libs/domain/src/enums.rs
autonomous: true

must_haves:
  truths:
    - "Teams table supports hierarchical structure via parent_team_id"
    - "Skill types are configurable with expiration and proficiency settings"
    - "User skills are normalized in separate table with certification tracking"
  artifacts:
    - path: "migrations/0007_create_teams.sql"
      provides: "Teams and memberships tables with hierarchy support"
      contains: "parent_team_id"
    - path: "migrations/0008_create_skills.sql"
      provides: "Skill types and user skills tables"
      contains: "skill_types"
    - path: "libs/domain/src/team.rs"
      provides: "Updated Team domain model with parent reference"
      exports: ["Team", "TeamMembership", "TeamRole"]
  key_links:
    - from: "libs/domain/src/team.rs"
      to: "migrations/0007_create_teams.sql"
      via: "domain model matches schema"
      pattern: "parent_team_id"
---

<objective>
Create database schema for hierarchical teams and normalized skill certification system.

Purpose: Provide the data foundation for team hierarchy with cascading permissions and skill certification with expiration/grace periods.
Output: SQL migrations for teams and skills tables, updated domain types.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-user-team-management/04-CONTEXT.md
@.planning/phases/04-user-team-management/04-RESEARCH.md
@libs/domain/src/team.rs
@libs/domain/src/user.rs
@libs/domain/src/ids.rs
@migrations/0001_create_enums.sql
@migrations/0002_create_users.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create teams and memberships migration</name>
  <files>migrations/0001_create_enums.sql, migrations/0007_create_teams.sql</files>
  <action>
First, check if team_status and team_role enums exist in 0001_create_enums.sql. If not, add them:

```sql
CREATE TYPE team_status AS ENUM ('active', 'inactive', 'deleted');
CREATE TYPE team_role AS ENUM ('leader', 'member');
```

Then create migration 0007_create_teams.sql:

```sql
-- Glyph Data Annotation Platform
-- Migration 0007: Create teams and memberships tables

-- Teams with hierarchy support
CREATE TABLE teams (
    team_id         UUID PRIMARY KEY,
    parent_team_id  UUID REFERENCES teams(team_id),
    name            VARCHAR(255) NOT NULL,
    description     TEXT,
    status          team_status NOT NULL DEFAULT 'active',
    capacity        INTEGER,
    specializations JSONB NOT NULL DEFAULT '[]',
    created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for hierarchy traversal and filtering
CREATE INDEX idx_teams_parent ON teams (parent_team_id);
CREATE INDEX idx_teams_status ON teams (status);
CREATE INDEX idx_teams_name ON teams (name);

-- Team memberships (many-to-many with role)
CREATE TABLE team_memberships (
    team_id         UUID NOT NULL REFERENCES teams(team_id) ON DELETE CASCADE,
    user_id         UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    role            team_role NOT NULL DEFAULT 'member',
    allocation_percentage INTEGER CHECK (allocation_percentage >= 0 AND allocation_percentage <= 100),
    joined_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (team_id, user_id)
);

CREATE INDEX idx_team_memberships_user ON team_memberships (user_id);
CREATE INDEX idx_team_memberships_role ON team_memberships (role);

-- Trigger for teams updated_at
CREATE TRIGGER update_teams_updated_at
    BEFORE UPDATE ON teams
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Comments
COMMENT ON TABLE teams IS 'Hierarchical teams with optional parent relationships';
COMMENT ON COLUMN teams.parent_team_id IS 'Reference to parent team for hierarchy, NULL for root teams';
COMMENT ON TABLE team_memberships IS 'User membership in teams with role (leader or member)';
```
  </action>
  <verify>Run `sqlx migrate run` - migration applies without errors. Query `SELECT * FROM teams` works.</verify>
  <done>Teams and team_memberships tables exist with hierarchy support via parent_team_id</done>
</task>

<task type="auto">
  <name>Task 2: Create skills certification migration</name>
  <files>migrations/0008_create_skills.sql</files>
  <action>
Create migration for normalized skill certification system:

```sql
-- Glyph Data Annotation Platform
-- Migration 0008: Create skill types and user skills tables

-- Skill types (admin-configured templates)
CREATE TABLE skill_types (
    skill_id            VARCHAR(50) PRIMARY KEY,
    name                VARCHAR(255) NOT NULL,
    description         TEXT,
    expiration_months   INTEGER,  -- NULL = never expires
    grace_period_days   INTEGER NOT NULL DEFAULT 0,
    requires_proficiency BOOLEAN NOT NULL DEFAULT FALSE,
    proficiency_levels  JSONB,  -- Ordered array e.g., ["novice", "intermediate", "expert"]
    created_at          TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at          TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- User skill certifications (normalized from users.skills JSONB)
CREATE TABLE user_skills (
    certification_id    UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id             UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    skill_id            VARCHAR(50) NOT NULL REFERENCES skill_types(skill_id) ON DELETE CASCADE,
    proficiency_level   VARCHAR(50),  -- Must match entry in skill_types.proficiency_levels if requires_proficiency
    certified_by        UUID REFERENCES users(user_id),
    certified_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at          TIMESTAMPTZ,  -- Computed from skill_types.expiration_months at certification time
    notes               TEXT,
    UNIQUE (user_id, skill_id)
);

CREATE INDEX idx_user_skills_user ON user_skills (user_id);
CREATE INDEX idx_user_skills_skill ON user_skills (skill_id);
CREATE INDEX idx_user_skills_certified_by ON user_skills (certified_by);
CREATE INDEX idx_user_skills_expiry ON user_skills (expires_at) WHERE expires_at IS NOT NULL;

-- Trigger for skill_types updated_at
CREATE TRIGGER update_skill_types_updated_at
    BEFORE UPDATE ON skill_types
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- View computing skill status dynamically (never store computed status)
CREATE VIEW user_skills_with_status AS
SELECT 
    us.certification_id,
    us.user_id,
    us.skill_id,
    us.proficiency_level,
    us.certified_by,
    us.certified_at,
    us.expires_at,
    us.notes,
    st.name as skill_name,
    st.grace_period_days,
    CASE
        WHEN us.expires_at IS NULL THEN 'never_expires'
        WHEN NOW() < us.expires_at THEN 'active'
        WHEN NOW() < us.expires_at + (INTERVAL '1 day' * st.grace_period_days) THEN 'soft_expired'
        ELSE 'hard_expired'
    END as status
FROM user_skills us
JOIN skill_types st ON us.skill_id = st.skill_id;

-- Comments
COMMENT ON TABLE skill_types IS 'Admin-configured skill templates with expiration rules';
COMMENT ON COLUMN skill_types.proficiency_levels IS 'Ordered array of proficiency level names, user-defined per skill';
COMMENT ON TABLE user_skills IS 'User skill certifications, one per skill per user';
COMMENT ON VIEW user_skills_with_status IS 'User skills with dynamically computed expiration status';
```
  </action>
  <verify>Run `sqlx migrate run` - migration applies. Query `SELECT * FROM user_skills_with_status` returns columns including status.</verify>
  <done>Skill types and user skills tables exist with dynamic status view</done>
</task>

<task type="auto">
  <name>Task 3: Update domain types for teams and skills</name>
  <files>libs/domain/src/team.rs, libs/domain/src/user.rs, libs/domain/src/ids.rs, libs/domain/src/lib.rs, libs/domain/src/enums.rs</files>
  <action>
Update libs/domain/src/team.rs:
- Add `parent_team_id: Option<TeamId>` to Team struct
- Remove `leader_id` field from Team (leadership is via TeamMembership with role=Leader)
- Simplify TeamRole enum to just Leader and Member (remove Manager per CONTEXT decisions)
- Keep TeamStatus as-is (Active, Inactive, Deleted)

Update libs/domain/src/user.rs:
- Create new UserSkillCertification struct (distinct from old UserSkill):
  ```rust
  #[typeshare]
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct UserSkillCertification {
      pub certification_id: Uuid,
      pub skill_id: String,
      pub proficiency_level: Option<String>,
      pub certified_by: Option<UserId>,
      pub certified_at: DateTime<Utc>,
      pub expires_at: Option<DateTime<Utc>>,
      pub notes: Option<String>,
  }
  ```

- Create SkillStatus enum in enums.rs:
  ```rust
  #[typeshare]
  #[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
  #[serde(rename_all = "snake_case")]
  pub enum SkillStatus {
      Active,
      SoftExpired,
      HardExpired,
      NeverExpires,
  }
  ```

- Add method to UserSkillCertification:
  ```rust
  impl UserSkillCertification {
      pub fn status(&self, grace_period_days: i32) -> SkillStatus {
          let Some(expires_at) = self.expires_at else {
              return SkillStatus::NeverExpires;
          };
          let now = Utc::now();
          if now < expires_at {
              return SkillStatus::Active;
          }
          let grace_end = expires_at + Duration::days(grace_period_days as i64);
          if now < grace_end {
              SkillStatus::SoftExpired
          } else {
              SkillStatus::HardExpired
          }
      }
  }
  ```

- Create SkillType struct:
  ```rust
  #[typeshare]
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct SkillType {
      pub skill_id: String,
      pub name: String,
      pub description: Option<String>,
      pub expiration_months: Option<i32>,
      pub grace_period_days: i32,
      pub requires_proficiency: bool,
      pub proficiency_levels: Option<Vec<String>>,
      pub created_at: DateTime<Utc>,
      pub updated_at: DateTime<Utc>,
  }
  ```

Update libs/domain/src/lib.rs to re-export:
- SkillType, UserSkillCertification, SkillStatus
- Keep User with updated skills field type

Run typeshare to regenerate TypeScript types.
  </action>
  <verify>`cargo check -p glyph-domain` compiles without errors. `cargo run --bin typeshare -- --lang typescript libs/domain/src packages/types/src/generated.ts` (or project's typeshare command) succeeds.</verify>
  <done>Domain types updated to match new schema, TypeScript types regenerated</done>
</task>

</tasks>

<verification>
- `sqlx migrate run` applies both new migrations (0007, 0008)
- `SELECT * FROM teams` returns empty table with correct columns including parent_team_id
- `SELECT * FROM team_memberships` returns empty table
- `SELECT * FROM skill_types` returns empty table
- `SELECT * FROM user_skills_with_status` returns empty with status column
- `cargo check -p glyph-domain` passes
- `cargo test -p glyph-domain` passes (if tests exist)
</verification>

<success_criteria>
- Teams table has parent_team_id column for hierarchy
- team_memberships table links users to teams with role
- skill_types table configures expiration and proficiency
- user_skills table tracks certifications per user
- user_skills_with_status view computes status dynamically
- Domain types in Rust match schema
- TypeScript types are generated
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-team-management/04-01-SUMMARY.md`
</output>
