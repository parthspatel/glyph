---
phase: 04-user-team-management
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/routes/users.rs
  - libs/db/src/repo/pg_user.rs
  - libs/db/src/repo/traits.rs
  - libs/db/src/repo/mod.rs
  - migrations/0009_extend_users.sql
autonomous: true

must_haves:
  truths:
    - "Users can be listed with pagination"
    - "User details include skills with status and quality profile"
    - "Users can be created, updated, and soft-deleted"
    - "User profile supports detailed fields (timezone, contact info)"
  artifacts:
    - path: "apps/api/src/routes/users.rs"
      provides: "Complete User CRUD endpoints"
      exports: ["list_users", "get_user", "create_user", "update_user", "delete_user"]
    - path: "libs/db/src/repo/pg_user.rs"
      provides: "PostgreSQL user repository with skill loading"
      exports: ["PgUserRepository"]
  key_links:
    - from: "apps/api/src/routes/users.rs"
      to: "libs/db/src/repo/pg_user.rs"
      via: "repository calls"
      pattern: "UserRepository"
---

<objective>
Implement complete User CRUD API with detailed profiles and skill integration.

Purpose: Enable user management through REST API with full profile details, paginated listing, and skill certification display.
Output: Working user endpoints replacing current stubs.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-user-team-management/04-CONTEXT.md
@.planning/phases/04-user-team-management/04-RESEARCH.md
@apps/api/src/routes/users.rs
@libs/db/src/repo/pg_user.rs
@libs/db/src/repo/traits.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend User domain and repository for detailed profiles</name>
  <files>libs/domain/src/user.rs, libs/db/src/repo/traits.rs, libs/db/src/repo/pg_user.rs</files>
  <action>
Update libs/domain/src/user.rs to add detailed profile fields:
```rust
#[typeshare]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub user_id: UserId,
    pub auth0_id: Option<String>,  // Link to Auth0 subject
    pub email: String,
    pub display_name: String,
    pub status: UserStatus,
    pub timezone: Option<String>,  // e.g., "America/New_York"
    pub department: Option<String>,
    pub bio: Option<String>,
    pub avatar_url: Option<String>,
    pub contact_info: Option<ContactInfo>,
    pub global_role: GlobalRole,  // Admin or User
    pub quality_profile: QualityProfile,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[typeshare]
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ContactInfo {
    pub phone: Option<String>,
    pub slack_handle: Option<String>,
    pub office_location: Option<String>,
}

#[typeshare]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GlobalRole {
    Admin,
    User,
}

impl Default for GlobalRole {
    fn default() -> Self {
        GlobalRole::User
    }
}
```

Update libs/db/src/repo/traits.rs:
- Extend NewUser to include optional fields:
  ```rust
  pub struct NewUser {
      pub email: String,
      pub display_name: String,
      pub auth0_id: Option<String>,
      pub timezone: Option<String>,
      pub department: Option<String>,
      pub global_role: Option<GlobalRole>,
  }
  ```
- Extend UserUpdate to include all editable fields:
  ```rust
  pub struct UserUpdate {
      pub display_name: Option<String>,
      pub status: Option<UserStatus>,
      pub timezone: Option<String>,
      pub department: Option<String>,
      pub bio: Option<String>,
      pub avatar_url: Option<String>,
      pub contact_info: Option<ContactInfo>,
      pub global_role: Option<GlobalRole>,
  }
  ```
- Add method to UserRepository: `find_by_auth0_id(&self, auth0_id: &str) -> Result<Option<User>, FindUserError>`

Update libs/db/src/repo/pg_user.rs:
- Update SQL queries to handle new columns
- Add migration awareness: new columns need to be added to users table (create migration 0009_extend_users.sql)
- Implement find_by_auth0_id method
- Update UserRow struct to include new fields
  </action>
  <verify>`cargo check -p glyph-db` compiles. Repository methods compile.</verify>
  <done>User domain has detailed profile fields, repository supports extended queries</done>
</task>

<task type="auto">
  <name>Task 2: Create users table extension migration</name>
  <files>migrations/0009_extend_users.sql</files>
  <action>
Create migration to add new profile columns to users table:

```sql
-- Glyph Data Annotation Platform
-- Migration 0009: Extend users table with profile details

-- Add new columns for detailed profiles
ALTER TABLE users
    ADD COLUMN auth0_id VARCHAR(255) UNIQUE,
    ADD COLUMN timezone VARCHAR(50),
    ADD COLUMN department VARCHAR(255),
    ADD COLUMN bio TEXT,
    ADD COLUMN avatar_url TEXT,
    ADD COLUMN contact_info JSONB NOT NULL DEFAULT '{}',
    ADD COLUMN global_role VARCHAR(20) NOT NULL DEFAULT 'user';

-- Index for Auth0 lookup (SSO auto-provision)
CREATE INDEX idx_users_auth0_id ON users (auth0_id) WHERE auth0_id IS NOT NULL;

-- Index for department filtering
CREATE INDEX idx_users_department ON users (department) WHERE department IS NOT NULL;

-- Comment updates
COMMENT ON COLUMN users.auth0_id IS 'Auth0 subject identifier for SSO users';
COMMENT ON COLUMN users.timezone IS 'User timezone, e.g., America/New_York';
COMMENT ON COLUMN users.contact_info IS 'Additional contact details: {phone, slack_handle, office_location}';
COMMENT ON COLUMN users.global_role IS 'Global role: admin or user';
```
  </action>
  <verify>`sqlx migrate run` applies without errors. `SELECT auth0_id, global_role FROM users` works.</verify>
  <done>Users table has all profile columns for detailed profiles</done>
</task>

<task type="auto">
  <name>Task 3: Implement complete User CRUD endpoints</name>
  <files>apps/api/src/routes/users.rs</files>
  <action>
Replace stub implementations with working endpoints:

```rust
//! User management endpoints

use std::sync::Arc;
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use glyph_db::{Pagination, UserRepository, SkillRepository, NewUser, UserUpdate};
use glyph_domain::{UserId, User, GlobalRole, ContactInfo};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::{error::ApiError, extractors::{CurrentUser, RequireAdmin}};

// Response types
#[derive(Debug, Serialize, ToSchema)]
pub struct UserListResponse {
    pub items: Vec<UserSummary>,
    pub total: i64,
    pub limit: i64,
    pub offset: i64,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct UserSummary {
    pub user_id: String,
    pub email: String,
    pub display_name: String,
    pub status: String,
    pub global_role: String,
    pub department: Option<String>,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct UserDetailResponse {
    pub user_id: String,
    pub email: String,
    pub display_name: String,
    pub status: String,
    pub timezone: Option<String>,
    pub department: Option<String>,
    pub bio: Option<String>,
    pub avatar_url: Option<String>,
    pub contact_info: Option<ContactInfo>,
    pub global_role: String,
    pub quality_profile: QualityProfileResponse,
    pub skills: Vec<UserSkillResponse>,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct QualityProfileResponse {
    pub overall_score: Option<f64>,
    pub accuracy_score: Option<f64>,
    pub consistency_score: Option<f64>,
    pub speed_percentile: Option<f64>,
    pub total_annotations: i64,
    pub approved_annotations: i64,
    pub rejected_annotations: i64,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct UserSkillResponse {
    pub certification_id: String,
    pub skill_id: String,
    pub skill_name: String,
    pub proficiency_level: Option<String>,
    pub certified_by: Option<String>,
    pub certified_at: String,
    pub expires_at: Option<String>,
    pub status: String,
}

// Request types
#[derive(Debug, Deserialize, ToSchema)]
pub struct CreateUserRequest {
    pub email: String,
    pub display_name: String,
    #[serde(default)]
    pub timezone: Option<String>,
    #[serde(default)]
    pub department: Option<String>,
    #[serde(default)]
    pub global_role: Option<String>,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct UpdateUserRequest {
    pub display_name: Option<String>,
    pub timezone: Option<String>,
    pub department: Option<String>,
    pub bio: Option<String>,
    pub avatar_url: Option<String>,
    pub contact_info: Option<ContactInfo>,
}

// Handlers
#[utoipa::path(
    get,
    path = "/users",
    tag = "users",
    params(
        ("limit" = Option<i64>, Query, description = "Max results per page (default 20, max 100)"),
        ("offset" = Option<i64>, Query, description = "Number of items to skip")
    ),
    responses(
        (status = 200, description = "List of users", body = UserListResponse),
        (status = 401, description = "Unauthorized")
    )
)]
pub async fn list_users(
    _user: CurrentUser,  // Require authentication
    Query(pagination): Query<Pagination>,
    State(repo): State<Arc<dyn UserRepository + Send + Sync>>,
) -> Result<Json<UserListResponse>, ApiError> {
    let page = repo.list(pagination).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    Ok(Json(UserListResponse {
        items: page.items.into_iter().map(UserSummary::from).collect(),
        total: page.total,
        limit: page.limit,
        offset: page.offset,
    }))
}

#[utoipa::path(
    get,
    path = "/users/{user_id}",
    tag = "users",
    params(
        ("user_id" = String, Path, description = "User ID (prefixed, e.g., user_01234...)")
    ),
    responses(
        (status = 200, description = "User found", body = UserDetailResponse),
        (status = 404, description = "User not found"),
        (status = 401, description = "Unauthorized")
    )
)]
pub async fn get_user(
    _user: CurrentUser,
    Path(user_id): Path<String>,
    State(repo): State<Arc<dyn UserRepository + Send + Sync>>,
    State(skill_repo): State<Arc<dyn SkillRepository + Send + Sync>>,
) -> Result<Json<UserDetailResponse>, ApiError> {
    let id: UserId = user_id.parse()?;
    let user = repo.find_by_id(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::not_found("user", user_id))?;
    
    // Load user's skills with status
    let skills = skill_repo.list_user_skills(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    Ok(Json(UserDetailResponse::from_user_with_skills(user, skills)))
}

#[utoipa::path(
    post,
    path = "/users",
    tag = "users",
    request_body = CreateUserRequest,
    responses(
        (status = 201, description = "User created", body = UserDetailResponse),
        (status = 400, description = "Invalid request"),
        (status = 409, description = "Email already exists"),
        (status = 403, description = "Admin only")
    )
)]
pub async fn create_user(
    RequireAdmin(_admin): RequireAdmin,  // Admin only
    Json(body): Json<CreateUserRequest>,
    State(repo): State<Arc<dyn UserRepository + Send + Sync>>,
) -> Result<(StatusCode, Json<UserDetailResponse>), ApiError> {
    // Validate email format
    if !body.email.contains('@') {
        return Err(ApiError::bad_request("user.email.invalid", "Invalid email format"));
    }
    
    let new_user = NewUser {
        email: body.email,
        display_name: body.display_name,
        timezone: body.timezone,
        department: body.department,
        global_role: body.global_role.and_then(|r| parse_global_role(&r)),
        ..Default::default()
    };
    
    let user = repo.create(&new_user).await
        .map_err(|e| match e {
            glyph_db::CreateUserError::EmailExists(email) => 
                ApiError::conflict("user.email.exists", format!("Email already exists: {}", email)),
            glyph_db::CreateUserError::Database(e) => 
                ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    Ok((StatusCode::CREATED, Json(UserDetailResponse::from(user))))
}

#[utoipa::path(
    patch,
    path = "/users/{user_id}",
    tag = "users",
    params(
        ("user_id" = String, Path, description = "User ID")
    ),
    request_body = UpdateUserRequest,
    responses(
        (status = 200, description = "User updated", body = UserDetailResponse),
        (status = 404, description = "User not found"),
        (status = 403, description = "Can only update own profile unless admin")
    )
)]
pub async fn update_user(
    current_user: CurrentUser,
    Path(user_id): Path<String>,
    Json(body): Json<UpdateUserRequest>,
    State(repo): State<Arc<dyn UserRepository + Send + Sync>>,
) -> Result<Json<UserDetailResponse>, ApiError> {
    let id: UserId = user_id.parse()?;
    
    // Users can only update their own profile unless admin
    if current_user.user_id != id && !current_user.has_role("admin") {
        return Err(ApiError::Forbidden {
            permission: "user:update(self) or role:admin".to_string(),
        });
    }
    
    let update = UserUpdate {
        display_name: body.display_name,
        timezone: body.timezone,
        department: body.department,
        bio: body.bio,
        avatar_url: body.avatar_url,
        contact_info: body.contact_info,
        ..Default::default()
    };
    
    let user = repo.update(&id, &update).await
        .map_err(|e| match e {
            glyph_db::UpdateUserError::NotFound(id) => ApiError::not_found("user", id.to_string()),
            glyph_db::UpdateUserError::Database(e) => ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    Ok(Json(UserDetailResponse::from(user)))
}

#[utoipa::path(
    delete,
    path = "/users/{user_id}",
    tag = "users",
    params(
        ("user_id" = String, Path, description = "User ID")
    ),
    responses(
        (status = 204, description = "User deleted"),
        (status = 404, description = "User not found"),
        (status = 403, description = "Admin only")
    )
)]
pub async fn delete_user(
    RequireAdmin(_admin): RequireAdmin,
    Path(user_id): Path<String>,
    State(repo): State<Arc<dyn UserRepository + Send + Sync>>,
) -> Result<StatusCode, ApiError> {
    let id: UserId = user_id.parse()?;
    repo.soft_delete(&id).await
        .map_err(|e| match e {
            glyph_db::UpdateUserError::NotFound(id) => ApiError::not_found("user", id.to_string()),
            glyph_db::UpdateUserError::Database(e) => ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    Ok(StatusCode::NO_CONTENT)
}

// Helper functions
fn parse_global_role(s: &str) -> Option<GlobalRole> {
    match s.to_lowercase().as_str() {
        "admin" => Some(GlobalRole::Admin),
        "user" => Some(GlobalRole::User),
        _ => None,
    }
}

impl From<User> for UserSummary {
    fn from(u: User) -> Self {
        Self {
            user_id: u.user_id.to_string(),
            email: u.email,
            display_name: u.display_name,
            status: format!("{:?}", u.status).to_lowercase(),
            global_role: format!("{:?}", u.global_role).to_lowercase(),
            department: u.department,
        }
    }
}

impl From<User> for UserDetailResponse {
    fn from(u: User) -> Self {
        Self {
            user_id: u.user_id.to_string(),
            email: u.email,
            display_name: u.display_name,
            status: format!("{:?}", u.status).to_lowercase(),
            timezone: u.timezone,
            department: u.department,
            bio: u.bio,
            avatar_url: u.avatar_url,
            contact_info: u.contact_info,
            global_role: format!("{:?}", u.global_role).to_lowercase(),
            quality_profile: QualityProfileResponse::from(u.quality_profile),
            skills: vec![],  // Loaded separately
            created_at: u.created_at.to_rfc3339(),
            updated_at: u.updated_at.to_rfc3339(),
        }
    }
}

impl UserDetailResponse {
    fn from_user_with_skills(u: User, skills: Vec<UserSkillWithStatus>) -> Self {
        let mut resp = Self::from(u);
        resp.skills = skills.into_iter().map(UserSkillResponse::from).collect();
        resp
    }
}

// Routes builder
pub fn routes() -> axum::Router {
    use axum::routing::{get, post, patch, delete};
    
    axum::Router::new()
        .route("/", get(list_users).post(create_user))
        .route("/{user_id}", get(get_user).patch(update_user).delete(delete_user))
}
```

Update OpenAPI documentation with proper schemas.
  </action>
  <verify>`cargo check -p glyph-api` compiles. Manual test: `curl http://localhost:3000/api/v1/users` returns paginated list (with auth).</verify>
  <done>User CRUD endpoints work with proper authorization</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-api` passes
- `sqlx migrate run` applies 0009 migration
- GET /api/v1/users returns paginated user list
- GET /api/v1/users/{id} returns user with skills and quality profile
- POST /api/v1/users creates user (admin only)
- PATCH /api/v1/users/{id} updates user profile
- DELETE /api/v1/users/{id} soft-deletes user (admin only)
</verification>

<success_criteria>
- Users can list other users with pagination
- User details include all profile fields
- Only admins can create or delete users
- Users can update their own profiles
- Skills are loaded with certification status
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-team-management/04-03-SUMMARY.md`
</output>
