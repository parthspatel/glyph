---
phase: 04-user-team-management
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/api/src/routes/skills.rs
  - apps/api/src/routes/mod.rs
  - libs/db/src/repo/pg_skill.rs
  - libs/db/src/repo/traits.rs
  - libs/db/src/repo/mod.rs
  - libs/db/src/repo/errors.rs
autonomous: true

must_haves:
  truths:
    - "Admins can create and configure skill types"
    - "Certifiers can grant skills to users with expiration"
    - "Skills can be revoked by certifiers"
    - "Skill status is computed dynamically (active/soft-expired/hard-expired)"
  artifacts:
    - path: "apps/api/src/routes/skills.rs"
      provides: "Skill type and certification endpoints"
      exports: ["routes"]
    - path: "libs/db/src/repo/pg_skill.rs"
      provides: "PostgreSQL skill repository"
      exports: ["PgSkillRepository"]
  key_links:
    - from: "apps/api/src/routes/skills.rs"
      to: "libs/db/src/repo/pg_skill.rs"
      via: "repository calls"
      pattern: "SkillRepository"
---

<objective>
Implement skill type configuration and user skill certification API.

Purpose: Enable admins to define skill types with expiration rules, and certifiers to grant/revoke skills to users.
Output: Skills management endpoints with proper authorization.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-user-team-management/04-CONTEXT.md
@.planning/phases/04-user-team-management/04-RESEARCH.md
@migrations/0008_create_skills.sql
@libs/domain/src/user.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create skill repository trait and PostgreSQL implementation</name>
  <files>libs/db/src/repo/traits.rs, libs/db/src/repo/pg_skill.rs, libs/db/src/repo/mod.rs, libs/db/src/repo/errors.rs</files>
  <action>
Add to libs/db/src/repo/errors.rs:
```rust
use glyph_domain::UserId;
use thiserror::Error;

// Skill type errors
#[derive(Debug, Error)]
pub enum FindSkillTypeError {
    #[error("skill type not found: {0}")]
    NotFound(String),
    #[error("database error: {0}")]
    Database(#[from] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum CreateSkillTypeError {
    #[error("skill type already exists: {0}")]
    AlreadyExists(String),
    #[error("database error: {0}")]
    Database(#[from] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum UpdateSkillTypeError {
    #[error("skill type not found: {0}")]
    NotFound(String),
    #[error("database error: {0}")]
    Database(#[from] sqlx::Error),
}

// User skill certification errors
#[derive(Debug, Error)]
pub enum CertifySkillError {
    #[error("skill type not found: {0}")]
    SkillTypeNotFound(String),
    #[error("user not found: {0}")]
    UserNotFound(UserId),
    #[error("user already has this skill")]
    AlreadyCertified,
    #[error("invalid proficiency level for this skill type")]
    InvalidProficiency,
    #[error("database error: {0}")]
    Database(#[from] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum RevokeSkillError {
    #[error("certification not found")]
    NotFound,
    #[error("database error: {0}")]
    Database(#[from] sqlx::Error),
}
```

Add to libs/db/src/repo/traits.rs:
```rust
use glyph_domain::{SkillType, UserId};
use crate::repo::errors::*;

/// Input for creating a skill type
#[derive(Debug, Clone)]
pub struct NewSkillType {
    pub skill_id: String,
    pub name: String,
    pub description: Option<String>,
    pub expiration_months: Option<i32>,
    pub grace_period_days: i32,
    pub requires_proficiency: bool,
    pub proficiency_levels: Option<Vec<String>>,
}

/// Input for updating a skill type
#[derive(Debug, Clone, Default)]
pub struct SkillTypeUpdate {
    pub name: Option<String>,
    pub description: Option<String>,
    pub expiration_months: Option<Option<i32>>,  // None = no change, Some(None) = clear
    pub grace_period_days: Option<i32>,
    pub requires_proficiency: Option<bool>,
    pub proficiency_levels: Option<Option<Vec<String>>>,
}

/// Input for certifying a user skill
#[derive(Debug, Clone)]
pub struct CertifyUserSkill {
    pub user_id: UserId,
    pub skill_id: String,
    pub proficiency_level: Option<String>,
    pub certified_by: UserId,
    pub notes: Option<String>,
}

/// User skill with computed status from view
#[derive(Debug, Clone)]
pub struct UserSkillWithStatus {
    pub certification_id: uuid::Uuid,
    pub user_id: UserId,
    pub skill_id: String,
    pub skill_name: String,
    pub proficiency_level: Option<String>,
    pub certified_by: Option<UserId>,
    pub certified_at: chrono::DateTime<chrono::Utc>,
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    pub notes: Option<String>,
    pub grace_period_days: i32,
    pub status: String,  // active, soft_expired, hard_expired, never_expires
}

/// Repository for skill operations
#[async_trait::async_trait]
pub trait SkillRepository: Send + Sync {
    // Skill types
    async fn create_skill_type(&self, skill_type: &NewSkillType) -> Result<SkillType, CreateSkillTypeError>;
    async fn find_skill_type(&self, skill_id: &str) -> Result<Option<SkillType>, FindSkillTypeError>;
    async fn list_skill_types(&self) -> Result<Vec<SkillType>, sqlx::Error>;
    async fn update_skill_type(&self, skill_id: &str, update: &SkillTypeUpdate) -> Result<SkillType, UpdateSkillTypeError>;
    
    // User skill certifications
    async fn certify_skill(&self, cert: &CertifyUserSkill) -> Result<UserSkillWithStatus, CertifySkillError>;
    async fn revoke_skill(&self, user_id: &UserId, skill_id: &str) -> Result<(), RevokeSkillError>;
    async fn list_user_skills(&self, user_id: &UserId) -> Result<Vec<UserSkillWithStatus>, sqlx::Error>;
    async fn get_user_skill(&self, user_id: &UserId, skill_id: &str) -> Result<Option<UserSkillWithStatus>, sqlx::Error>;
}
```

Create libs/db/src/repo/pg_skill.rs implementing SkillRepository:
```rust
//! PostgreSQL implementation of SkillRepository

use async_trait::async_trait;
use chrono::{Duration, Utc};
use sqlx::PgPool;
use uuid::Uuid;

use glyph_domain::{SkillType, UserId};
use crate::audit::{AuditAction, AuditActorType, AuditEvent, AuditWriter, SYSTEM_ACTOR_ID};
use crate::repo::errors::*;
use crate::repo::traits::*;

pub struct PgSkillRepository {
    pool: PgPool,
    audit: AuditWriter,
}

impl PgSkillRepository {
    pub fn new(pool: PgPool) -> Self {
        let audit = AuditWriter::new(pool.clone());
        Self { pool, audit }
    }
}

#[async_trait]
impl SkillRepository for PgSkillRepository {
    async fn create_skill_type(&self, st: &NewSkillType) -> Result<SkillType, CreateSkillTypeError> {
        // Check for existing
        let existing = sqlx::query_scalar::<_, String>(
            "SELECT skill_id FROM skill_types WHERE skill_id = $1"
        )
        .bind(&st.skill_id)
        .fetch_optional(&self.pool)
        .await?;
        
        if existing.is_some() {
            return Err(CreateSkillTypeError::AlreadyExists(st.skill_id.clone()));
        }
        
        let row = sqlx::query_as::<_, SkillTypeRow>(
            r#"
            INSERT INTO skill_types (skill_id, name, description, expiration_months, 
                                     grace_period_days, requires_proficiency, proficiency_levels)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            RETURNING *
            "#
        )
        .bind(&st.skill_id)
        .bind(&st.name)
        .bind(&st.description)
        .bind(st.expiration_months)
        .bind(st.grace_period_days)
        .bind(st.requires_proficiency)
        .bind(serde_json::to_value(&st.proficiency_levels).ok())
        .fetch_one(&self.pool)
        .await?;
        
        Ok(row.into())
    }
    
    async fn find_skill_type(&self, skill_id: &str) -> Result<Option<SkillType>, FindSkillTypeError> {
        let row = sqlx::query_as::<_, SkillTypeRow>(
            "SELECT * FROM skill_types WHERE skill_id = $1"
        )
        .bind(skill_id)
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(row.map(Into::into))
    }
    
    async fn list_skill_types(&self) -> Result<Vec<SkillType>, sqlx::Error> {
        let rows = sqlx::query_as::<_, SkillTypeRow>(
            "SELECT * FROM skill_types ORDER BY name"
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(rows.into_iter().map(Into::into).collect())
    }
    
    async fn update_skill_type(&self, skill_id: &str, update: &SkillTypeUpdate) -> Result<SkillType, UpdateSkillTypeError> {
        let row = sqlx::query_as::<_, SkillTypeRow>(
            r#"
            UPDATE skill_types SET
                name = COALESCE($2, name),
                description = COALESCE($3, description),
                expiration_months = COALESCE($4, expiration_months),
                grace_period_days = COALESCE($5, grace_period_days),
                requires_proficiency = COALESCE($6, requires_proficiency),
                proficiency_levels = COALESCE($7, proficiency_levels),
                updated_at = NOW()
            WHERE skill_id = $1
            RETURNING *
            "#
        )
        .bind(skill_id)
        .bind(&update.name)
        .bind(&update.description)
        .bind(update.expiration_months.flatten())
        .bind(update.grace_period_days)
        .bind(update.requires_proficiency)
        .bind(update.proficiency_levels.as_ref().and_then(|p| serde_json::to_value(p).ok()))
        .fetch_optional(&self.pool)
        .await?
        .ok_or_else(|| UpdateSkillTypeError::NotFound(skill_id.to_string()))?;
        
        Ok(row.into())
    }
    
    async fn certify_skill(&self, cert: &CertifyUserSkill) -> Result<UserSkillWithStatus, CertifySkillError> {
        // Load skill type for expiration and proficiency validation
        let skill_type = self.find_skill_type(&cert.skill_id).await
            .map_err(|e| CertifySkillError::Database(match e {
                FindSkillTypeError::Database(e) => e,
                _ => sqlx::Error::RowNotFound,
            }))?
            .ok_or_else(|| CertifySkillError::SkillTypeNotFound(cert.skill_id.clone()))?;
        
        // Validate proficiency level
        if skill_type.requires_proficiency {
            match (&cert.proficiency_level, &skill_type.proficiency_levels) {
                (None, _) => return Err(CertifySkillError::InvalidProficiency),
                (Some(level), Some(levels)) if !levels.contains(level) => {
                    return Err(CertifySkillError::InvalidProficiency);
                }
                _ => {}
            }
        }
        
        // Compute expires_at
        let expires_at = skill_type.expiration_months.map(|months| {
            Utc::now() + Duration::days(months as i64 * 30)
        });
        
        // Insert certification
        let certification_id = Uuid::now_v7();
        sqlx::query(
            r#"
            INSERT INTO user_skills (certification_id, user_id, skill_id, proficiency_level, 
                                     certified_by, expires_at, notes)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            ON CONFLICT (user_id, skill_id) DO UPDATE SET
                proficiency_level = EXCLUDED.proficiency_level,
                certified_by = EXCLUDED.certified_by,
                certified_at = NOW(),
                expires_at = EXCLUDED.expires_at,
                notes = EXCLUDED.notes
            "#
        )
        .bind(certification_id.to_string())
        .bind(cert.user_id.to_string())
        .bind(&cert.skill_id)
        .bind(&cert.proficiency_level)
        .bind(cert.certified_by.to_string())
        .bind(expires_at)
        .bind(&cert.notes)
        .execute(&self.pool)
        .await?;
        
        // Return from view
        self.get_user_skill(&cert.user_id, &cert.skill_id).await
            .map_err(CertifySkillError::Database)?
            .ok_or(CertifySkillError::Database(sqlx::Error::RowNotFound))
    }
    
    async fn revoke_skill(&self, user_id: &UserId, skill_id: &str) -> Result<(), RevokeSkillError> {
        let result = sqlx::query(
            "DELETE FROM user_skills WHERE user_id = $1 AND skill_id = $2"
        )
        .bind(user_id.to_string())
        .bind(skill_id)
        .execute(&self.pool)
        .await?;
        
        if result.rows_affected() == 0 {
            return Err(RevokeSkillError::NotFound);
        }
        
        Ok(())
    }
    
    async fn list_user_skills(&self, user_id: &UserId) -> Result<Vec<UserSkillWithStatus>, sqlx::Error> {
        let rows = sqlx::query_as::<_, UserSkillRow>(
            "SELECT * FROM user_skills_with_status WHERE user_id = $1 ORDER BY skill_name"
        )
        .bind(user_id.to_string())
        .fetch_all(&self.pool)
        .await?;
        
        Ok(rows.into_iter().filter_map(|r| r.try_into().ok()).collect())
    }
    
    async fn get_user_skill(&self, user_id: &UserId, skill_id: &str) -> Result<Option<UserSkillWithStatus>, sqlx::Error> {
        let row = sqlx::query_as::<_, UserSkillRow>(
            "SELECT * FROM user_skills_with_status WHERE user_id = $1 AND skill_id = $2"
        )
        .bind(user_id.to_string())
        .bind(skill_id)
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(row.and_then(|r| r.try_into().ok()))
    }
}

// Row types for SQLx
#[derive(sqlx::FromRow)]
struct SkillTypeRow {
    skill_id: String,
    name: String,
    description: Option<String>,
    expiration_months: Option<i32>,
    grace_period_days: i32,
    requires_proficiency: bool,
    proficiency_levels: Option<serde_json::Value>,
    created_at: chrono::DateTime<chrono::Utc>,
    updated_at: chrono::DateTime<chrono::Utc>,
}

impl From<SkillTypeRow> for SkillType {
    fn from(r: SkillTypeRow) -> Self {
        Self {
            skill_id: r.skill_id,
            name: r.name,
            description: r.description,
            expiration_months: r.expiration_months,
            grace_period_days: r.grace_period_days,
            requires_proficiency: r.requires_proficiency,
            proficiency_levels: r.proficiency_levels.and_then(|v| serde_json::from_value(v).ok()),
            created_at: r.created_at,
            updated_at: r.updated_at,
        }
    }
}

#[derive(sqlx::FromRow)]
struct UserSkillRow {
    certification_id: String,
    user_id: String,
    skill_id: String,
    skill_name: String,
    proficiency_level: Option<String>,
    certified_by: Option<String>,
    certified_at: chrono::DateTime<chrono::Utc>,
    expires_at: Option<chrono::DateTime<chrono::Utc>>,
    notes: Option<String>,
    grace_period_days: i32,
    status: String,
}

impl TryFrom<UserSkillRow> for UserSkillWithStatus {
    type Error = glyph_domain::IdParseError;
    
    fn try_from(r: UserSkillRow) -> Result<Self, Self::Error> {
        Ok(Self {
            certification_id: r.certification_id.parse().unwrap_or_default(),
            user_id: r.user_id.parse()?,
            skill_id: r.skill_id,
            skill_name: r.skill_name,
            proficiency_level: r.proficiency_level,
            certified_by: r.certified_by.map(|s| s.parse()).transpose()?,
            certified_at: r.certified_at,
            expires_at: r.expires_at,
            notes: r.notes,
            grace_period_days: r.grace_period_days,
            status: r.status,
        })
    }
}
```

Update libs/db/src/repo/mod.rs to export PgSkillRepository.
  </action>
  <verify>`cargo check -p glyph-db` compiles.</verify>
  <done>Skill repository trait and PostgreSQL implementation complete</done>
</task>

<task type="auto">
  <name>Task 2: Create skill management endpoints</name>
  <files>apps/api/src/routes/skills.rs, apps/api/src/routes/mod.rs</files>
  <action>
Create apps/api/src/routes/skills.rs:

```rust
//! Skill type and certification management endpoints

use std::sync::Arc;
use axum::{
    extract::{Path, State},
    http::StatusCode,
    Json,
};
use glyph_db::{SkillRepository, NewSkillType, SkillTypeUpdate, CertifyUserSkill, UserSkillWithStatus};
use glyph_domain::{UserId, SkillType};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

use crate::{error::ApiError, extractors::{CurrentUser, RequireAdmin}, services::PermissionService};

// === Skill Type Endpoints (Admin only) ===

#[derive(Debug, Deserialize, ToSchema)]
pub struct CreateSkillTypeRequest {
    pub skill_id: String,  // e.g., "medical_translation"
    pub name: String,
    pub description: Option<String>,
    pub expiration_months: Option<i32>,
    #[serde(default)]
    pub grace_period_days: i32,
    #[serde(default)]
    pub requires_proficiency: bool,
    pub proficiency_levels: Option<Vec<String>>,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct UpdateSkillTypeRequest {
    pub name: Option<String>,
    pub description: Option<String>,
    pub expiration_months: Option<i32>,
    pub grace_period_days: Option<i32>,
    pub requires_proficiency: Option<bool>,
    pub proficiency_levels: Option<Vec<String>>,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct SkillTypeResponse {
    pub skill_id: String,
    pub name: String,
    pub description: Option<String>,
    pub expiration_months: Option<i32>,
    pub grace_period_days: i32,
    pub requires_proficiency: bool,
    pub proficiency_levels: Option<Vec<String>>,
    pub created_at: String,
    pub updated_at: String,
}

impl From<SkillType> for SkillTypeResponse {
    fn from(st: SkillType) -> Self {
        Self {
            skill_id: st.skill_id,
            name: st.name,
            description: st.description,
            expiration_months: st.expiration_months,
            grace_period_days: st.grace_period_days,
            requires_proficiency: st.requires_proficiency,
            proficiency_levels: st.proficiency_levels,
            created_at: st.created_at.to_rfc3339(),
            updated_at: st.updated_at.to_rfc3339(),
        }
    }
}

#[utoipa::path(
    post,
    path = "/skills/types",
    tag = "skills",
    request_body = CreateSkillTypeRequest,
    responses(
        (status = 201, description = "Skill type created", body = SkillTypeResponse),
        (status = 400, description = "Invalid request"),
        (status = 409, description = "Skill type already exists"),
        (status = 403, description = "Admin only")
    )
)]
pub async fn create_skill_type(
    RequireAdmin(_admin): RequireAdmin,
    Json(body): Json<CreateSkillTypeRequest>,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
) -> Result<(StatusCode, Json<SkillTypeResponse>), ApiError> {
    // Validate skill_id format (alphanumeric + underscore)
    if !body.skill_id.chars().all(|c| c.is_alphanumeric() || c == '_') {
        return Err(ApiError::bad_request("skill.id.invalid", "Skill ID must be alphanumeric with underscores"));
    }
    
    let skill_type = repo.create_skill_type(&NewSkillType {
        skill_id: body.skill_id,
        name: body.name,
        description: body.description,
        expiration_months: body.expiration_months,
        grace_period_days: body.grace_period_days,
        requires_proficiency: body.requires_proficiency,
        proficiency_levels: body.proficiency_levels,
    }).await
    .map_err(|e| match e {
        glyph_db::CreateSkillTypeError::AlreadyExists(id) => 
            ApiError::conflict("skill.type.exists", format!("Skill type already exists: {}", id)),
        glyph_db::CreateSkillTypeError::Database(e) => 
            ApiError::Internal(anyhow::anyhow!("{}", e)),
    })?;
    
    Ok((StatusCode::CREATED, Json(SkillTypeResponse::from(skill_type))))
}

#[utoipa::path(
    get,
    path = "/skills/types",
    tag = "skills",
    responses(
        (status = 200, description = "List of skill types", body = Vec<SkillTypeResponse>)
    )
)]
pub async fn list_skill_types(
    _user: CurrentUser,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
) -> Result<Json<Vec<SkillTypeResponse>>, ApiError> {
    let types = repo.list_skill_types().await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    Ok(Json(types.into_iter().map(SkillTypeResponse::from).collect()))
}

#[utoipa::path(
    get,
    path = "/skills/types/{skill_id}",
    tag = "skills",
    params(("skill_id" = String, Path, description = "Skill type ID")),
    responses(
        (status = 200, description = "Skill type found", body = SkillTypeResponse),
        (status = 404, description = "Skill type not found")
    )
)]
pub async fn get_skill_type(
    _user: CurrentUser,
    Path(skill_id): Path<String>,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
) -> Result<Json<SkillTypeResponse>, ApiError> {
    let skill_type = repo.find_skill_type(&skill_id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::not_found("skill_type", skill_id))?;
    Ok(Json(SkillTypeResponse::from(skill_type)))
}

#[utoipa::path(
    patch,
    path = "/skills/types/{skill_id}",
    tag = "skills",
    params(("skill_id" = String, Path, description = "Skill type ID")),
    request_body = UpdateSkillTypeRequest,
    responses(
        (status = 200, description = "Skill type updated", body = SkillTypeResponse),
        (status = 404, description = "Skill type not found"),
        (status = 403, description = "Admin only")
    )
)]
pub async fn update_skill_type(
    RequireAdmin(_admin): RequireAdmin,
    Path(skill_id): Path<String>,
    Json(body): Json<UpdateSkillTypeRequest>,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
) -> Result<Json<SkillTypeResponse>, ApiError> {
    let skill_type = repo.update_skill_type(&skill_id, &SkillTypeUpdate {
        name: body.name,
        description: body.description,
        expiration_months: body.expiration_months.map(Some),
        grace_period_days: body.grace_period_days,
        requires_proficiency: body.requires_proficiency,
        proficiency_levels: body.proficiency_levels.map(Some),
    }).await
    .map_err(|e| match e {
        glyph_db::UpdateSkillTypeError::NotFound(id) => ApiError::not_found("skill_type", id),
        glyph_db::UpdateSkillTypeError::Database(e) => ApiError::Internal(anyhow::anyhow!("{}", e)),
    })?;
    Ok(Json(SkillTypeResponse::from(skill_type)))
}

// === User Skill Certification Endpoints ===

#[derive(Debug, Deserialize, ToSchema)]
pub struct CertifySkillRequest {
    pub proficiency_level: Option<String>,
    pub notes: Option<String>,
}

#[derive(Debug, Serialize, ToSchema)]
pub struct UserSkillResponse {
    pub certification_id: String,
    pub skill_id: String,
    pub skill_name: String,
    pub proficiency_level: Option<String>,
    pub certified_by: Option<String>,
    pub certified_at: String,
    pub expires_at: Option<String>,
    pub status: String,
}

impl From<UserSkillWithStatus> for UserSkillResponse {
    fn from(s: UserSkillWithStatus) -> Self {
        Self {
            certification_id: s.certification_id.to_string(),
            skill_id: s.skill_id,
            skill_name: s.skill_name,
            proficiency_level: s.proficiency_level,
            certified_by: s.certified_by.map(|id| id.to_string()),
            certified_at: s.certified_at.to_rfc3339(),
            expires_at: s.expires_at.map(|t| t.to_rfc3339()),
            status: s.status,
        }
    }
}

#[utoipa::path(
    post,
    path = "/users/{user_id}/skills/{skill_id}",
    tag = "skills",
    params(
        ("user_id" = String, Path, description = "Target user ID"),
        ("skill_id" = String, Path, description = "Skill type ID")
    ),
    request_body = CertifySkillRequest,
    responses(
        (status = 201, description = "Skill certified", body = UserSkillResponse),
        (status = 400, description = "Invalid proficiency level"),
        (status = 403, description = "Requires admin or skill:certifier role"),
        (status = 404, description = "User or skill type not found")
    )
)]
pub async fn certify_user_skill(
    current_user: CurrentUser,
    Path((user_id, skill_id)): Path<(String, String)>,
    Json(body): Json<CertifySkillRequest>,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
    State(permission_service): State<Arc<PermissionService>>,
) -> Result<(StatusCode, Json<UserSkillResponse>), ApiError> {
    // Check certifier permission
    if !permission_service.can_certify_skills(&current_user) {
        return Err(ApiError::Forbidden {
            permission: "role:admin or role:skill:certifier".to_string(),
        });
    }
    
    let target_user_id: UserId = user_id.parse()?;
    
    let cert = repo.certify_skill(&CertifyUserSkill {
        user_id: target_user_id,
        skill_id,
        proficiency_level: body.proficiency_level,
        certified_by: current_user.user_id,
        notes: body.notes,
    }).await
    .map_err(|e| match e {
        glyph_db::CertifySkillError::SkillTypeNotFound(id) => 
            ApiError::not_found("skill_type", id),
        glyph_db::CertifySkillError::UserNotFound(id) => 
            ApiError::not_found("user", id.to_string()),
        glyph_db::CertifySkillError::InvalidProficiency => 
            ApiError::bad_request("skill.proficiency.invalid", "Invalid proficiency level for this skill type"),
        glyph_db::CertifySkillError::AlreadyCertified => 
            ApiError::conflict("skill.already_certified", "User already has this skill (will be updated)"),
        glyph_db::CertifySkillError::Database(e) => 
            ApiError::Internal(anyhow::anyhow!("{}", e)),
    })?;
    
    Ok((StatusCode::CREATED, Json(UserSkillResponse::from(cert))))
}

#[utoipa::path(
    delete,
    path = "/users/{user_id}/skills/{skill_id}",
    tag = "skills",
    params(
        ("user_id" = String, Path, description = "Target user ID"),
        ("skill_id" = String, Path, description = "Skill type ID")
    ),
    responses(
        (status = 204, description = "Skill revoked"),
        (status = 403, description = "Requires admin or skill:certifier role"),
        (status = 404, description = "Certification not found")
    )
)]
pub async fn revoke_user_skill(
    current_user: CurrentUser,
    Path((user_id, skill_id)): Path<(String, String)>,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
    State(permission_service): State<Arc<PermissionService>>,
) -> Result<StatusCode, ApiError> {
    if !permission_service.can_certify_skills(&current_user) {
        return Err(ApiError::Forbidden {
            permission: "role:admin or role:skill:certifier".to_string(),
        });
    }
    
    let target_user_id: UserId = user_id.parse()?;
    repo.revoke_skill(&target_user_id, &skill_id).await
        .map_err(|e| match e {
            glyph_db::RevokeSkillError::NotFound => 
                ApiError::not_found("user_skill", format!("{}:{}", user_id, skill_id)),
            glyph_db::RevokeSkillError::Database(e) => 
                ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    Ok(StatusCode::NO_CONTENT)
}

#[utoipa::path(
    get,
    path = "/users/{user_id}/skills",
    tag = "skills",
    params(("user_id" = String, Path, description = "User ID")),
    responses(
        (status = 200, description = "User skills list", body = Vec<UserSkillResponse>)
    )
)]
pub async fn list_user_skills(
    _user: CurrentUser,
    Path(user_id): Path<String>,
    State(repo): State<Arc<dyn SkillRepository + Send + Sync>>,
) -> Result<Json<Vec<UserSkillResponse>>, ApiError> {
    let target_user_id: UserId = user_id.parse()?;
    let skills = repo.list_user_skills(&target_user_id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    Ok(Json(skills.into_iter().map(UserSkillResponse::from).collect()))
}

/// Skill type routes
pub fn skill_type_routes() -> axum::Router {
    use axum::routing::{get, post, patch};
    
    axum::Router::new()
        .route("/", get(list_skill_types).post(create_skill_type))
        .route("/{skill_id}", get(get_skill_type).patch(update_skill_type))
}

/// User skill routes (nested under /users/{user_id}/skills)
pub fn user_skill_routes() -> axum::Router {
    use axum::routing::{get, post, delete};
    
    axum::Router::new()
        .route("/", get(list_user_skills))
        .route("/{skill_id}", post(certify_user_skill).delete(revoke_user_skill))
}
```

Update apps/api/src/routes/mod.rs:
- Add `mod skills;`
- Export skill routes
- Update api_v1_routes to include:
  - `.nest("/skills/types", skills::skill_type_routes())`
  - `.nest("/users/{user_id}/skills", skills::user_skill_routes())` (or handle in users routes)
  </action>
  <verify>`cargo check -p glyph-api` compiles.</verify>
  <done>Skill management endpoints created with proper authorization</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for skill expiration and validation</name>
  <files>libs/db/src/repo/pg_skill.rs</files>
  <action>
Add tests to pg_skill.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;

    #[test]
    fn test_expiration_computation() {
        let months = 6;
        let expected_days = months * 30;
        let expires_at = Utc::now() + Duration::days(expected_days as i64);
        
        // Verify computation is approximately correct (within 1 day)
        let diff = (expires_at - Utc::now()).num_days();
        assert!(diff >= expected_days - 1 && diff <= expected_days + 1);
    }
    
    #[test]
    fn test_skill_status_logic() {
        // Test active
        let expires_at = Utc::now() + Duration::days(30);
        let grace_period_days = 7;
        let now = Utc::now();
        
        // Before expiration = active
        assert!(now < expires_at);
        
        // After expiration but within grace = soft_expired
        let grace_end = expires_at + Duration::days(grace_period_days as i64);
        let after_expiry = expires_at + Duration::days(1);
        assert!(after_expiry < grace_end);
        
        // After grace = hard_expired
        let after_grace = grace_end + Duration::days(1);
        assert!(after_grace > grace_end);
    }
}
```

These tests verify the expiration computation logic matches the database view.
  </action>
  <verify>`cargo test -p glyph-db` passes skill tests.</verify>
  <done>Skill certification tests verify expiration logic</done>
</task>

</tasks>

<verification>
- `cargo check` passes for all crates
- GET /api/v1/skills/types returns list of skill types
- POST /api/v1/skills/types creates skill type (admin only)
- POST /api/v1/users/{id}/skills/{skill_id} certifies user skill (certifier only)
- DELETE /api/v1/users/{id}/skills/{skill_id} revokes skill
- GET /api/v1/users/{id}/skills returns skills with computed status
</verification>

<success_criteria>
- Skill types can be configured with expiration and proficiency
- Certifiers can grant skills to users
- Skills are revokable
- Expiration is computed at certification time
- Status (active/soft-expired/hard-expired) is computed dynamically
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-team-management/04-04-SUMMARY.md`
</output>
