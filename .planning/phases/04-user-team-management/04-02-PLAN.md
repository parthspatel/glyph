---
phase: 04-user-team-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/extractors/mod.rs
  - apps/api/src/extractors/require_admin.rs
  - apps/api/src/extractors/require_team_lead.rs
  - apps/api/src/services/mod.rs
  - apps/api/src/services/permission_service.rs
  - apps/api/src/error.rs
autonomous: true

must_haves:
  truths:
    - "Admin-only routes can use RequireAdmin extractor"
    - "Team operations can use RequireTeamLead extractor with cascade"
    - "Permission denial returns verbose message with required permission"
  artifacts:
    - path: "apps/api/src/extractors/require_admin.rs"
      provides: "RequireAdmin extractor checking global admin role"
      exports: ["RequireAdmin"]
    - path: "apps/api/src/extractors/require_team_lead.rs"
      provides: "RequireTeamLead extractor with hierarchy cascade"
      exports: ["RequireTeamLead"]
    - path: "apps/api/src/services/permission_service.rs"
      provides: "Permission checking functions with recursive CTE"
      exports: ["check_team_leadership_cascade"]
  key_links:
    - from: "apps/api/src/extractors/require_team_lead.rs"
      to: "apps/api/src/services/permission_service.rs"
      via: "calls check_team_leadership_cascade"
      pattern: "check_team_leadership_cascade"
---

<objective>
Create RBAC permission extractors for admin and team-scoped operations.

Purpose: Enable declarative permission checks on route handlers. Admin routes use RequireAdmin, team operations use RequireTeamLead with automatic cascade to sub-teams.
Output: Two new extractors and supporting permission service.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-user-team-management/04-CONTEXT.md
@.planning/phases/04-user-team-management/04-RESEARCH.md
@apps/api/src/extractors/current_user.rs
@apps/api/src/error.rs
@libs/db/src/pool.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RequireAdmin extractor and update error types</name>
  <files>apps/api/src/extractors/require_admin.rs, apps/api/src/extractors/mod.rs, apps/api/src/error.rs</files>
  <action>
First, update apps/api/src/error.rs to support verbose permission denial:
- Add new variant or update Forbidden to include required permission:
  ```rust
  #[error("forbidden: requires {permission}")]
  Forbidden { permission: String },
  ```
- Update error_code() to return "auth.forbidden"
- Update IntoResponse to include permission in detail message

Create apps/api/src/extractors/require_admin.rs:
```rust
//! RequireAdmin extractor for admin-only routes.

use axum::{async_trait, extract::FromRequestParts, http::request::Parts};
use crate::{error::ApiError, extractors::CurrentUser};

/// Extractor that requires the current user to have Admin role.
/// 
/// Usage:
/// ```ignore
/// async fn admin_endpoint(RequireAdmin(user): RequireAdmin) -> impl IntoResponse {
///     // user is guaranteed to be admin
/// }
/// ```
pub struct RequireAdmin(pub CurrentUser);

#[async_trait]
impl<S> FromRequestParts<S> for RequireAdmin
where
    S: Send + Sync,
{
    type Rejection = ApiError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        let user = CurrentUser::from_request_parts(parts, state).await?;
        
        if !user.has_role("admin") {
            return Err(ApiError::Forbidden {
                permission: "role:admin".to_string(),
            });
        }
        
        Ok(RequireAdmin(user))
    }
}
```

Update apps/api/src/extractors/mod.rs to export RequireAdmin:
```rust
mod current_user;
mod require_admin;

pub use current_user::{AuthState, CurrentUser};
pub use require_admin::RequireAdmin;
```
  </action>
  <verify>`cargo check -p glyph-api` compiles. Write a simple test route using RequireAdmin.</verify>
  <done>RequireAdmin extractor available, ApiError supports verbose permission denial</done>
</task>

<task type="auto">
  <name>Task 2: Create permission service with team hierarchy check</name>
  <files>apps/api/src/services/mod.rs, apps/api/src/services/permission_service.rs</files>
  <action>
Create apps/api/src/services/mod.rs (new directory):
```rust
//! Business logic services
pub mod permission_service;

pub use permission_service::PermissionService;
```

Create apps/api/src/services/permission_service.rs:
```rust
//! Permission checking service with team hierarchy support.

use glyph_domain::{TeamId, UserId};
use sqlx::PgPool;

/// Service for checking user permissions with team hierarchy cascade.
pub struct PermissionService {
    pool: PgPool,
}

impl PermissionService {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    /// Check if user leads the given team OR any of its parent teams.
    /// Leadership cascades downward: leading a parent team grants leadership of all sub-teams.
    pub async fn check_team_leadership_cascade(
        &self,
        user_id: &UserId,
        team_id: &TeamId,
    ) -> Result<bool, sqlx::Error> {
        // Use recursive CTE to traverse up the team hierarchy
        let result = sqlx::query_scalar::<_, bool>(
            r#"
            WITH RECURSIVE parent_teams AS (
                -- Start with the target team
                SELECT team_id, parent_team_id 
                FROM teams 
                WHERE team_id = $1 AND status != 'deleted'
                
                UNION ALL
                
                -- Recursively get parent teams
                SELECT t.team_id, t.parent_team_id
                FROM teams t
                JOIN parent_teams pt ON t.team_id = pt.parent_team_id
                WHERE t.status != 'deleted'
            )
            SELECT EXISTS(
                SELECT 1 
                FROM team_memberships tm
                JOIN parent_teams pt ON tm.team_id = pt.team_id
                WHERE tm.user_id = $2 AND tm.role = 'leader'
            )
            "#,
        )
        .bind(team_id.to_string())
        .bind(user_id.to_string())
        .fetch_one(&self.pool)
        .await?;

        Ok(result)
    }

    /// Check if user is a member of the given team (any role).
    pub async fn check_team_membership(
        &self,
        user_id: &UserId,
        team_id: &TeamId,
    ) -> Result<bool, sqlx::Error> {
        let result = sqlx::query_scalar::<_, bool>(
            r#"
            SELECT EXISTS(
                SELECT 1 FROM team_memberships
                WHERE team_id = $1 AND user_id = $2
            )
            "#,
        )
        .bind(team_id.to_string())
        .bind(user_id.to_string())
        .fetch_one(&self.pool)
        .await?;

        Ok(result)
    }

    /// Check if user can certify skills (either admin or has skill:certifier permission).
    pub fn can_certify_skills(&self, user: &crate::extractors::CurrentUser) -> bool {
        user.has_any_role(&["admin", "skill:certifier"])
    }
}
```

Update apps/api/src/lib.rs to include services module.
  </action>
  <verify>`cargo check -p glyph-api` compiles. The recursive CTE query compiles with sqlx (may need to run `cargo sqlx prepare` if using compile-time checking).</verify>
  <done>PermissionService provides team hierarchy checks via recursive CTE</done>
</task>

<task type="auto">
  <name>Task 3: Create RequireTeamLead extractor</name>
  <files>apps/api/src/extractors/require_team_lead.rs, apps/api/src/extractors/mod.rs</files>
  <action>
Create apps/api/src/extractors/require_team_lead.rs:
```rust
//! RequireTeamLead extractor for team-scoped operations.

use axum::{
    async_trait,
    extract::{FromRequestParts, Path},
    http::request::Parts,
};
use glyph_domain::TeamId;

use crate::{error::ApiError, extractors::CurrentUser, services::PermissionService};

/// Extractor that requires the current user to lead the specified team.
/// 
/// Leadership cascades: if user leads a parent team, they lead all sub-teams.
/// Admins automatically pass this check.
///
/// Extracts team_id from path parameter named "team_id".
///
/// Usage:
/// ```ignore
/// async fn team_endpoint(
///     RequireTeamLead { user, team_id }: RequireTeamLead
/// ) -> impl IntoResponse {
///     // user is guaranteed to lead this team
/// }
/// ```
pub struct RequireTeamLead {
    pub user: CurrentUser,
    pub team_id: TeamId,
}

#[async_trait]
impl<S> FromRequestParts<S> for RequireTeamLead
where
    S: Send + Sync,
{
    type Rejection = ApiError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        // Get current user first
        let user = CurrentUser::from_request_parts(parts, state).await?;

        // Extract team_id from path - look for team_ prefix in path segments
        let team_id_str = parts.uri.path()
            .split('/')
            .find(|s| s.starts_with("team_"))
            .ok_or_else(|| ApiError::bad_request("path.team_id.missing", "Team ID not found in path"))?;

        let team_id: TeamId = team_id_str.parse().map_err(|e: glyph_domain::IdParseError| {
            ApiError::bad_request("team.id.invalid", e.to_string())
        })?;

        // Admins bypass team leadership check
        if user.has_role("admin") {
            return Ok(RequireTeamLead { user, team_id });
        }

        // Get database pool from extensions
        let pool = parts
            .extensions
            .get::<sqlx::PgPool>()
            .ok_or_else(|| ApiError::Internal(anyhow::anyhow!("Database pool not configured")))?
            .clone();

        let permission_service = PermissionService::new(pool);

        // Check team leadership with cascade
        let has_permission = permission_service
            .check_team_leadership_cascade(&user.user_id, &team_id)
            .await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("Permission check failed: {}", e)))?;

        if !has_permission {
            return Err(ApiError::Forbidden {
                permission: format!("team:lead({})", team_id),
            });
        }

        Ok(RequireTeamLead { user, team_id })
    }
}
```

Update apps/api/src/extractors/mod.rs:
```rust
mod current_user;
mod require_admin;
mod require_team_lead;

pub use current_user::{AuthState, CurrentUser};
pub use require_admin::RequireAdmin;
pub use require_team_lead::RequireTeamLead;
```
  </action>
  <verify>`cargo check -p glyph-api` compiles. Write integration test that checks RequireTeamLead works with nested team hierarchy.</verify>
  <done>RequireTeamLead extractor checks team leadership with parent cascade</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-api` passes
- `cargo test -p glyph-api` passes (if tests exist)
- RequireAdmin is exported from extractors module
- RequireTeamLead is exported from extractors module
- PermissionService is exported from services module
- ApiError::Forbidden includes permission string in response
</verification>

<success_criteria>
- RequireAdmin extractor rejects non-admin users with "requires role:admin"
- RequireTeamLead extractor checks team hierarchy via recursive CTE
- Admins bypass RequireTeamLead check (global admin override)
- Permission denial messages are verbose and actionable
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-team-management/04-02-SUMMARY.md`
</output>
