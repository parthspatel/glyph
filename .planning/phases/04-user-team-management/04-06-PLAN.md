---
phase: 04-user-team-management
plan: 06
type: execute
wave: 3
depends_on: ["04-02", "04-05"]
files_modified:
  - apps/api/src/routes/teams.rs
  - libs/db/src/repo/pg_team.rs
autonomous: true

must_haves:
  truths:
    - "Team leaders can add/remove members"
    - "Members can be promoted to leader role"
    - "Teams can have multiple leaders"
    - "Membership changes are audited"
  artifacts:
    - path: "apps/api/src/routes/teams.rs"
      provides: "Team membership management endpoints"
      exports: ["list_team_members", "add_team_member", "remove_team_member", "update_team_member"]
  key_links:
    - from: "apps/api/src/routes/teams.rs"
      to: "apps/api/src/extractors/require_team_lead.rs"
      via: "RequireTeamLead for authorization"
      pattern: "RequireTeamLead"
---

<objective>
Implement team membership management with RBAC authorization.

Purpose: Enable team leaders to manage their team membership, add/remove users, and promote members to leaders.
Output: Team membership endpoints with proper cascade-aware authorization.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-user-team-management/04-CONTEXT.md
@.planning/phases/04-user-team-management/04-02-PLAN.md
@.planning/phases/04-user-team-management/04-05-PLAN.md
@apps/api/src/routes/teams.rs
@apps/api/src/extractors/require_team_lead.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add team membership endpoints</name>
  <files>apps/api/src/routes/teams.rs</files>
  <action>
Add membership management endpoints to apps/api/src/routes/teams.rs:

```rust
// === Team Membership Endpoints ===

#[derive(Debug, Serialize, ToSchema)]
pub struct TeamMemberResponse {
    pub user_id: String,
    pub display_name: String,
    pub email: String,
    pub role: String,
    pub joined_at: String,
    pub allocation_percentage: Option<i32>,
}

impl From<TeamMembershipWithUser> for TeamMemberResponse {
    fn from(m: TeamMembershipWithUser) -> Self {
        Self {
            user_id: m.user_id.to_string(),
            display_name: m.display_name,
            email: m.email,
            role: format!("{:?}", m.role).to_lowercase(),
            joined_at: m.joined_at.to_rfc3339(),
            allocation_percentage: m.allocation_percentage,
        }
    }
}

#[derive(Debug, Serialize, ToSchema)]
pub struct TeamMemberListResponse {
    pub items: Vec<TeamMemberResponse>,
    pub total: i64,
    pub limit: i64,
    pub offset: i64,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct AddMemberRequest {
    pub user_id: String,
    #[serde(default)]
    pub role: Option<String>,  // "leader" or "member", defaults to "member"
    pub allocation_percentage: Option<i32>,
}

#[derive(Debug, Deserialize, ToSchema)]
pub struct UpdateMemberRequest {
    pub role: Option<String>,
    pub allocation_percentage: Option<i32>,
}

#[utoipa::path(
    get,
    path = "/teams/{team_id}/members",
    tag = "teams",
    params(
        ("team_id" = String, Path, description = "Team ID"),
        ("limit" = Option<i64>, Query, description = "Max results"),
        ("offset" = Option<i64>, Query, description = "Offset")
    ),
    responses(
        (status = 200, description = "Team members", body = TeamMemberListResponse),
        (status = 404, description = "Team not found")
    )
)]
pub async fn list_team_members(
    _user: CurrentUser,
    Path(team_id): Path<String>,
    Query(pagination): Query<Pagination>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
) -> Result<Json<TeamMemberListResponse>, ApiError> {
    let id: TeamId = team_id.parse()?;
    
    // Verify team exists
    let _ = repo.find_by_id(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::not_found("team", team_id))?;
    
    let page = repo.list_members(&id, pagination).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    Ok(Json(TeamMemberListResponse {
        items: page.items.into_iter().map(TeamMemberResponse::from).collect(),
        total: page.total,
        limit: page.limit,
        offset: page.offset,
    }))
}

#[utoipa::path(
    post,
    path = "/teams/{team_id}/members",
    tag = "teams",
    params(("team_id" = String, Path, description = "Team ID")),
    request_body = AddMemberRequest,
    responses(
        (status = 201, description = "Member added", body = TeamMemberResponse),
        (status = 400, description = "Invalid request"),
        (status = 403, description = "Requires team leadership"),
        (status = 404, description = "Team or user not found"),
        (status = 409, description = "User already a member")
    )
)]
pub async fn add_team_member(
    current_user: CurrentUser,
    Path(team_id): Path<String>,
    Json(body): Json<AddMemberRequest>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
    State(user_repo): State<Arc<dyn UserRepository + Send + Sync>>,
    State(permission_service): State<Arc<crate::services::PermissionService>>,
) -> Result<(StatusCode, Json<TeamMemberResponse>), ApiError> {
    let id: TeamId = team_id.parse()?;
    
    // Check permission: admin or team leader (with cascade)
    if !current_user.has_role("admin") {
        let is_leader = permission_service.check_team_leadership_cascade(&current_user.user_id, &id).await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
        if !is_leader {
            return Err(ApiError::Forbidden {
                permission: format!("team:lead({}) or role:admin", id),
            });
        }
    }
    
    let member_user_id: UserId = body.user_id.parse()?;
    
    // Verify user exists
    let _ = user_repo.find_by_id(&member_user_id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::not_found("user", body.user_id.clone()))?;
    
    let role = match body.role.as_deref() {
        Some("leader") => glyph_domain::TeamRole::Leader,
        Some("member") | None => glyph_domain::TeamRole::Member,
        Some(r) => return Err(ApiError::bad_request("team.role.invalid", format!("Invalid role: {}. Must be 'leader' or 'member'", r))),
    };
    
    let membership = repo.add_member(&id, &member_user_id, role, body.allocation_percentage).await
        .map_err(|e| match e {
            glyph_db::TeamMembershipError::AlreadyMember => 
                ApiError::conflict("team.member.exists", "User is already a member of this team"),
            glyph_db::TeamMembershipError::NotMember => 
                ApiError::Internal(anyhow::anyhow!("Unexpected: not member after add")),
            glyph_db::TeamMembershipError::Database(e) => 
                ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    // Get user details for response
    let user = user_repo.find_by_id(&member_user_id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::Internal(anyhow::anyhow!("User disappeared")))?;
    
    Ok((StatusCode::CREATED, Json(TeamMemberResponse {
        user_id: membership.user_id.to_string(),
        display_name: user.display_name,
        email: user.email,
        role: format!("{:?}", membership.role).to_lowercase(),
        joined_at: membership.joined_at.to_rfc3339(),
        allocation_percentage: membership.allocation_percentage,
    })))
}

#[utoipa::path(
    delete,
    path = "/teams/{team_id}/members/{user_id}",
    tag = "teams",
    params(
        ("team_id" = String, Path, description = "Team ID"),
        ("user_id" = String, Path, description = "User ID to remove")
    ),
    responses(
        (status = 204, description = "Member removed"),
        (status = 400, description = "Cannot remove last leader"),
        (status = 403, description = "Requires team leadership"),
        (status = 404, description = "Member not found")
    )
)]
pub async fn remove_team_member(
    current_user: CurrentUser,
    Path((team_id, user_id)): Path<(String, String)>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
    State(permission_service): State<Arc<crate::services::PermissionService>>,
) -> Result<StatusCode, ApiError> {
    let id: TeamId = team_id.parse()?;
    let member_user_id: UserId = user_id.parse()?;
    
    // Check permission
    if !current_user.has_role("admin") {
        let is_leader = permission_service.check_team_leadership_cascade(&current_user.user_id, &id).await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
        if !is_leader {
            return Err(ApiError::Forbidden {
                permission: format!("team:lead({}) or role:admin", id),
            });
        }
    }
    
    // Prevent removing last leader
    let members = repo.list_members(&id, Pagination::default()).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    let leader_count = members.items.iter()
        .filter(|m| m.role == glyph_domain::TeamRole::Leader)
        .count();
    
    let is_removing_leader = members.items.iter()
        .any(|m| m.user_id == member_user_id && m.role == glyph_domain::TeamRole::Leader);
    
    if is_removing_leader && leader_count <= 1 {
        return Err(ApiError::bad_request(
            "team.last_leader",
            "Cannot remove the last leader. Promote another member to leader first."
        ));
    }
    
    repo.remove_member(&id, &member_user_id).await
        .map_err(|e| match e {
            glyph_db::TeamMembershipError::NotMember => 
                ApiError::not_found("team_member", format!("{}:{}", team_id, user_id)),
            glyph_db::TeamMembershipError::AlreadyMember => 
                ApiError::Internal(anyhow::anyhow!("Unexpected error")),
            glyph_db::TeamMembershipError::Database(e) => 
                ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    Ok(StatusCode::NO_CONTENT)
}

#[utoipa::path(
    patch,
    path = "/teams/{team_id}/members/{user_id}",
    tag = "teams",
    params(
        ("team_id" = String, Path, description = "Team ID"),
        ("user_id" = String, Path, description = "User ID to update")
    ),
    request_body = UpdateMemberRequest,
    responses(
        (status = 200, description = "Member updated", body = TeamMemberResponse),
        (status = 400, description = "Cannot demote last leader"),
        (status = 403, description = "Requires team leadership"),
        (status = 404, description = "Member not found")
    )
)]
pub async fn update_team_member(
    current_user: CurrentUser,
    Path((team_id, user_id)): Path<(String, String)>,
    Json(body): Json<UpdateMemberRequest>,
    State(repo): State<Arc<dyn TeamRepository + Send + Sync>>,
    State(user_repo): State<Arc<dyn UserRepository + Send + Sync>>,
    State(permission_service): State<Arc<crate::services::PermissionService>>,
) -> Result<Json<TeamMemberResponse>, ApiError> {
    let id: TeamId = team_id.parse()?;
    let member_user_id: UserId = user_id.parse()?;
    
    // Check permission
    if !current_user.has_role("admin") {
        let is_leader = permission_service.check_team_leadership_cascade(&current_user.user_id, &id).await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
        if !is_leader {
            return Err(ApiError::Forbidden {
                permission: format!("team:lead({}) or role:admin", id),
            });
        }
    }
    
    let new_role = body.role.as_ref().map(|r| match r.as_str() {
        "leader" => Ok(glyph_domain::TeamRole::Leader),
        "member" => Ok(glyph_domain::TeamRole::Member),
        _ => Err(ApiError::bad_request("team.role.invalid", format!("Invalid role: {}", r))),
    }).transpose()?;
    
    // If demoting from leader, check not last leader
    if new_role == Some(glyph_domain::TeamRole::Member) {
        let members = repo.list_members(&id, Pagination::default()).await
            .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
        
        let current_member = members.items.iter()
            .find(|m| m.user_id == member_user_id);
        
        if let Some(m) = current_member {
            if m.role == glyph_domain::TeamRole::Leader {
                let leader_count = members.items.iter()
                    .filter(|m| m.role == glyph_domain::TeamRole::Leader)
                    .count();
                
                if leader_count <= 1 {
                    return Err(ApiError::bad_request(
                        "team.last_leader",
                        "Cannot demote the last leader. Promote another member to leader first."
                    ));
                }
            }
        }
    }
    
    let membership = repo.update_member(&id, &member_user_id, new_role, body.allocation_percentage).await
        .map_err(|e| match e {
            glyph_db::TeamMembershipError::NotMember => 
                ApiError::not_found("team_member", format!("{}:{}", team_id, user_id)),
            glyph_db::TeamMembershipError::AlreadyMember => 
                ApiError::Internal(anyhow::anyhow!("Unexpected error")),
            glyph_db::TeamMembershipError::Database(e) => 
                ApiError::Internal(anyhow::anyhow!("{}", e)),
        })?;
    
    // Get user details for response
    let user = user_repo.find_by_id(&member_user_id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::Internal(anyhow::anyhow!("User not found")))?;
    
    Ok(Json(TeamMemberResponse {
        user_id: membership.user_id.to_string(),
        display_name: user.display_name,
        email: user.email,
        role: format!("{:?}", membership.role).to_lowercase(),
        joined_at: membership.joined_at.to_rfc3339(),
        allocation_percentage: membership.allocation_percentage,
    }))
}

// Update routes builder to include member endpoints
pub fn routes() -> axum::Router {
    use axum::routing::{get, post, patch, delete};
    
    axum::Router::new()
        .route("/", get(list_teams).post(create_team))
        .route("/{team_id}", get(get_team).patch(update_team).delete(delete_team))
        .route("/{team_id}/tree", get(get_team_tree))
        .route("/{team_id}/members", get(list_team_members).post(add_team_member))
        .route("/{team_id}/members/{user_id}", patch(update_team_member).delete(remove_team_member))
}
```
  </action>
  <verify>`cargo check -p glyph-api` compiles.</verify>
  <done>Team membership endpoints created with RBAC via permission service</done>
</task>

<task type="auto">
  <name>Task 2: Add audit logging for membership changes</name>
  <files>libs/db/src/repo/pg_team.rs</files>
  <action>
Update the membership methods in PgTeamRepository to include audit logging:

```rust
async fn add_member(&self, team_id: &TeamId, user_id: &UserId, role: TeamRole, allocation: Option<i32>) -> Result<TeamMembership, TeamMembershipError> {
    let row = sqlx::query_as::<_, TeamMembershipRow>(
        r#"
        INSERT INTO team_memberships (team_id, user_id, role, allocation_percentage)
        VALUES ($1, $2, $3, $4)
        RETURNING team_id, user_id, role, allocation_percentage, joined_at
        "#
    )
    .bind(team_id.to_string())
    .bind(user_id.to_string())
    .bind(format!("{:?}", role).to_lowercase())
    .bind(allocation)
    .fetch_one(&self.pool)
    .await
    .map_err(|e| {
        if let sqlx::Error::Database(ref db_err) = e {
            if db_err.constraint() == Some("team_memberships_pkey") {
                return TeamMembershipError::AlreadyMember;
            }
        }
        TeamMembershipError::Database(e)
    })?;
    
    // Record audit event
    self.audit.record_best_effort(AuditEvent {
        entity_type: "team_membership",
        entity_id: format!("{}:{}", team_id, user_id),
        action: AuditAction::Create,
        actor_id: SYSTEM_ACTOR_ID.to_string(),
        actor_type: AuditActorType::System,
        data_snapshot: serde_json::json!({
            "team_id": team_id.to_string(),
            "user_id": user_id.to_string(),
            "role": format!("{:?}", role).to_lowercase(),
            "allocation_percentage": allocation,
        }),
        changes: None,
        request_id: None,
    }).await;
    
    row.try_into().map_err(|_| TeamMembershipError::Database(sqlx::Error::RowNotFound))
}

async fn remove_member(&self, team_id: &TeamId, user_id: &UserId) -> Result<(), TeamMembershipError> {
    let result = sqlx::query(
        "DELETE FROM team_memberships WHERE team_id = $1 AND user_id = $2"
    )
    .bind(team_id.to_string())
    .bind(user_id.to_string())
    .execute(&self.pool)
    .await
    .map_err(TeamMembershipError::Database)?;
    
    if result.rows_affected() == 0 {
        return Err(TeamMembershipError::NotMember);
    }
    
    // Record audit event
    self.audit.record_best_effort(AuditEvent {
        entity_type: "team_membership",
        entity_id: format!("{}:{}", team_id, user_id),
        action: AuditAction::Delete,
        actor_id: SYSTEM_ACTOR_ID.to_string(),
        actor_type: AuditActorType::System,
        data_snapshot: serde_json::json!({
            "team_id": team_id.to_string(),
            "user_id": user_id.to_string(),
        }),
        changes: None,
        request_id: None,
    }).await;
    
    Ok(())
}

async fn update_member(&self, team_id: &TeamId, user_id: &UserId, role: Option<TeamRole>, allocation: Option<i32>) -> Result<TeamMembership, TeamMembershipError> {
    let row = sqlx::query_as::<_, TeamMembershipRow>(
        r#"
        UPDATE team_memberships SET
            role = COALESCE($3, role),
            allocation_percentage = COALESCE($4, allocation_percentage)
        WHERE team_id = $1 AND user_id = $2
        RETURNING team_id, user_id, role, allocation_percentage, joined_at
        "#
    )
    .bind(team_id.to_string())
    .bind(user_id.to_string())
    .bind(role.map(|r| format!("{:?}", r).to_lowercase()))
    .bind(allocation)
    .fetch_optional(&self.pool)
    .await
    .map_err(TeamMembershipError::Database)?
    .ok_or(TeamMembershipError::NotMember)?;
    
    // Record audit event
    self.audit.record_best_effort(AuditEvent {
        entity_type: "team_membership",
        entity_id: format!("{}:{}", team_id, user_id),
        action: AuditAction::Update,
        actor_id: SYSTEM_ACTOR_ID.to_string(),
        actor_type: AuditActorType::System,
        data_snapshot: serde_json::json!({
            "team_id": team_id.to_string(),
            "user_id": user_id.to_string(),
            "role": role.map(|r| format!("{:?}", r).to_lowercase()),
            "allocation_percentage": allocation,
        }),
        changes: None,
        request_id: None,
    }).await;
    
    row.try_into().map_err(|_| TeamMembershipError::Database(sqlx::Error::RowNotFound))
}
```

Note: In production, the actor_id should be passed from the API layer to reflect the actual user making the change.
  </action>
  <verify>`cargo check -p glyph-db` compiles. Tests pass.</verify>
  <done>Membership changes include audit logging</done>
</task>

</tasks>

<verification>
- GET /api/v1/teams/{id}/members returns member list with user details
- POST /api/v1/teams/{id}/members adds member (team leader or admin only)
- PATCH /api/v1/teams/{id}/members/{user_id} updates role/allocation
- DELETE /api/v1/teams/{id}/members/{user_id} removes member
- Cannot remove last leader (400 error with clear message)
- Cannot demote last leader (400 error with clear message)
- All membership changes are recorded in audit log
</verification>

<success_criteria>
- Team leaders can manage their team membership
- Members can be promoted to leader (multiple leaders allowed)
- Last leader protection prevents accidental lockout
- All membership changes are audited
- Permission checks use cascade (parent team leadership grants access)
</success_criteria>

<output>
After completion, create `.planning/phases/04-user-team-management/04-06-SUMMARY.md`
</output>
