---
phase: 05-project-management
plan: 11
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/db/src/repo/pg_project.rs
  - libs/db/src/repo/mod.rs
  - libs/db/src/lib.rs
  - apps/api/src/routes/projects.rs
  - migrations/0013_optional_workflow.sql
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Project can be saved from /projects/new"
    - "Created project can be retrieved by ID"
    - "Project list shows created projects"
  artifacts:
    - path: "libs/db/src/repo/pg_project.rs"
      provides: "PostgreSQL project repository with CRUD operations"
      min_lines: 150
    - path: "apps/api/src/routes/projects.rs"
      provides: "Project API routes wired to database"
      contains: "PgProjectRepository"
  key_links:
    - from: "apps/api/src/routes/projects.rs"
      to: "libs/db/src/repo/pg_project.rs"
      via: "PgProjectRepository usage"
      pattern: "PgProjectRepository::new"
    - from: "libs/db/src/repo/pg_project.rs"
      to: "projects table"
      via: "sqlx queries"
      pattern: "INSERT INTO projects|SELECT.*FROM projects"
---

<objective>
Implement PgProjectRepository and wire project API routes to actually persist to database.

Purpose: UAT reported 404 on project save because create_project returns mock data without DB insert and get_project always returns not_found. The repository stub needs a real implementation.

Output: Working PgProjectRepository with create/find_by_id/list/update/delete operations, routes using it.
</objective>

<context>
@.planning/phases/05-project-management/05-UAT.md
@libs/db/src/repo/pg_user.rs (reference implementation pattern)
@libs/db/src/repo/pg_team.rs (reference implementation pattern)
@libs/db/src/repo/traits.rs (NewProject, ProjectUpdate, ProjectRepository trait)
@libs/db/src/repo/errors.rs
@libs/domain/src/project.rs (Project domain type)
@migrations/0003_create_projects.sql
@migrations/0011_project_types.sql
@apps/api/src/routes/projects.rs (current stub routes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration for nullable workflow_id</name>
  <files>migrations/0013_optional_workflow.sql</files>
  <action>
Create migration to make workflow_id and layout_id optional (matching domain model):

```sql
-- Migration 0013: Make workflow_id and layout_id optional on projects
-- Domain model has these as Option<T>, but DB schema has NOT NULL

ALTER TABLE projects 
ALTER COLUMN workflow_id DROP NOT NULL;

ALTER TABLE projects
ALTER COLUMN layout_id DROP NOT NULL;

-- Add missing columns from domain model
ALTER TABLE projects
ADD COLUMN IF NOT EXISTS project_type_id UUID REFERENCES project_types(project_type_id);

ALTER TABLE projects
ADD COLUMN IF NOT EXISTS team_id UUID REFERENCES teams(team_id);

ALTER TABLE projects
ADD COLUMN IF NOT EXISTS tags JSONB NOT NULL DEFAULT '[]';

ALTER TABLE projects
ADD COLUMN IF NOT EXISTS documentation TEXT;

ALTER TABLE projects
ADD COLUMN IF NOT EXISTS deadline TIMESTAMPTZ;

ALTER TABLE projects
ADD COLUMN IF NOT EXISTS deadline_action VARCHAR(50);
```

Run the migration:
```bash
sqlx migrate run --source migrations
```
  </action>
  <verify>
Query database schema to confirm columns are nullable:
```sql
SELECT column_name, is_nullable 
FROM information_schema.columns 
WHERE table_name = 'projects' AND column_name IN ('workflow_id', 'layout_id');
```
Should show 'YES' for is_nullable.
  </verify>
  <done>Database schema matches domain model with optional workflow_id and layout_id</done>
</task>

<task type="auto">
  <name>Task 2: Implement PgProjectRepository</name>
  <files>libs/db/src/repo/pg_project.rs, libs/db/src/repo/mod.rs, libs/db/src/lib.rs</files>
  <action>
Create libs/db/src/repo/pg_project.rs following pg_user.rs pattern:

1. Define PgProjectRepository struct with pool and audit writer:
```rust
pub struct PgProjectRepository {
    pool: PgPool,
    audit: AuditWriter,
}

impl PgProjectRepository {
    pub fn new(pool: PgPool) -> Self {
        let audit = AuditWriter::new(pool.clone());
        Self { pool, audit }
    }
}
```

2. Define ProjectRow struct for sqlx mapping:
```rust
#[derive(sqlx::FromRow)]
struct ProjectRow {
    project_id: String,
    name: String,
    description: Option<String>,
    status: String,
    project_type_id: Option<String>,
    workflow_id: Option<String>,
    layout_id: Option<String>,
    team_id: Option<String>,
    settings: serde_json::Value,
    tags: serde_json::Value,
    documentation: Option<String>,
    deadline: Option<chrono::DateTime<chrono::Utc>>,
    deadline_action: Option<String>,
    created_at: chrono::DateTime<chrono::Utc>,
    updated_at: chrono::DateTime<chrono::Utc>,
    created_by: String,
}
```

3. Implement TryFrom<ProjectRow> for Project with proper ID parsing and enum conversion

4. Implement ProjectRepository trait methods:
   - find_by_id: SELECT * FROM projects WHERE project_id = $1 AND status != 'deleted'
   - create: INSERT INTO projects (...) VALUES (...) RETURNING *
   - update: UPDATE projects SET ... WHERE project_id = $1 RETURNING *
   - list: SELECT * FROM projects WHERE status != 'deleted' ORDER BY created_at DESC LIMIT $1 OFFSET $2
   - soft_delete: UPDATE projects SET status = 'deleted' WHERE project_id = $1

5. Add audit logging for create/update/delete operations (use AuditWriter pattern from pg_user.rs)

6. Update libs/db/src/repo/mod.rs to add:
```rust
pub mod pg_project;
pub use pg_project::*;
```

7. Ensure libs/db/src/lib.rs re-exports PgProjectRepository (check if mod.rs re-exports are already in lib.rs)
  </action>
  <verify>
Run `cargo check -p glyph-db` - compiles without errors.
  </verify>
  <done>PgProjectRepository implements all CRUD operations with audit trail</done>
</task>

<task type="auto">
  <name>Task 3: Wire project routes to repository</name>
  <files>apps/api/src/routes/projects.rs</files>
  <action>
Update apps/api/src/routes/projects.rs to use PgProjectRepository:

1. Add imports at top:
```rust
use sqlx::PgPool;
use axum::Extension;
use glyph_db::{PgProjectRepository, ProjectRepository, NewProject, ProjectUpdate, Pagination};
```

2. Update list_projects handler:
```rust
async fn list_projects(
    Query(params): Query<ListProjectsQuery>,
    _current_user: CurrentUser,
    Extension(pool): Extension<PgPool>,
) -> Result<Json<ProjectListResponse>, ApiError> {
    let pagination = Pagination {
        limit: params.limit.unwrap_or(20),
        offset: params.offset.unwrap_or(0),
        ..Default::default()
    };
    
    let repo = PgProjectRepository::new(pool);
    let page = repo.list(pagination).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?;
    
    let items = page.items.into_iter().map(|p| ProjectSummaryResponse {
        project_id: p.project_id.to_string(),
        name: p.name,
        description: p.description,
        status: format!("{:?}", p.status).to_lowercase(),
        project_type_name: None,
        team_name: None,
        task_count: 0,
        completed_task_count: 0,
        completion_percentage: 0.0,
        tags: p.tags,
        deadline: p.deadline.map(|d| d.to_rfc3339()),
        created_at: p.created_at.to_rfc3339(),
        created_by: p.created_by.to_string(),
    }).collect();
    
    Ok(Json(ProjectListResponse {
        items,
        total: page.total,
        limit: page.limit,
        offset: page.offset,
    }))
}
```

3. Update get_project handler:
```rust
async fn get_project(
    Path(project_id): Path<String>,
    _current_user: CurrentUser,
    Extension(pool): Extension<PgPool>,
) -> Result<Json<ProjectDetailResponse>, ApiError> {
    let id: ProjectId = project_id.parse()
        .map_err(|_| ApiError::not_found("project", &project_id))?;
    
    let repo = PgProjectRepository::new(pool);
    let project = repo.find_by_id(&id).await
        .map_err(|e| ApiError::Internal(anyhow::anyhow!("{}", e)))?
        .ok_or_else(|| ApiError::not_found("project", &project_id))?;
    
    Ok(Json(map_to_detail_response(project)))
}
```

4. Update create_project handler to call repo.create()

5. Update update_project handler to call repo.update()

6. Update delete_project handler to call repo.soft_delete()

7. Add helper function map_to_detail_response(project: Project) -> ProjectDetailResponse

Keep activate_project, update_status, clone_project as stubs for now (more complex logic).
  </action>
  <verify>
Run `cargo check -p glyph-api` - compiles without errors.
Start API server and test:
```bash
# Create project
curl -X POST http://localhost:3000/api/v1/projects \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Project"}' 

# Should return 201 with project_id

# Get project (use ID from create response)
curl http://localhost:3000/api/v1/projects/{id}

# List projects
curl http://localhost:3000/api/v1/projects
```
  </verify>
  <done>Project CRUD operations persist to database and can be retrieved</done>
</task>

</tasks>

<verification>
1. Run migrations: `sqlx migrate run --source migrations`
2. Build: `cargo build -p glyph-api`
3. Start API server: `cargo run -p glyph-api`
4. Test create:
   ```bash
   curl -X POST http://localhost:3000/api/v1/projects \
     -H "Content-Type: application/json" \
     -H "Cookie: access_token=..." \
     -d '{"name": "Test Project", "description": "Testing"}'
   ```
5. Test get by ID from response
6. Test list endpoint
7. Test from frontend: Navigate to /projects/new, fill form, save
</verification>

<success_criteria>
- POST /api/v1/projects creates project in database (returns 201)
- GET /api/v1/projects/{id} returns created project (returns 200)
- GET /api/v1/projects lists all projects
- Frontend /projects/new form saves successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-project-management/05-11-SUMMARY.md`
</output>
