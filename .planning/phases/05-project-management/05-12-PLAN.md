---
phase: 05-project-management
plan: 12
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/routes/project_types.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Project types can be listed via GET /api/v1/project-types"
    - "Project types can be fetched by ID via GET /api/v1/project-types/{id}"
    - "Project types can be created via POST /api/v1/project-types"
    - "Project types can be updated via PUT /api/v1/project-types/{id}"
    - "Project types can be deleted via DELETE /api/v1/project-types/{id}"
  artifacts:
    - path: "apps/api/src/routes/project_types.rs"
      provides: "ProjectType CRUD API endpoints wired to PgProjectTypeRepository"
      contains: "PgProjectTypeRepository::new"
  key_links:
    - from: "apps/api/src/routes/project_types.rs"
      to: "libs/db/src/repo/pg_project_type.rs"
      via: "Extension<PgPool> -> PgProjectTypeRepository"
      pattern: "PgProjectTypeRepository::new\\(pool\\)"
---

<objective>
Wire ProjectType CRUD API routes to the existing PgProjectTypeRepository implementation.

Purpose: The repository is fully implemented (464 lines) but routes return stubs. This gap closure connects the API layer to the database layer.
Output: Working ProjectType CRUD endpoints that persist to PostgreSQL.
</objective>

<context>
Reference files:
- libs/db/src/repo/pg_project_type.rs (existing repository)
- apps/api/src/routes/project_types.rs (routes to wire)
- apps/api/src/routes/projects.rs (pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire list_project_types to PgProjectTypeRepository::list()</name>
  <files>apps/api/src/routes/project_types.rs</files>
  <action>
1. Add imports at top of file for repository and domain types
2. Modify list_project_types to accept Extension(pool) parameter
3. Replace placeholder implementation with repository call
4. Add From impl for ProjectTypeResponse
  </action>
  <verify>Run `cargo check -p glyph-api` - no errors</verify>
  <done>GET /api/v1/project-types returns actual data from database instead of empty array</done>
</task>

<task type="auto">
  <name>Task 2: Wire get, create, update, delete to PgProjectTypeRepository</name>
  <files>apps/api/src/routes/project_types.rs</files>
  <action>
1. Wire get_project_type - add Extension(pool), call repo.find_by_id()
2. Wire create_project_type - build CreateProjectType, call repo.create()
3. Wire update_project_type - build UpdateProjectType, call repo.update()
4. Wire delete_project_type - call repo.delete()
5. Add helper functions for parsing difficulty and proficiency levels
  </action>
  <verify>
    Run `cargo check -p glyph-api` - no errors
    Run `cargo test -p glyph-api` - all tests pass
  </verify>
  <done>
    All ProjectType CRUD endpoints return real data:
    - GET /{id} returns project type or 404
    - POST creates and returns 201
    - PUT /{id} updates and returns updated
    - DELETE /{id} deletes and returns 204
  </done>
</task>

</tasks>

<verification>
1. `cargo build -p glyph-api` compiles without errors
2. Start server, test full CRUD cycle:
   - POST /api/v1/project-types -> 201 + created object
   - GET /api/v1/project-types -> array with created object
   - GET /api/v1/project-types/{id} -> created object
   - PUT /api/v1/project-types/{id} -> updated object  
   - DELETE /api/v1/project-types/{id} -> 204
</verification>

<success_criteria>
- All 5 ProjectType CRUD routes connect to PgProjectTypeRepository
- Data persists to PostgreSQL database
- Error handling maps repository errors to HTTP status codes
- Response format matches ProjectTypeResponse schema
</success_criteria>

<output>
After completion, create `.planning/phases/05-project-management/05-12-SUMMARY.md`
</output>
