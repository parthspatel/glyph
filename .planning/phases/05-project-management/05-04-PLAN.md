---
phase: 05-project-management
plan: 04
type: execute
wave: 3
depends_on: [05-02, 05-03]
files_modified:
  - apps/api/src/routes/projects.rs
  - apps/api/src/routes/project_types.rs
  - apps/api/src/routes/mod.rs
  - libs/db/src/repo/pg_project.rs
autonomous: true

must_haves:
  truths:
    - "Project CRUD endpoints exist at /api/v1/projects"
    - "ProjectType CRUD endpoints exist at /api/v1/project-types"
    - "Status transitions validate allowed changes"
    - "Activation validates required fields"
  artifacts:
    - path: "apps/api/src/routes/projects.rs"
      provides: "Project API endpoints"
      contains: "pub fn router"
    - path: "apps/api/src/routes/project_types.rs"
      provides: "ProjectType API endpoints"
      contains: "pub fn router"
---

<objective>
Create Project and ProjectType CRUD APIs with lifecycle state machine.

Purpose: Expose REST endpoints for managing projects and project types. Implement status lifecycle transitions with validation. Support project templates, cloning, and activation requirements.

Output: Full CRUD routes for projects and project types at /api/v1.
</objective>

<context>
@apps/api/src/routes/users.rs (pattern for CRUD routes)
@apps/api/src/routes/teams.rs (pattern for routes)
@libs/domain/src/project.rs (existing Project entity)
@.planning/phases/05-project-management/05-CONTEXT.md (lifecycle decisions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Project repository and domain</name>
  <files>libs/db/src/repo/pg_project.rs, libs/domain/src/project.rs</files>
  <action>
1. Update Project entity in libs/domain/src/project.rs:
   - Add project_type_id: Option<ProjectTypeId>
   - Add tags: Vec<String>
   - Add documentation: Option<String> (markdown)
   - Add deadline: Option<DateTime<Utc>>
   - Add deadline_action: Option<DeadlineAction>
   - Add auto_complete_enabled: bool
   - Ensure status field uses ProjectStatus enum

2. Define DeadlineAction enum:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[typeshare]
pub enum DeadlineAction {
    Notify,
    Pause,
    Escalate,
}
```

3. Update CreateProject and UpdateProject DTOs

4. Add ProjectStatusMachine helper:
```rust
impl ProjectStatus {
    pub fn allowed_transitions(&self) -> Vec<ProjectStatus> {
        match self {
            Self::Draft => vec![Self::Active, Self::Archived],
            Self::Active => vec![Self::Paused, Self::Completed],
            Self::Paused => vec![Self::Active, Self::Archived],
            Self::Completed => vec![Self::Archived, Self::Paused],
            Self::Archived => vec![], // Terminal
        }
    }
    
    pub fn can_transition_to(&self, target: &Self) -> bool {
        self.allowed_transitions().contains(target)
    }
}
```

5. Update PgProjectRepository to handle new fields
  </action>
  <verify>
Run `cargo check -p glyph-domain glyph-db` - compiles.
  </verify>
</task>

<task type="auto">
  <name>Task 2: Create Project routes</name>
  <files>apps/api/src/routes/projects.rs, apps/api/src/routes/mod.rs</files>
  <action>
Create apps/api/src/routes/projects.rs:

1. Define router:
```rust
pub fn router() -> Router<AppState> {
    Router::new()
        .route("/", get(list_projects).post(create_project))
        .route("/:id", get(get_project).put(update_project).delete(delete_project))
        .route("/:id/status", post(update_status))
        .route("/:id/clone", post(clone_project))
        .route("/:id/activate", post(activate_project))
        .route("/:id/transfer", post(transfer_ownership))
}
```

2. Implement list_projects:
   - Query params: status, project_type_id, created_by, team_id, search, tags
   - Pagination with limit/offset
   - Sorting by name, created_at, status
   - Filter by "my", "team", "all" view
   - Return project list with metrics (task_count, completion_pct, active_annotators - placeholders for now)

3. Implement create_project:
   - Validate project_type_id if provided
   - Set status to Draft
   - CurrentUser as created_by
   - Return created project

4. Implement get_project:
   - Include project_type details
   - Include data_sources list
   - Include recent activity (last 20 events from audit log)

5. Implement update_project:
   - Check permission (creator, admin, team lead)
   - Validate project_type change only in Draft
   - Update fields

6. Implement delete_project:
   - Soft delete (set deleted_at)
   - Check permission

7. Implement update_status:
   - Validate transition using allowed_transitions()
   - For Draft->Active: call validate_activation()
   - Return updated project

8. Implement activate_project:
   - Validate: output_schema exists, at least one data source, skill requirements defined
   - Return structured errors if validation fails
   - Transition to Active if valid

9. Implement clone_project:
   - Body: { include_data_sources: bool, as_template: bool }
   - Create new project in Draft status
   - Copy settings based on options

10. Implement transfer_ownership:
    - Body: { new_owner_id: UserId }
    - Update created_by
    - Audit log the transfer

11. Add OpenAPI annotations with utoipa
  </action>
  <verify>
Run `cargo check -p glyph-api` - compiles.
Test with curl: create project, update status, clone.
  </verify>
</task>

<task type="auto">
  <name>Task 3: Create ProjectType routes</name>
  <files>apps/api/src/routes/project_types.rs</files>
  <action>
Create apps/api/src/routes/project_types.rs:

1. Define router:
```rust
pub fn router() -> Router<AppState> {
    Router::new()
        .route("/", get(list_project_types).post(create_project_type))
        .route("/:id", get(get_project_type).put(update_project_type).delete(delete_project_type))
        .route("/:id/validate-schema", post(validate_schema))
        .route("/infer-schema", post(infer_schema))
}
```

2. Implement list_project_types:
   - Query params: is_system, created_by, search
   - Return list with skill_requirements embedded

3. Implement create_project_type:
   - Validate input_schema and output_schema are valid JSON Schema
   - Set is_system = false (only seed data can set true)
   - Handle skill_requirements array

4. Implement get_project_type:
   - Include usage_count (projects using this type)

5. Implement update_project_type:
   - Check permission (creator or admin)
   - Validate schemas if changed

6. Implement delete_project_type:
   - Check no projects reference it (or soft delete)

7. Implement validate_schema:
   - Body: { schema: Value, sample_data: Value }
   - Use SchemaValidationService to validate
   - Return ValidationResult

8. Implement infer_schema:
   - Body: { samples: Vec<Value> }
   - Use SchemaValidationService::infer_schema()
   - Return SchemaInferenceResult with ambiguities

9. Add OpenAPI annotations
  </action>
  <verify>
Run `cargo check -p glyph-api` - compiles.
Test schema validation endpoint with sample data.
  </verify>
</task>

</tasks>

<verification>
1. All routes compile: `cargo check -p glyph-api`
2. Project CRUD works via curl/Swagger
3. Status transitions enforce state machine
4. Activation fails without required fields
5. Clone creates new project correctly
6. ProjectType CRUD works
7. Schema validation returns errors
</verification>

<success_criteria>
- GET/POST/PUT/DELETE for /projects and /project-types
- Status transitions validated with clear errors
- Activation validates output_schema, data_sources, skills
- Clone supports with/without data sources
- OpenAPI documentation complete
</success_criteria>
