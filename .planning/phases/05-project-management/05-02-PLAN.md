---
phase: 05-project-management
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - libs/domain/src/project.rs
  - libs/domain/src/project_type.rs
  - libs/domain/src/lib.rs
  - libs/db/src/repo/pg_project_type.rs
  - libs/db/src/repo/mod.rs
autonomous: true

must_haves:
  truths:
    - "ProjectType entity with typed ID exists"
    - "ProjectTypeRepository trait defined"
    - "PostgreSQL implementation compiles"
    - "Skill requirements embedded in ProjectType"
  artifacts:
    - path: "libs/domain/src/project_type.rs"
      provides: "ProjectType domain entity"
      contains: "pub struct ProjectType"
    - path: "libs/db/src/repo/pg_project_type.rs"
      provides: "PostgreSQL repository implementation"
      contains: "impl ProjectTypeRepository"
---

<objective>
Create ProjectType domain entity and repository with full CRUD operations.

Purpose: Define the reusable project type templates that contain task input schemas, annotation output schemas, and skill requirements. This is the foundation for project configuration.

Output: ProjectType entity in libs/domain, repository trait, PostgreSQL implementation.
</objective>

<context>
@libs/domain/src/user.rs (pattern for typed IDs)
@libs/domain/src/team.rs (pattern for entities)
@libs/db/src/repo/pg_user.rs (pattern for repositories)
@.planning/phases/05-project-management/05-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProjectType domain entity</name>
  <files>libs/domain/src/project_type.rs, libs/domain/src/lib.rs</files>
  <action>
Create libs/domain/src/project_type.rs following existing patterns:

1. Define ProjectTypeId with typed_id! macro (prefix: "ptype_")

2. Define ProjectType struct:
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[typeshare]
pub struct ProjectType {
    pub id: ProjectTypeId,
    pub name: String,
    pub description: Option<String>,
    pub input_schema: serde_json::Value,
    pub output_schema: serde_json::Value,
    pub estimated_duration_seconds: Option<i32>,
    pub difficulty_level: Option<DifficultyLevel>,
    pub skill_requirements: Vec<SkillRequirement>,
    pub is_system: bool,
    pub created_by: Option<UserId>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
```

3. Define DifficultyLevel enum:
```rust
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
#[typeshare]
pub enum DifficultyLevel {
    Easy,
    Medium,
    Hard,
    Expert,
}
```

4. Define SkillRequirement struct:
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[typeshare]
pub struct SkillRequirement {
    pub skill_id: String,
    pub min_proficiency: ProficiencyLevel,
    pub is_required: bool,
    pub weight: f32,
}
```

5. Define CreateProjectType and UpdateProjectType DTOs

6. Export from libs/domain/src/lib.rs
  </action>
  <verify>
Run `cargo check -p glyph-domain` - should compile.
Run `cargo run -p glyph-domain --bin typeshare` - TypeScript types generated.
  </verify>
</task>

<task type="auto">
  <name>Task 2: Create ProjectType repository</name>
  <files>libs/db/src/repo/pg_project_type.rs, libs/db/src/repo/mod.rs</files>
  <action>
Create libs/db/src/repo/pg_project_type.rs:

1. Define ProjectTypeRepository trait:
```rust
#[async_trait]
pub trait ProjectTypeRepository: Send + Sync {
    async fn create(&self, project_type: &CreateProjectType, created_by: Option<&UserId>) 
        -> Result<ProjectType, CreateProjectTypeError>;
    async fn get_by_id(&self, id: &ProjectTypeId) 
        -> Result<Option<ProjectType>, GetProjectTypeError>;
    async fn list(&self, filter: &ProjectTypeFilter) 
        -> Result<Vec<ProjectType>, ListProjectTypeError>;
    async fn update(&self, id: &ProjectTypeId, update: &UpdateProjectType) 
        -> Result<ProjectType, UpdateProjectTypeError>;
    async fn delete(&self, id: &ProjectTypeId) 
        -> Result<(), DeleteProjectTypeError>;
}
```

2. Define per-operation error types (following existing pattern)

3. Define ProjectTypeFilter struct:
```rust
pub struct ProjectTypeFilter {
    pub is_system: Option<bool>,
    pub created_by: Option<UserId>,
    pub search: Option<String>,
    pub limit: Option<i64>,
    pub offset: Option<i64>,
}
```

4. Implement PgProjectTypeRepository:
   - Use sqlx::query_as! for type safety
   - Handle skill_requirements as separate table join
   - Use as_uuid() for ID binding (per project decisions)

5. Export from libs/db/src/repo/mod.rs
  </action>
  <verify>
Run `cargo check -p glyph-db` - should compile.
Write integration test that creates and retrieves a project type.
  </verify>
</task>

</tasks>

<verification>
1. Domain types compile: `cargo check -p glyph-domain`
2. Repository compiles: `cargo check -p glyph-db`
3. TypeScript types generated for ProjectType
4. Integration test passes for CRUD operations
</verification>

<success_criteria>
- ProjectTypeId with "ptype_" prefix
- ProjectType entity with all required fields
- SkillRequirement embedded in ProjectType
- Repository trait with per-operation errors
- PostgreSQL implementation with skill requirements join
</success_criteria>
