---
phase: 05-project-management
plan: 08
type: execute
wave: 5
depends_on: [05-07]
files_modified:
  - apps/web/src/pages/ProjectCreatePage.tsx
  - apps/web/src/components/project/ProjectForm.tsx
  - apps/web/src/components/project/sections/BasicInfoSection.tsx
  - apps/web/src/components/project/sections/ProjectTypeSection.tsx
  - apps/web/src/components/project/sections/SchemaSection.tsx
  - apps/web/src/components/project/sections/DataSourcesSection.tsx
  - apps/web/src/components/project/sections/SkillRequirementsSection.tsx
  - apps/web/src/components/project/ProjectChecklist.tsx
  - apps/web/src/components/project/SchemaEditor.tsx
autonomous: true

must_haves:
  truths:
    - "Project creation form with collapsible sections"
    - "Side panel with checklist and summary"
    - "Monaco editor for JSON schemas"
    - "Unsaved changes warning works"
    - "Manual save with validation"
  artifacts:
    - path: "apps/web/src/pages/ProjectCreatePage.tsx"
      provides: "Project creation page"
      contains: "ProjectCreatePage"
    - path: "apps/web/src/components/project/ProjectForm.tsx"
      provides: "Main project form"
      contains: "ProjectForm"
---

<objective>
Create the project creation/edit form with collapsible sections and checklist sidebar.

Purpose: Build the main form for creating and editing projects. Sections collapse when complete and expand when incomplete. Side panel shows completion checklist and project summary. Monaco editor for schema editing with live validation.

Output: ProjectCreatePage at /projects/new and ProjectEditPage at /projects/:id/edit.
</objective>

<context>
@.planning/phases/05-project-management/05-CONTEXT.md (form decisions)
@.planning/phases/05-project-management/05-RESEARCH.md (patterns)
@apps/web/src/pages/ (page patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create form sections and ProjectForm</name>
  <files>apps/web/src/components/project/ProjectForm.tsx, apps/web/src/components/project/sections/*.tsx</files>
  <action>
1. Create apps/web/src/components/project/ProjectForm.tsx:

```typescript
import { useForm, FormProvider } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as Accordion from '@radix-ui/react-accordion';
import { z } from 'zod';
import { useState, useEffect } from 'react';
import { useUnsavedChanges } from '@/hooks/useUnsavedChanges';

const projectSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  project_type_id: z.string().optional(),
  input_schema: z.any().optional(),
  output_schema: z.any().optional(),
  data_sources: z.array(z.any()).default([]),
  skill_requirements: z.array(z.any()).default([]),
  tags: z.array(z.string()).default([]),
  documentation: z.string().optional(),
  deadline: z.string().optional(),
  deadline_action: z.enum(['notify', 'pause', 'escalate']).optional(),
});

type ProjectFormData = z.infer<typeof projectSchema>;

interface ProjectFormProps {
  defaultValues?: Partial<ProjectFormData>;
  onSubmit: (data: ProjectFormData) => Promise<void>;
  isEdit?: boolean;
}

export function ProjectForm({ defaultValues, onSubmit, isEdit }: ProjectFormProps) {
  const methods = useForm<ProjectFormData>({
    resolver: zodResolver(projectSchema),
    mode: 'onChange',
    defaultValues: {
      name: '',
      data_sources: [],
      skill_requirements: [],
      tags: [],
      ...defaultValues,
    },
  });

  const { formState: { errors, isDirty, dirtyFields }, watch, handleSubmit } = methods;
  
  // Unsaved changes warning
  useUnsavedChanges(isDirty);
  
  // Track section completion
  const name = watch('name');
  const projectTypeId = watch('project_type_id');
  const outputSchema = watch('output_schema');
  const dataSources = watch('data_sources');
  const skillRequirements = watch('skill_requirements');
  
  const sectionStatus = {
    basic: Boolean(name),
    projectType: Boolean(projectTypeId),
    schema: Boolean(outputSchema && Object.keys(outputSchema).length > 0),
    dataSources: dataSources.length > 0,
    skills: skillRequirements.length > 0,
  };
  
  // Auto-collapse completed sections
  const [openSections, setOpenSections] = useState(['basic']);
  
  useEffect(() => {
    // Expand first incomplete section
    const sections = ['basic', 'projectType', 'schema', 'dataSources', 'skills'];
    const firstIncomplete = sections.find(s => !sectionStatus[s as keyof typeof sectionStatus]);
    if (firstIncomplete && !openSections.includes(firstIncomplete)) {
      setOpenSections([firstIncomplete]);
    }
  }, [sectionStatus]);
  
  return (
    <FormProvider {...methods}>
      <form onSubmit={handleSubmit(onSubmit)} className="flex gap-6">
        {/* Main form */}
        <div className="flex-1">
          <Accordion.Root
            type="multiple"
            value={openSections}
            onValueChange={setOpenSections}
            className="space-y-4"
          >
            <AccordionSection
              value="basic"
              title="Basic Information"
              isComplete={sectionStatus.basic}
              hasError={!!errors.name}
            >
              <BasicInfoSection />
            </AccordionSection>
            
            <AccordionSection
              value="projectType"
              title="Project Type"
              isComplete={sectionStatus.projectType}
            >
              <ProjectTypeSection disabled={isEdit && defaultValues?.status !== 'draft'} />
            </AccordionSection>
            
            <AccordionSection
              value="schema"
              title="Schema Configuration"
              isComplete={sectionStatus.schema}
            >
              <SchemaSection />
            </AccordionSection>
            
            <AccordionSection
              value="dataSources"
              title="Data Sources"
              isComplete={sectionStatus.dataSources}
            >
              <DataSourcesSection projectId={defaultValues?.id} />
            </AccordionSection>
            
            <AccordionSection
              value="skills"
              title="Skill Requirements"
              isComplete={sectionStatus.skills}
            >
              <SkillRequirementsSection />
            </AccordionSection>
          </Accordion.Root>
          
          {/* Form actions */}
          <div className="mt-6 flex justify-end gap-4">
            <Button variant="outline" type="button" onClick={() => history.back()}>
              Cancel
            </Button>
            <Button type="submit" disabled={!isDirty}>
              {isEdit ? 'Save Changes' : 'Create Project'}
            </Button>
          </div>
        </div>
        
        {/* Side panel */}
        <ProjectChecklist
          sectionStatus={sectionStatus}
          onSectionClick={(section) => setOpenSections([section])}
        />
      </form>
    </FormProvider>
  );
}

function AccordionSection({ value, title, isComplete, hasError, children }) {
  return (
    <Accordion.Item value={value} className="border rounded-lg">
      <Accordion.Trigger className="w-full px-4 py-3 flex items-center justify-between">
        <div className="flex items-center gap-2">
          {isComplete ? (
            <CheckCircleIcon className="h-5 w-5 text-green-500" />
          ) : hasError ? (
            <AlertCircleIcon className="h-5 w-5 text-red-500" />
          ) : (
            <CircleIcon className="h-5 w-5 text-gray-300" />
          )}
          <span className="font-medium">{title}</span>
        </div>
        <ChevronDownIcon className="h-5 w-5 transition-transform accordion-chevron" />
      </Accordion.Trigger>
      <Accordion.Content className="px-4 pb-4">
        {children}
      </Accordion.Content>
    </Accordion.Item>
  );
}
```

2. Create section components:

apps/web/src/components/project/sections/BasicInfoSection.tsx:
- Name input (required)
- Description textarea
- Tags input with typeahead
- Documentation markdown editor

apps/web/src/components/project/sections/ProjectTypeSection.tsx:
- ProjectType select dropdown
- Show selected type's skill requirements as preview
- "Create new type" link

apps/web/src/components/project/sections/SchemaSection.tsx:
- Tabs: Input Schema / Output Schema
- Monaco editor for each
- "Infer from sample" button for input schema
- Live validation indicator
- Schema preview (simplified form preview)

apps/web/src/components/project/sections/DataSourcesSection.tsx:
- List existing data sources
- Add new data source form
- Per-source: type selector, config fields, test connection button
- Only show if project is already created (else show message)

apps/web/src/components/project/sections/SkillRequirementsSection.tsx:
- List of skill requirements
- Add requirement: skill dropdown, proficiency level, required checkbox
  </action>
  <verify>
Form renders all sections.
Accordion expands/collapses correctly.
Each section validates independently.
  </verify>
</task>

<task type="auto">
  <name>Task 2: Create SchemaEditor and ProjectChecklist</name>
  <files>apps/web/src/components/project/SchemaEditor.tsx, apps/web/src/components/project/ProjectChecklist.tsx</files>
  <action>
1. Create apps/web/src/components/project/SchemaEditor.tsx:

```typescript
import Editor from '@monaco-editor/react';
import { useState, useCallback } from 'react';

interface SchemaEditorProps {
  value: object;
  onChange: (value: object) => void;
  height?: string;
}

export function SchemaEditor({ value, onChange, height = '300px' }: SchemaEditorProps) {
  const [error, setError] = useState<string | null>(null);
  
  const handleChange = useCallback((newValue: string | undefined) => {
    if (!newValue) return;
    
    try {
      const parsed = JSON.parse(newValue);
      setError(null);
      onChange(parsed);
    } catch (e) {
      setError((e as Error).message);
    }
  }, [onChange]);
  
  return (
    <div className="border rounded-lg overflow-hidden">
      <Editor
        height={height}
        language="json"
        value={JSON.stringify(value, null, 2)}
        onChange={handleChange}
        options={{
          minimap: { enabled: false },
          formatOnPaste: true,
          formatOnType: true,
          automaticLayout: true,
          scrollBeyondLastLine: false,
          fontSize: 13,
        }}
      />
      {error && (
        <div className="bg-red-50 border-t border-red-200 px-3 py-2 text-sm text-red-600">
          {error}
        </div>
      )}
    </div>
  );
}
```

2. Create apps/web/src/components/project/ProjectChecklist.tsx:

```typescript
interface ProjectChecklistProps {
  sectionStatus: {
    basic: boolean;
    projectType: boolean;
    schema: boolean;
    dataSources: boolean;
    skills: boolean;
  };
  onSectionClick: (section: string) => void;
}

export function ProjectChecklist({ sectionStatus, onSectionClick }: ProjectChecklistProps) {
  const completedCount = Object.values(sectionStatus).filter(Boolean).length;
  const totalCount = Object.keys(sectionStatus).length;
  
  // Required for activation
  const activationRequirements = [
    { key: 'schema', label: 'Output schema defined', met: sectionStatus.schema },
    { key: 'dataSources', label: 'At least one data source', met: sectionStatus.dataSources },
    { key: 'skills', label: 'Skill requirements set', met: sectionStatus.skills },
  ];
  
  const canActivate = activationRequirements.every(r => r.met);
  
  return (
    <div className="w-80 shrink-0">
      <div className="sticky top-4 space-y-4">
        {/* Progress summary */}
        <div className="border rounded-lg p-4">
          <h3 className="font-medium mb-2">Completion</h3>
          <div className="flex items-center gap-3">
            <div className="flex-1 h-2 bg-gray-200 rounded">
              <div
                className="h-full bg-green-500 rounded transition-all"
                style={{ width: `${(completedCount / totalCount) * 100}%` }}
              />
            </div>
            <span className="text-sm text-gray-600">{completedCount}/{totalCount}</span>
          </div>
        </div>
        
        {/* Section checklist */}
        <div className="border rounded-lg p-4">
          <h3 className="font-medium mb-3">Sections</h3>
          <ul className="space-y-2">
            {Object.entries(sectionStatus).map(([key, complete]) => (
              <li key={key}>
                <button
                  onClick={() => onSectionClick(key)}
                  className="flex items-center gap-2 text-sm w-full text-left hover:bg-gray-50 rounded px-2 py-1"
                >
                  {complete ? (
                    <CheckIcon className="h-4 w-4 text-green-500" />
                  ) : (
                    <CircleIcon className="h-4 w-4 text-gray-300" />
                  )}
                  <span className={complete ? 'text-gray-600' : 'text-gray-900'}>
                    {sectionLabels[key]}
                  </span>
                </button>
              </li>
            ))}
          </ul>
        </div>
        
        {/* Activation requirements */}
        <div className="border rounded-lg p-4">
          <h3 className="font-medium mb-3">Activation Requirements</h3>
          <ul className="space-y-2">
            {activationRequirements.map((req) => (
              <li key={req.key} className="flex items-center gap-2 text-sm">
                {req.met ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <XCircleIcon className="h-4 w-4 text-red-400" />
                )}
                <span className={req.met ? 'text-gray-600' : 'text-gray-900'}>
                  {req.label}
                </span>
                {!req.met && (
                  <button
                    onClick={() => onSectionClick(req.key)}
                    className="text-blue-600 text-xs hover:underline ml-auto"
                  >
                    Go to section
                  </button>
                )}
              </li>
            ))}
          </ul>
          {canActivate && (
            <p className="mt-3 text-sm text-green-600">
              Ready to activate!
            </p>
          )}
        </div>
      </div>
    </div>
  );
}

const sectionLabels: Record<string, string> = {
  basic: 'Basic Information',
  projectType: 'Project Type',
  schema: 'Schema',
  dataSources: 'Data Sources',
  skills: 'Skill Requirements',
};
```
  </action>
  <verify>
Monaco editor renders and accepts JSON.
Checklist shows correct completion status.
Clicking checklist items scrolls/expands section.
  </verify>
</task>

<task type="auto">
  <name>Task 3: Create ProjectCreatePage and ProjectEditPage</name>
  <files>apps/web/src/pages/ProjectCreatePage.tsx, apps/web/src/pages/ProjectEditPage.tsx</files>
  <action>
1. Create apps/web/src/pages/ProjectCreatePage.tsx:

```typescript
import { useNavigate } from 'react-router-dom';
import { useCreateProject } from '@/hooks/useProjects';
import { ProjectForm } from '@/components/project/ProjectForm';
import { toast } from '@/components/ui/toast';

export function ProjectCreatePage() {
  const navigate = useNavigate();
  const createProject = useCreateProject();
  
  const handleSubmit = async (data: ProjectFormData) => {
    try {
      const project = await createProject.mutateAsync(data);
      toast.success('Project created successfully');
      navigate(`/projects/${project.id}`);
    } catch (error) {
      toast.error('Failed to create project');
    }
  };
  
  return (
    <div className="container py-6 max-w-6xl">
      <h1 className="text-2xl font-bold mb-6">Create Project</h1>
      <ProjectForm onSubmit={handleSubmit} />
    </div>
  );
}
```

2. Create apps/web/src/pages/ProjectEditPage.tsx:

```typescript
import { useParams, useNavigate } from 'react-router-dom';
import { useProject, useUpdateProject } from '@/hooks/useProjects';
import { ProjectForm } from '@/components/project/ProjectForm';

export function ProjectEditPage() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { data: project, isLoading } = useProject(id!);
  const updateProject = useUpdateProject();
  
  if (isLoading) return <LoadingSkeleton />;
  if (!project) return <NotFound />;
  
  const handleSubmit = async (data: ProjectFormData) => {
    await updateProject.mutateAsync({ id: id!, data });
    toast.success('Project updated');
    navigate(`/projects/${id}`);
  };
  
  return (
    <div className="container py-6 max-w-6xl">
      <h1 className="text-2xl font-bold mb-6">Edit Project</h1>
      <ProjectForm
        defaultValues={project}
        onSubmit={handleSubmit}
        isEdit
      />
    </div>
  );
}
```

3. Add keyboard shortcuts (in ProjectForm):
```typescript
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 's') {
      e.preventDefault();
      handleSubmit(onSubmit)();
    }
    if (e.key === 'Escape') {
      // Could show confirm dialog
    }
  };
  
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [handleSubmit, onSubmit]);
```

4. Add routes:
```typescript
{ path: '/projects/new', element: <ProjectCreatePage /> }
{ path: '/projects/:id/edit', element: <ProjectEditPage /> }
```
  </action>
  <verify>
/projects/new renders form.
Create project - redirects to detail page.
/projects/:id/edit loads existing data.
Cmd+S saves form.
Navigation blocked if unsaved changes.
  </verify>
</task>

</tasks>

<verification>
1. Form renders with all collapsible sections
2. Sections auto-collapse when complete
3. Side panel checklist updates in real-time
4. Monaco editor validates JSON
5. Unsaved changes warning works
6. Form submits and creates/updates project
7. Keyboard shortcuts work
</verification>

<success_criteria>
- Collapsible accordion sections with smart collapse
- Side panel shows completion checklist
- Activation requirements clearly shown
- Monaco editor for schemas with syntax highlighting
- Real-time validation
- Manual save with Cmd+S shortcut
- Unsaved changes warning on navigate
</success_criteria>
