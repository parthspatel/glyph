---
phase: 05-project-management
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - libs/domain/src/schema.rs
  - libs/domain/src/lib.rs
  - apps/api/src/services/schema_service.rs
  - apps/api/src/services/mod.rs
autonomous: true

must_haves:
  truths:
    - "SchemaValidationService compiles and caches validators"
    - "Validation returns structured error information"
    - "Schema inference from sample data works"
  artifacts:
    - path: "apps/api/src/services/schema_service.rs"
      provides: "JSON Schema validation service"
      contains: "pub struct SchemaValidationService"
    - path: "libs/domain/src/schema.rs"
      provides: "Schema-related domain types"
      contains: "ValidationError"
---

<objective>
Create JSON Schema validation service with caching and sample data inference.

Purpose: Provide centralized schema compilation and validation for task input and annotation output data. Cache compiled validators for performance. Support inferring schemas from uploaded sample data.

Output: SchemaValidationService in apps/api, domain types for validation results.
</objective>

<context>
@.planning/phases/05-project-management/05-RESEARCH.md (jsonschema patterns)
@apps/api/src/services/ (existing service patterns)
@libs/domain/src/ (domain type patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema domain types</name>
  <files>libs/domain/src/schema.rs, libs/domain/src/lib.rs</files>
  <action>
Create libs/domain/src/schema.rs:

1. Define SchemaVersionId with typed_id! macro (prefix: "schv_")

2. Define ValidationError struct:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[typeshare]
pub struct ValidationError {
    pub path: String,
    pub message: String,
    pub keyword: Option<String>,
}
```

3. Define ValidationResult:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[typeshare]
pub struct ValidationResult {
    pub is_valid: bool,
    pub errors: Vec<ValidationError>,
}
```

4. Define SchemaInferenceResult:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[typeshare]
pub struct SchemaInferenceResult {
    pub schema: serde_json::Value,
    pub ambiguities: Vec<SchemaAmbiguity>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[typeshare]
pub struct SchemaAmbiguity {
    pub path: String,
    pub description: String,
    pub options: Vec<String>,
    pub suggested: String,
}
```

5. Export from lib.rs
  </action>
  <verify>
Run `cargo check -p glyph-domain` - compiles.
TypeScript types generated.
  </verify>
</task>

<task type="auto">
  <name>Task 2: Create SchemaValidationService</name>
  <files>apps/api/src/services/schema_service.rs, apps/api/src/services/mod.rs</files>
  <action>
Create apps/api/src/services/schema_service.rs:

1. Define SchemaValidationService:
```rust
use jsonschema::Validator;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;

pub struct SchemaValidationService {
    /// Cache of compiled validators keyed by schema hash
    validators: RwLock<HashMap<String, Arc<Validator>>>,
}

impl SchemaValidationService {
    pub fn new() -> Self {
        Self {
            validators: RwLock::new(HashMap::new()),
        }
    }
    
    /// Compile a schema and cache it
    pub async fn compile(&self, schema: &serde_json::Value) 
        -> Result<Arc<Validator>, SchemaCompileError> {
        let hash = self.hash_schema(schema);
        
        // Check cache
        if let Some(validator) = self.validators.read().await.get(&hash) {
            return Ok(Arc::clone(validator));
        }
        
        // Compile
        let validator = jsonschema::validator_for(schema)
            .map_err(|e| SchemaCompileError::InvalidSchema(e.to_string()))?;
        
        let validator = Arc::new(validator);
        self.validators.write().await.insert(hash, Arc::clone(&validator));
        
        Ok(validator)
    }
    
    /// Validate data against a schema
    pub async fn validate(&self, schema: &serde_json::Value, data: &serde_json::Value) 
        -> Result<ValidationResult, SchemaCompileError> {
        let validator = self.compile(schema).await?;
        
        let errors: Vec<ValidationError> = validator
            .iter_errors(data)
            .map(|e| ValidationError {
                path: e.instance_path.to_string(),
                message: e.to_string(),
                keyword: Some(e.keyword().to_string()),
            })
            .collect();
        
        Ok(ValidationResult {
            is_valid: errors.is_empty(),
            errors,
        })
    }
    
    fn hash_schema(&self, schema: &serde_json::Value) -> String {
        use std::hash::{Hash, Hasher};
        use std::collections::hash_map::DefaultHasher;
        let mut hasher = DefaultHasher::new();
        schema.to_string().hash(&mut hasher);
        format!("{:x}", hasher.finish())
    }
}
```

2. Add schema inference function:
```rust
/// Infer schema from sample JSON data
pub fn infer_schema(samples: &[serde_json::Value]) -> SchemaInferenceResult {
    // Implement basic type inference
    // - Detect string, number, boolean, array, object
    // - Track optional vs required based on presence across samples
    // - Flag ambiguities when types differ
}
```

3. Define error types:
```rust
#[derive(Debug, thiserror::Error)]
pub enum SchemaCompileError {
    #[error("Invalid schema: {0}")]
    InvalidSchema(String),
}
```

4. Export from apps/api/src/services/mod.rs
  </action>
  <verify>
Run `cargo check -p glyph-api` - compiles.
Write unit test that validates sample data against a schema.
Write unit test that infers schema from sample JSON.
  </verify>
</task>

</tasks>

<verification>
1. Domain types compile with typeshare
2. SchemaValidationService compiles
3. Validation correctly identifies errors with paths
4. Schema inference produces valid JSON Schema
5. Caching works (same schema doesn't recompile)
</verification>

<success_criteria>
- ValidationError has path, message, keyword fields
- SchemaValidationService caches compiled validators
- validate() returns structured errors
- infer_schema() produces JSON Schema from samples
- Error types follow project convention
</success_criteria>
