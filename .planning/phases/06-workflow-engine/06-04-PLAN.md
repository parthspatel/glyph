---
phase: 06-workflow-engine
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - libs/workflow-engine/src/state/mod.rs
  - libs/workflow-engine/src/state/step_state.rs
  - libs/workflow-engine/src/state/workflow_state.rs
  - libs/workflow-engine/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "StepState enum tracks step lifecycle (Pending, Active, Completed, Skipped, Failed)"
    - "State transitions are validated with guard functions"
    - "WorkflowState tracks current step and all step states"
  artifacts:
    - path: "libs/workflow-engine/src/state/step_state.rs"
      provides: "Step state enum with transitions"
      contains: "StepState"
    - path: "libs/workflow-engine/src/state/workflow_state.rs"
      provides: "Workflow state aggregate"
      contains: "WorkflowStateManager"
  key_links:
    - from: "libs/workflow-engine/src/state/step_state.rs"
      to: "libs/domain/src/task.rs"
      via: "compatible with WorkflowState in Task"
      pattern: "StepState"
---

<objective>
Implement workflow state machine with enum-based step states.

Purpose: Create the state machine that tracks workflow execution state. Per RESEARCH.md, use enum-based states (not type-state) for runtime flexibility with YAML-defined dynamic workflows.

Output: State module with StepState enum, transition guards, and WorkflowStateManager.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflow-engine/06-CONTEXT.md
@.planning/phases/06-workflow-engine/06-RESEARCH.md
@libs/domain/src/task.rs
@libs/domain/src/enums.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StepState enum with transition guards</name>
  <files>libs/workflow-engine/src/state/mod.rs, libs/workflow-engine/src/state/step_state.rs</files>
  <action>
Create libs/workflow-engine/src/state/mod.rs:
```rust
pub mod step_state;
pub mod workflow_state;

pub use step_state::*;
pub use workflow_state::*;
```

Create libs/workflow-engine/src/state/step_state.rs with:

1. StepState enum (per RESEARCH.md pattern):
```rust
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "status", rename_all = "snake_case")]
pub enum StepState {
    Pending,
    Active {
        started_at: DateTime<Utc>,
        assigned_to: Vec<Uuid>,
        last_activity: DateTime<Utc>,
    },
    Completed {
        completed_at: DateTime<Utc>,
        result: StepResult,
    },
    Skipped {
        reason: String,
        skipped_at: DateTime<Utc>,
    },
    Failed {
        error: String,
        retries: u8,
        failed_at: DateTime<Utc>,
    },
}
```

2. StepResult enum:
   - Submitted { annotations: Vec<Uuid> }
   - Approved
   - Rejected { reason: String }
   - Consensus { agreement: f64, resolved_by: String }
   - AutoProcessed { output: serde_json::Value }
   - ConditionMet { branch: String }
   - SubWorkflowCompleted { output: serde_json::Value }

3. impl StepState with:
   - can_transition_to(&self, target: &StepState) -> bool
   - Valid transitions:
     - Pending -> Active
     - Active -> Completed, Failed, Skipped
     - Failed -> Active (retry), Skipped (give up)
   - is_terminal(&self) -> bool
   - is_active(&self) -> bool

4. StateTransitionError enum:
   - InvalidTransition { from: String, to: String }
   - StepNotFound(String)
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>StepState enum with transition guards implemented per RESEARCH.md pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Create WorkflowStateManager</name>
  <files>libs/workflow-engine/src/state/workflow_state.rs</files>
  <action>
Create libs/workflow-engine/src/state/workflow_state.rs with:

1. WorkflowStateManager struct:
```rust
pub struct WorkflowStateManager {
    current_step_id: Option<String>,
    step_states: HashMap<String, StepState>,
    history: Vec<StateTransition>,
    context: serde_json::Value,  // Shared context between steps
}
```

2. StateTransition struct:
   - from_step: Option<String>
   - to_step: String
   - occurred_at: DateTime<Utc>
   - reason: String

3. impl WorkflowStateManager:
   - new(entry_step_id: &str) -> Self
   - from_snapshot(snapshot: &WorkflowSnapshot) -> Self
   
   - current_step(&self) -> Option<&str>
   - get_step_state(&self, step_id: &str) -> Option<&StepState>
   - set_step_state(&mut self, step_id: &str, state: StepState) -> Result<(), StateTransitionError>
   
   - activate_step(&mut self, step_id: &str, assigned_to: Vec<Uuid>) -> Result<(), StateTransitionError>
   - complete_step(&mut self, step_id: &str, result: StepResult) -> Result<(), StateTransitionError>
   - skip_step(&mut self, step_id: &str, reason: &str) -> Result<(), StateTransitionError>
   - fail_step(&mut self, step_id: &str, error: &str) -> Result<(), StateTransitionError>
   - retry_step(&mut self, step_id: &str) -> Result<u8, StateTransitionError> (returns retry count)
   
   - transition_to(&mut self, next_step_id: &str, reason: &str) -> Result<(), StateTransitionError>
   - record_activity(&mut self, step_id: &str) -> Result<(), StateTransitionError> (updates last_activity for timeout tracking)
   
   - get_context(&self) -> &serde_json::Value
   - set_context(&mut self, key: &str, value: serde_json::Value)
   - merge_context(&mut self, data: serde_json::Value)
   
   - to_snapshot(&self) -> WorkflowSnapshot
   - get_history(&self) -> &[StateTransition]

4. WorkflowSnapshot struct (for event sourcing):
   - version: u64
   - current_step_id: Option<String>
   - step_states: HashMap<String, StepState>
   - context: serde_json::Value
   - created_at: DateTime<Utc>
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>WorkflowStateManager with full state management and snapshotting implemented.</done>
</task>

<task type="auto">
  <name>Task 3: Export state module from lib.rs</name>
  <files>libs/workflow-engine/src/lib.rs</files>
  <action>
Update libs/workflow-engine/src/lib.rs to add:
```rust
pub mod state;
pub use state::*;
```
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>State module exported from workflow-engine crate.</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-workflow-engine` passes
- `grep -r "StepState" libs/workflow-engine/src/state/` finds the enum
- `grep -r "can_transition_to" libs/workflow-engine/` finds guard function
</verification>

<success_criteria>
- StepState enum with Pending, Active, Completed, Skipped, Failed variants
- Transition guards prevent invalid state changes
- WorkflowStateManager tracks current step and all step states
- Activity tracking for inactivity-based timeouts
- Snapshot creation for event sourcing
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflow-engine/06-04-SUMMARY.md`
</output>
