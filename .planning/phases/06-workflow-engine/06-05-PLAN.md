---
phase: 06-workflow-engine
plan: 05
type: execute
wave: 3
depends_on: ["06-03", "06-04"]
files_modified:
  - libs/workflow-engine/src/transition/mod.rs
  - libs/workflow-engine/src/transition/evaluator.rs
  - libs/workflow-engine/src/transition/conditions.rs
  - libs/workflow-engine/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Transitions can be evaluated based on step completion state"
    - "Condition expressions support basic comparisons"
    - "Next step is selected based on first matching transition"
  artifacts:
    - path: "libs/workflow-engine/src/transition/evaluator.rs"
      provides: "Transition evaluation logic"
      contains: "TransitionEvaluator"
    - path: "libs/workflow-engine/src/transition/conditions.rs"
      provides: "Condition evaluation"
      contains: "evaluate_condition"
  key_links:
    - from: "libs/workflow-engine/src/transition/evaluator.rs"
      to: "libs/workflow-engine/src/state/workflow_state.rs"
      via: "reads step state for evaluation"
      pattern: "WorkflowStateManager"
---

<objective>
Implement transition evaluation engine for workflow progression.

Purpose: Evaluate transition conditions to determine the next step in a workflow. Support built-in conditions (always, on_complete, on_agreement, on_disagreement) and simple expression evaluation.

Output: Transition module with TransitionEvaluator and condition handlers.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflow-engine/06-CONTEXT.md
@.planning/phases/06-workflow-engine/06-RESEARCH.md
@libs/workflow-engine/src/config/types.rs
@libs/workflow-engine/src/state/workflow_state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create condition evaluation module</name>
  <files>libs/workflow-engine/src/transition/mod.rs, libs/workflow-engine/src/transition/conditions.rs</files>
  <action>
Create libs/workflow-engine/src/transition/mod.rs:
```rust
pub mod evaluator;
pub mod conditions;

pub use evaluator::*;
pub use conditions::*;
```

Create libs/workflow-engine/src/transition/conditions.rs with:

1. ConditionContext struct:
   - step_result: Option<&StepResult>
   - consensus_agreement: Option<f64>
   - workflow_context: &serde_json::Value
   - step_states: &HashMap<String, StepState>

2. evaluate_condition(condition: &TransitionConditionConfig, ctx: &ConditionContext) -> Result<bool, ConditionError>:
   - Match on condition_type:
     - "always" -> true
     - "on_complete" -> step is in Completed state
     - "on_agreement" -> consensus_agreement >= threshold (from expression or config)
     - "on_disagreement" -> consensus_agreement < threshold
     - "expression" -> evaluate_expression(expression, ctx)

3. evaluate_expression(expr: &str, ctx: &ConditionContext) -> Result<bool, ConditionError>:
   - Parse simple expressions: "field op value"
   - Supported operators: ==, !=, >, <, >=, <=
   - Field can be: "agreement", "step.X.completed", context paths like "context.field"
   - Start simple (per RESEARCH.md recommendation), add complexity later if needed

4. ConditionError enum:
   - ParseError(String)
   - InvalidField(String)
   - TypeMismatch { expected: String, got: String }
   - MissingContext(String)
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>Condition evaluation with built-in types and simple expressions implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Create TransitionEvaluator</name>
  <files>libs/workflow-engine/src/transition/evaluator.rs</files>
  <action>
Create libs/workflow-engine/src/transition/evaluator.rs with:

1. TransitionEvaluator struct:
   - workflow_config: &WorkflowConfig (reference to workflow definition)

2. impl TransitionEvaluator:
   - new(config: &WorkflowConfig) -> Self
   
   - evaluate_next_step(
       &self,
       current_step_id: &str,
       state: &WorkflowStateManager,
       step_result: Option<&StepResult>,
       consensus_agreement: Option<f64>,
     ) -> Result<Option<String>, TransitionError>
     
     - Get all transitions from current_step_id
     - Build ConditionContext from state and arguments
     - Evaluate each transition condition in order
     - Return first matching transition's to_step_id
     - Return None if no transitions match (terminal state)
   
   - get_outgoing_transitions(&self, step_id: &str) -> Vec<&TransitionConfig>
   
   - is_terminal_step(&self, step_id: &str) -> bool:
     - Check if step_id is "_complete" or "_failed"
     - Or has no outgoing transitions

3. TransitionError enum:
   - StepNotFound(String)
   - NoMatchingTransition(String)
   - ConditionError(ConditionError)
   - CycleDetected
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>TransitionEvaluator with ordered condition evaluation implemented.</done>
</task>

<task type="auto">
  <name>Task 3: Export transition module</name>
  <files>libs/workflow-engine/src/lib.rs</files>
  <action>
Update libs/workflow-engine/src/lib.rs to add:
```rust
pub mod transition;
pub use transition::*;
```
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>Transition module exported from workflow-engine crate.</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-workflow-engine` passes
- `grep -r "evaluate_next_step" libs/workflow-engine/` finds evaluator method
- `grep -r "evaluate_condition" libs/workflow-engine/` finds condition handler
</verification>

<success_criteria>
- Built-in conditions (always, on_complete, on_agreement, on_disagreement) work
- Simple expression evaluation (field op value) works
- TransitionEvaluator returns next step based on first matching condition
- Terminal steps (_complete, _failed) properly identified
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflow-engine/06-05-SUMMARY.md`
</output>
