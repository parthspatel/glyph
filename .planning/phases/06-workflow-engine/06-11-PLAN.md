---
phase: 06-workflow-engine
plan: 11
type: execute
wave: 6
depends_on: ["06-01", "06-04", "06-09", "06-10"]
files_modified:
  - libs/workflow-engine/src/events/mod.rs
  - libs/workflow-engine/src/events/store.rs
  - libs/workflow-engine/src/events/types.rs
  - libs/workflow-engine/src/events/replay.rs
  - libs/workflow-engine/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Workflow events are appended to event store"
    - "State can be rebuilt from events"
    - "Snapshots are created every 50 events"
  artifacts:
    - path: "libs/workflow-engine/src/events/store.rs"
      provides: "Event store with append and replay"
      contains: "EventStore"
    - path: "libs/workflow-engine/src/events/types.rs"
      provides: "Workflow event types"
      contains: "WorkflowEvent"
  key_links:
    - from: "libs/workflow-engine/src/events/store.rs"
      to: "migrations/0015_workflow_events.sql"
      via: "persists to workflow_events table"
      pattern: "workflow_events"
---

<objective>
Implement event sourcing for workflow state persistence.

Purpose: Persist all workflow state changes as events for audit trail and state reconstruction. Per RESEARCH.md: snapshot every 50 events for replay performance.

Output: Events module with EventStore, event types, and replay functionality.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflow-engine/06-CONTEXT.md
@.planning/phases/06-workflow-engine/06-RESEARCH.md
@libs/workflow-engine/src/state/workflow_state.rs
@migrations/0015_workflow_events.sql
@migrations/0016_workflow_snapshots.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define event types</name>
  <files>libs/workflow-engine/src/events/mod.rs, libs/workflow-engine/src/events/types.rs</files>
  <action>
Create libs/workflow-engine/src/events/mod.rs:
```rust
pub mod types;
pub mod store;
pub mod replay;

pub use types::*;
pub use store::*;
pub use replay::*;
```

Create libs/workflow-engine/src/events/types.rs with:

1. WorkflowEvent enum (per RESEARCH.md):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum WorkflowEvent {
    WorkflowStarted {
        workflow_id: Uuid,
        config_version: String,
        started_at: DateTime<Utc>,
    },
    StepActivated {
        step_id: String,
        assigned_to: Vec<Uuid>,
        activated_at: DateTime<Utc>,
    },
    StepCompleted {
        step_id: String,
        result: StepResult,
        completed_at: DateTime<Utc>,
    },
    StepFailed {
        step_id: String,
        error: String,
        retries: u8,
        failed_at: DateTime<Utc>,
    },
    StepSkipped {
        step_id: String,
        reason: String,
        skipped_at: DateTime<Utc>,
    },
    TransitionOccurred {
        from_step: String,
        to_step: String,
        condition_met: Option<String>,
        occurred_at: DateTime<Utc>,
    },
    ConsensusCalculated {
        step_id: String,
        agreement: f64,
        metric: String,
        resolved_by: Option<String>,
        calculated_at: DateTime<Utc>,
    },
    ContextUpdated {
        key: String,
        value: serde_json::Value,
        updated_at: DateTime<Utc>,
    },
    WorkflowCompleted {
        final_output: serde_json::Value,
        completed_at: DateTime<Utc>,
    },
    WorkflowFailed {
        error: String,
        recoverable: bool,
        failed_at: DateTime<Utc>,
    },
}
```

2. StoredEvent struct:
   - event_id: Uuid
   - stream_id: Uuid
   - stream_type: String
   - version: u64
   - event: WorkflowEvent
   - metadata: serde_json::Value
   - occurred_at: DateTime<Utc>
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>All workflow event types defined with serde serialization.</done>
</task>

<task type="auto">
  <name>Task 2: Create event store</name>
  <files>libs/workflow-engine/src/events/store.rs</files>
  <action>
Create libs/workflow-engine/src/events/store.rs with:

1. const SNAPSHOT_INTERVAL: u64 = 50;  // Per RESEARCH.md

2. #[async_trait] trait EventStore: Send + Sync:
   - async append(&self, stream_id: Uuid, events: Vec<WorkflowEvent>) -> Result<u64, EventStoreError>
   - async load_events(&self, stream_id: Uuid, from_version: u64) -> Result<Vec<StoredEvent>, EventStoreError>
   - async get_latest_snapshot(&self, stream_id: Uuid) -> Result<Option<WorkflowSnapshot>, EventStoreError>
   - async save_snapshot(&self, stream_id: Uuid, snapshot: &WorkflowSnapshot) -> Result<(), EventStoreError>

3. PgEventStore struct (PostgreSQL implementation):
   - pool: sqlx::PgPool
   - current_versions: HashMap<Uuid, u64>  // Cache of latest versions

4. impl EventStore for PgEventStore:
   - append:
     - Get current version for stream (from cache or DB)
     - Insert events with incrementing versions
     - Use optimistic concurrency (check version hasn't changed)
     - If (current_version % SNAPSHOT_INTERVAL) == 0, trigger snapshot
   
   - load_events:
     - SELECT from workflow_events WHERE stream_id = ? AND version > ? ORDER BY version
   
   - get_latest_snapshot:
     - SELECT from workflow_snapshots WHERE stream_id = ? ORDER BY version DESC LIMIT 1
   
   - save_snapshot:
     - INSERT into workflow_snapshots

5. EventStoreError enum:
   - ConcurrencyConflict { expected: u64, actual: u64 }
   - StreamNotFound(Uuid)
   - DatabaseError(String)
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>Event store with PostgreSQL implementation and snapshot triggers.</done>
</task>

<task type="auto">
  <name>Task 3: Create replay functionality</name>
  <files>libs/workflow-engine/src/events/replay.rs, libs/workflow-engine/src/lib.rs</files>
  <action>
Create libs/workflow-engine/src/events/replay.rs with:

1. StateRebuilder struct:
   - event_store: Arc<dyn EventStore>

2. impl StateRebuilder:
   - async rebuild_state(&self, stream_id: Uuid) -> Result<WorkflowStateManager, ReplayError>:
     - Load latest snapshot from event store
     - If snapshot exists:
       - Initialize state from snapshot
       - Load events after snapshot version
     - If no snapshot:
       - Load all events for stream
       - Initialize empty state
     - Apply each event to state in order
     - Return rebuilt state
   
   - apply_event(state: &mut WorkflowStateManager, event: &WorkflowEvent):
     - Match on event type
     - Update state accordingly:
       - WorkflowStarted -> set current_step to entry
       - StepActivated -> state.activate_step()
       - StepCompleted -> state.complete_step()
       - TransitionOccurred -> state.transition_to()
       - ContextUpdated -> state.set_context()
       - etc.

3. ReplayError enum:
   - EventStoreError(EventStoreError)
   - InvalidEventSequence(String)
   - SnapshotCorrupted

Update libs/workflow-engine/src/lib.rs:
```rust
pub mod events;
pub use events::*;
```
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>State replay from events with snapshot optimization implemented.</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-workflow-engine` passes
- `grep -r "SNAPSHOT_INTERVAL" libs/workflow-engine/` finds 50 events config
- `grep -r "WorkflowEvent" libs/workflow-engine/src/events/` finds all event types
</verification>

<success_criteria>
- All workflow events defined (Started, StepActivated, Completed, Failed, etc.)
- Events persisted to workflow_events table
- Snapshots created every 50 events
- State can be rebuilt from snapshot + events
- Optimistic concurrency prevents lost updates
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflow-engine/06-11-SUMMARY.md`
</output>
