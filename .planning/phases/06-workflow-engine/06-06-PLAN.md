---
phase: 06-workflow-engine
plan: 06
type: execute
wave: 3
depends_on: ["06-01"]
files_modified:
  - libs/workflow-engine/src/consensus/mod.rs
  - libs/workflow-engine/src/consensus/kappa.rs
  - libs/workflow-engine/src/consensus/alpha.rs
  - libs/workflow-engine/src/consensus/iou.rs
  - libs/workflow-engine/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Cohen's Kappa calculates agreement for 2 annotators"
    - "Krippendorff's Alpha handles missing data and multiple annotators"
    - "IoU calculates span/box overlap"
  artifacts:
    - path: "libs/workflow-engine/src/consensus/kappa.rs"
      provides: "Cohen's Kappa implementation"
      contains: "cohens_kappa"
    - path: "libs/workflow-engine/src/consensus/alpha.rs"
      provides: "Krippendorff's Alpha implementation"
      contains: "krippendorffs_alpha"
    - path: "libs/workflow-engine/src/consensus/iou.rs"
      provides: "IoU for spans and boxes"
      contains: "iou_span"
  key_links:
    - from: "libs/workflow-engine/src/consensus/mod.rs"
      to: "libs/domain/src/enums.rs"
      via: "ConsensusMethod enum usage"
      pattern: "ConsensusMethod"
---

<objective>
Implement consensus algorithms for inter-annotator agreement.

Purpose: Calculate agreement metrics between annotators to determine if consensus was reached. Per RESEARCH.md, implement Krippendorff's Alpha in-house (no mature Rust crate), Cohen's Kappa for pairwise, and IoU for spans/boxes.

Output: Consensus module with Kappa, Alpha, and IoU implementations.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflow-engine/06-CONTEXT.md
@.planning/phases/06-workflow-engine/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Cohen's Kappa</name>
  <files>libs/workflow-engine/src/consensus/mod.rs, libs/workflow-engine/src/consensus/kappa.rs</files>
  <action>
Create libs/workflow-engine/src/consensus/mod.rs:
```rust
pub mod kappa;
pub mod alpha;
pub mod iou;

pub use kappa::*;
pub use alpha::*;
pub use iou::*;
```

Create libs/workflow-engine/src/consensus/kappa.rs with:

1. cohens_kappa(a: &[u32], b: &[u32]) -> Result<f64, ConsensusError>:
   - Validate both arrays have same length
   - Calculate observed agreement (Po):
     - Count matching values / total items
   - Calculate expected agreement (Pe):
     - For each category, calculate probability of both choosing it by chance
     - Pe = sum over categories of (P_a * P_b)
   - Kappa = (Po - Pe) / (1 - Pe)
   - Handle edge case where Pe = 1 (return 1.0)

2. cohens_kappa_weighted(a: &[u32], b: &[u32], weights: &[f64]) -> Result<f64, ConsensusError>:
   - Weighted version for ordinal data
   - Use linear or quadratic weights

3. ConsensusError enum:
   - LengthMismatch { expected: usize, got: usize }
   - EmptyInput
   - InvalidCategory(String)
   - ComputationError(String)

Per RESEARCH.md formula: Îº = (Po - Pe) / (1 - Pe)
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>Cohen's Kappa for 2 annotators implemented with weighted variant.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Krippendorff's Alpha</name>
  <files>libs/workflow-engine/src/consensus/alpha.rs</files>
  <action>
Create libs/workflow-engine/src/consensus/alpha.rs with:

Per RESEARCH.md, Alpha = 1 - (Do / De) where Do is observed disagreement, De is expected disagreement.

1. krippendorffs_alpha_nominal(annotations: &[Vec<Option<u32>>]) -> Result<f64, ConsensusError>:
   - annotations[i][j] = annotator i's label for item j (None if missing)
   - Build coincidence matrix:
     - For each item, for each pair of non-missing values, increment coincidence[val1][val2]
   - Calculate observed disagreement (Do):
     - Sum of off-diagonal coincidences / total coincidences
   - Calculate expected disagreement (De):
     - Based on marginal frequencies
   - Alpha = 1 - (Do / De)
   - Handle missing data naturally (skip missing pairs)

2. krippendorffs_alpha_ordinal(annotations: &[Vec<Option<u32>>]) -> Result<f64, ConsensusError>:
   - Use ordinal metric (squared distance between categories)

3. krippendorffs_alpha_interval(annotations: &[Vec<Option<f64>>]) -> Result<f64, ConsensusError>:
   - Use interval metric (squared difference)

4. Helper functions:
   - build_coincidence_matrix(annotations) -> HashMap<(u32, u32), f64>
   - calculate_marginals(coincidence_matrix) -> HashMap<u32, f64>

Note: Stream-based calculation not needed for v1, optimize later if needed (per RESEARCH.md, set `evaluation: checkpoint` for large datasets).
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>Krippendorff's Alpha for nominal, ordinal, and interval data implemented.</done>
</task>

<task type="auto">
  <name>Task 3: Implement IoU for spans and boxes</name>
  <files>libs/workflow-engine/src/consensus/iou.rs, libs/workflow-engine/src/lib.rs</files>
  <action>
Create libs/workflow-engine/src/consensus/iou.rs with:

1. Span struct:
   - start: usize
   - end: usize

2. iou_span(a: &Span, b: &Span) -> f64:
   - intersection_start = max(a.start, b.start)
   - intersection_end = min(a.end, b.end)
   - intersection = max(0, intersection_end - intersection_start)
   - union = (a.end - a.start) + (b.end - b.start) - intersection
   - Return intersection / union (handle division by zero -> 0.0)

3. BoundingBox struct:
   - x: f64, y: f64, width: f64, height: f64

4. iou_box(a: &BoundingBox, b: &BoundingBox) -> f64:
   - Calculate intersection area
   - Calculate union area
   - Return intersection / union

5. average_iou_spans(spans_a: &[Span], spans_b: &[Span]) -> f64:
   - Match spans greedily by highest IoU
   - Return average IoU of matched pairs

6. Update libs/workflow-engine/src/lib.rs:
```rust
pub mod consensus;
pub use consensus::*;
```
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>IoU for spans and bounding boxes implemented, consensus module exported.</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-workflow-engine` passes
- `grep -r "cohens_kappa" libs/workflow-engine/` finds implementation
- `grep -r "krippendorffs_alpha" libs/workflow-engine/` finds implementation
- `grep -r "iou_span" libs/workflow-engine/` finds implementation
</verification>

<success_criteria>
- Cohen's Kappa works for 2 annotators with categorical data
- Krippendorff's Alpha handles missing data and multiple annotators
- IoU calculates span overlap correctly
- All functions handle edge cases (empty input, division by zero)
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflow-engine/06-06-SUMMARY.md`
</output>
