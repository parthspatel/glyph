---
phase: 06-workflow-engine
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - libs/workflow-engine/src/parser/mod.rs
  - libs/workflow-engine/src/parser/parser.rs
  - libs/workflow-engine/src/parser/validator.rs
  - libs/workflow-engine/src/lib.rs
  - Cargo.toml
  - libs/workflow-engine/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "YAML workflows can be parsed from strings"
    - "Invalid step references are rejected with helpful errors"
    - "Cyclic workflows are detected and rejected"
    - "All paths lead to terminal state"
  artifacts:
    - path: "libs/workflow-engine/src/parser/parser.rs"
      provides: "YAML parsing logic"
      contains: "parse_workflow"
    - path: "libs/workflow-engine/src/parser/validator.rs"
      provides: "DAG validation with petgraph"
      contains: "validate_dag"
  key_links:
    - from: "libs/workflow-engine/src/parser/validator.rs"
      to: "petgraph"
      via: "cycle detection"
      pattern: "is_cyclic_directed"
---

<objective>
Implement YAML workflow parser with structural validation using petgraph.

Purpose: Parse YAML workflow configurations and validate their structure before saving. Detect cycles, unreachable states, and invalid step references with detailed error messages including typo suggestions.

Output: Parser module that converts YAML strings to validated WorkflowConfig with helpful error messages.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflow-engine/06-CONTEXT.md
@.planning/phases/06-workflow-engine/06-RESEARCH.md
@libs/workflow-engine/src/config/types.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create YAML parser</name>
  <files>libs/workflow-engine/src/parser/mod.rs, libs/workflow-engine/src/parser/parser.rs</files>
  <action>
Create libs/workflow-engine/src/parser/mod.rs:
```rust
pub mod parser;
pub mod validator;

pub use parser::*;
pub use validator::*;
```

Create libs/workflow-engine/src/parser/parser.rs with:

1. ParseError enum:
   - YamlError(serde_yml::Error)
   - ValidationError(ValidationError)

2. parse_workflow(yaml: &str) -> Result<WorkflowConfig, ParseError>:
   - Parse YAML using serde_yml::from_str
   - Call validate_workflow on parsed config
   - Return validated config or detailed error

3. parse_workflow_with_library(yaml: &str, library: &StepLibrary) -> Result<WorkflowConfig, ParseError>:
   - Parse YAML
   - Resolve step library references using library.resolve()
   - Validate fully resolved config
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>YAML parser functions implemented with serde_yml integration.</done>
</task>

<task type="auto">
  <name>Task 2: Create structural validator with petgraph</name>
  <files>libs/workflow-engine/src/parser/validator.rs</files>
  <action>
Create libs/workflow-engine/src/parser/validator.rs with:

1. ValidationError struct with fields:
   - message: String
   - location: Option<String> (e.g., "step.transitions[2].to")
   - suggestion: Option<String> (e.g., "Did you mean 'review'?")

2. validate_workflow(config: &WorkflowConfig) -> Result<(), ValidationError>:
   - Call all validation functions
   - Collect all errors before returning

3. validate_step_references(config: &WorkflowConfig) -> Result<(), ValidationError>:
   - Build HashSet of step IDs
   - Check all transition from/to references exist
   - On unknown reference, use strsim::levenshtein to suggest similar step names

4. validate_dag(config: &WorkflowConfig) -> Result<(), ValidationError>:
   - Build petgraph::DiGraph from steps and transitions
   - Use algo::is_cyclic_directed() to detect cycles
   - If cycle found, use algo::kosaraju_scc() to identify cycle nodes

5. validate_reachability(config: &WorkflowConfig) -> Result<(), ValidationError>:
   - Build graph
   - Find entry step (first step or explicitly marked)
   - Use petgraph::visit::Dfs to check all steps are reachable from entry
   - Check all non-terminal steps have outgoing transitions
   - Check terminal states (_complete, _failed) are reachable

6. validate_timeout_bounds(config: &WorkflowConfig) -> Result<(), ValidationError>:
   - Check timeout_minutes <= 480 (8 hours max per CONTEXT.md)
   - Check timeout_minutes > 0

Add strsim to workspace dependencies for typo detection (levenshtein distance).
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>DAG validation with cycle detection, reachability checks, and typo suggestions implemented.</done>
</task>

<task type="auto">
  <name>Task 3: Update lib.rs and add strsim dependency</name>
  <files>libs/workflow-engine/src/lib.rs, Cargo.toml, libs/workflow-engine/Cargo.toml</files>
  <action>
Add strsim to workspace Cargo.toml:
```toml
strsim = "0.11"
```

Add to libs/workflow-engine/Cargo.toml:
```toml
strsim.workspace = true
```

Update libs/workflow-engine/src/lib.rs:
```rust
pub mod parser;
pub use parser::*;
```
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>Parser module exported and strsim dependency added for typo suggestions.</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-workflow-engine` passes
- `grep -r "is_cyclic_directed" libs/workflow-engine/` finds petgraph usage
- `grep -r "levenshtein" libs/workflow-engine/` finds strsim usage
</verification>

<success_criteria>
- parse_workflow function parses valid YAML
- Invalid step references return error with "Did you mean X?" suggestion
- Cyclic workflows are rejected with clear cycle identification
- Unreachable steps are detected
- Timeout values outside 0-480 range are rejected
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflow-engine/06-03-SUMMARY.md`
</output>
