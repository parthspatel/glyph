---
phase: 06-workflow-engine
plan: 12
type: execute
wave: 7
depends_on: ["06-09", "06-10", "06-11"]
files_modified:
  - libs/workflow-engine/src/engine.rs
  - libs/workflow-engine/src/lib.rs
  - apps/api/src/routes/workflows.rs
autonomous: true

must_haves:
  truths:
    - "WorkflowOrchestrator integrates all components"
    - "Single workflow executes correctly end-to-end"
    - "API exposes workflow operations"
  artifacts:
    - path: "libs/workflow-engine/src/engine.rs"
      provides: "Complete workflow orchestration"
      contains: "WorkflowOrchestrator"
    - path: "apps/api/src/routes/workflows.rs"
      provides: "Workflow API endpoints"
      contains: "create_workflow"
  key_links:
    - from: "libs/workflow-engine/src/engine.rs"
      to: "libs/workflow-engine/src/events/store.rs"
      via: "persists events"
      pattern: "EventStore"
---

<objective>
Integrate all workflow engine components into WorkflowOrchestrator.

Purpose: Wire together parser, state machine, executors, transitions, goals, and events into a cohesive orchestrator. Expose API endpoints for workflow operations.

Output: Complete WorkflowOrchestrator and workflow API routes.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-workflow-engine/06-CONTEXT.md
@.planning/phases/06-workflow-engine/06-RESEARCH.md
@libs/workflow-engine/src/lib.rs
@apps/api/src/routes/workflows.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkflowOrchestrator</name>
  <files>libs/workflow-engine/src/engine.rs</files>
  <action>
Update/replace libs/workflow-engine/src/engine.rs with complete orchestrator:

1. WorkflowOrchestrator struct:
   - config_store: Arc<dyn WorkflowConfigStore>  // Stores parsed workflow configs
   - event_store: Arc<dyn EventStore>
   - handler_registry: Arc<HandlerRegistry>
   - goal_tracker: Arc<Mutex<GoalTracker>>
   - step_library: Arc<StepLibrary>

2. impl WorkflowOrchestrator:
   - new(config_store, event_store, pool) -> Self:
     - Initialize handler_registry with builtins
     - Initialize goal_tracker
     - Initialize step_library with predefined templates
   
   - async create_workflow(yaml: &str) -> Result<WorkflowConfig, OrchestrationError>:
     - Parse YAML using parser
     - Validate using validator
     - Store in config_store
     - Return validated config
   
   - async start_task(task_id: Uuid, workflow_id: Uuid) -> Result<(), OrchestrationError>:
     - Load workflow config
     - Create initial state at entry step
     - Emit WorkflowStarted event
     - Activate entry step
   
   - async process_submission(task_id: Uuid, step_id: &str, annotation: AnnotationData) -> Result<ProcessResult, OrchestrationError>:
     - Rebuild state from events
     - Add annotation to context
     - Execute step
     - If Complete:
       - Emit StepCompleted event
       - Evaluate transitions
       - Emit TransitionOccurred event
       - Activate next step (if any)
       - Update goal tracker
     - If Waiting:
       - Record activity for timeout tracking
     - Create snapshot if needed
     - Return result
   
   - async advance_task(task_id: Uuid) -> Result<Option<String>, OrchestrationError>:
     - Rebuild state
     - Execute current step if auto-executable
     - Evaluate transitions
     - Return next step or None if complete
   
   - async get_task_state(task_id: Uuid) -> Result<WorkflowStateManager, OrchestrationError>:
     - Rebuild from events using StateRebuilder

3. ProcessResult enum:
   - Waiting { step_id: String, reason: String }
   - Advanced { next_step: String }
   - Completed { output: serde_json::Value }
   - Failed { error: String }

4. OrchestrationError enum:
   - ConfigNotFound(Uuid)
   - ParseError(ParseError)
   - ExecutionError(ExecutorError)
   - EventStoreError(EventStoreError)
   - StateError(StateTransitionError)

5. trait WorkflowConfigStore: Send + Sync:
   - async save(&self, config: &WorkflowConfig) -> Result<Uuid, StorageError>
   - async load(&self, id: Uuid) -> Result<WorkflowConfig, StorageError>
   - async load_by_name(&self, name: &str) -> Result<WorkflowConfig, StorageError>
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine`.</verify>
  <done>WorkflowOrchestrator integrating all components implemented.</done>
</task>

<task type="auto">
  <name>Task 2: Wire up API routes</name>
  <files>apps/api/src/routes/workflows.rs</files>
  <action>
Update apps/api/src/routes/workflows.rs with actual implementations:

1. POST /api/v1/workflows:
   - Accept YAML body
   - Call orchestrator.create_workflow()
   - Return created workflow config or validation errors

2. GET /api/v1/workflows/{id}:
   - Load workflow config by ID
   - Return config

3. POST /api/v1/tasks/{task_id}/start:
   - Call orchestrator.start_task()
   - Return initial state

4. POST /api/v1/tasks/{task_id}/submit:
   - Accept annotation submission
   - Call orchestrator.process_submission()
   - Return ProcessResult

5. GET /api/v1/tasks/{task_id}/state:
   - Call orchestrator.get_task_state()
   - Return current workflow state

6. POST /api/v1/tasks/{task_id}/advance:
   - Call orchestrator.advance_task()
   - Return next step or completion status

Add AppState extension for WorkflowOrchestrator access.
  </action>
  <verify>Run `cargo check -p glyph-api`.</verify>
  <done>Workflow API routes wired to orchestrator.</done>
</task>

<task type="auto">
  <name>Task 3: Final lib.rs cleanup and exports</name>
  <files>libs/workflow-engine/src/lib.rs</files>
  <action>
Ensure libs/workflow-engine/src/lib.rs has clean exports:

```rust
//! Workflow engine for Glyph
//!
//! Provides workflow state machine, step execution, transitions,
//! consensus calculation, goal tracking, and event sourcing.

pub mod config;
pub mod parser;
pub mod state;
pub mod transition;
pub mod consensus;
pub mod executor;
pub mod goals;
pub mod events;

// Re-export main types at crate root
pub use config::{WorkflowConfig, StepConfig, TransitionConfig, StepLibrary};
pub use parser::{parse_workflow, parse_workflow_with_library, ParseError, ValidationError};
pub use state::{StepState, StepResult, WorkflowStateManager, WorkflowSnapshot};
pub use transition::{TransitionEvaluator, ConditionError};
pub use consensus::{cohens_kappa, krippendorffs_alpha_nominal, iou_span, ConsensusError};
pub use executor::{StepExecutor, ExecutionContext, ExecutionResult, create_executor, HandlerRegistry};
pub use goals::{GoalTracker, GoalEvaluator, CompletionAction};
pub use events::{WorkflowEvent, EventStore, PgEventStore, StateRebuilder};

// Main orchestrator
mod engine;
pub use engine::{WorkflowOrchestrator, ProcessResult, OrchestrationError, WorkflowConfigStore};

// Backward compatibility
pub mod assignment;
```
  </action>
  <verify>Run `cargo check -p glyph-workflow-engine` and `cargo check -p glyph-api`.</verify>
  <done>All exports clean and accessible from crate root.</done>
</task>

</tasks>

<verification>
- `cargo check -p glyph-workflow-engine` passes
- `cargo check -p glyph-api` passes
- `cargo test -p glyph-workflow-engine` (any tests) pass
- POST /api/v1/workflows endpoint accepts YAML
</verification>

<success_criteria>
- WorkflowOrchestrator integrates config, state, execution, events, goals
- create_workflow parses and validates YAML
- start_task initializes workflow state and emits events
- process_submission handles annotation and advances workflow
- API routes expose workflow operations
- All crate exports are clean and documented
</success_criteria>

<output>
After completion, create `.planning/phases/06-workflow-engine/06-12-SUMMARY.md`
</output>
