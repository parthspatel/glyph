---
phase: 07-task-management
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - apps/api/src/routes/queue.rs
  - apps/api/src/services/assignment_service.rs
  - apps/api/src/services/mod.rs
  - libs/db/src/repo/pg_task.rs
  - libs/domain/src/task.rs
autonomous: true

must_haves:
  truths:
    - "Annotators can accept assignments"
    - "Annotators can reject assignments with a reason"
    - "Rejected tasks enter cooldown before reassignment"
    - "Tasks are prioritized by composite scoring"
    - "Pool mode allows claiming from available tasks"
  artifacts:
    - path: "apps/api/src/routes/queue.rs"
      provides: "Accept/reject endpoints"
      contains: "accept_task"
    - path: "apps/api/src/services/assignment_service.rs"
      provides: "Assignment business logic"
      exports: ["AssignmentService"]
  key_links:
    - from: "apps/api/src/routes/queue.rs"
      to: "apps/api/src/services/assignment_service.rs"
      via: "service call"
      pattern: "assignment_service"
---

<objective>
Implement Accept/Reject Flow and Priority Scoring

Purpose: Enable annotators to accept or reject task assignments with proper cooldown handling and priority-based ordering.

Output: Accept/reject API endpoints and priority scoring algorithm.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-task-management/07-CONTEXT.md
@.planning/phases/07-task-management/07-RESEARCH.md
@.planning/phases/07-task-management/07-01-SUMMARY.md
@.planning/phases/07-task-management/07-02-SUMMARY.md
@apps/api/src/routes/queue.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Accept/Reject Endpoints</name>
  <files>
    apps/api/src/routes/queue.rs
    libs/domain/src/task.rs
  </files>
  <action>
Add accept/reject endpoints to `apps/api/src/routes/queue.rs`:

**1. Add RejectReason enum to domain (libs/domain/src/task.rs):**
```rust
#[typeshare]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum RejectReason {
    ConflictOfInterest,
    UnclearInstructions,
    MissingContext,
    OutsideExpertise,
    ScheduleConflict,
    TechnicalIssues,
    Other { details: String },
}
```

**2. Add request types:**
```rust
#[derive(Debug, Deserialize)]
pub struct RejectRequest {
    pub reason: RejectReason,
}

#[derive(Debug, Serialize)]
pub struct AcceptResponse {
    pub assignment_id: Uuid,
    pub task_id: Uuid,
    pub redirect_url: String, // URL to annotation interface
}
```

**3. Implement endpoints:**

`POST /api/v1/queue/{assignment_id}/accept`:
```rust
async fn accept_task(
    Path(assignment_id): Path<Uuid>,
    State(state): State<AppState>,
    auth: AuthUser,
) -> Result<Json<AcceptResponse>, ApiError> {
    // 1. Verify assignment belongs to current user
    let assignment = state.assignment_repo.find_by_id(&assignment_id.into()).await?
        .ok_or(ApiError::not_found("Assignment not found"))?;
    
    if assignment.user_id != auth.user_id {
        return Err(ApiError::forbidden("Assignment belongs to another user"));
    }
    
    // 2. Check assignment status is 'assigned'
    if assignment.status != AssignmentStatus::Assigned {
        return Err(ApiError::conflict("Assignment cannot be accepted in current state"));
    }
    
    // 3. Update to 'accepted' with accepted_at = NOW()
    state.assignment_repo.update_status(&assignment_id.into(), AssignmentStatus::Accepted).await?;
    
    // 4. Broadcast event
    state.ws_hub.broadcast_to_user(auth.user_id.into(), QueueEvent::TaskStatusChanged {
        task_id: assignment.task_id.into(),
        assignment_id: assignment_id,
        old_status: "assigned".into(),
        new_status: "accepted".into(),
    }).await;
    
    Ok(Json(AcceptResponse {
        assignment_id,
        task_id: assignment.task_id.into(),
        redirect_url: format!("/annotate/{}", assignment.task_id),
    }))
}
```

`POST /api/v1/queue/{assignment_id}/reject`:
```rust
async fn reject_task(
    Path(assignment_id): Path<Uuid>,
    State(state): State<AppState>,
    auth: AuthUser,
    Json(req): Json<RejectRequest>,
) -> Result<StatusCode, ApiError> {
    // 1. Verify ownership
    let assignment = state.assignment_repo.find_by_id(&assignment_id.into()).await?
        .ok_or(ApiError::not_found("Assignment not found"))?;
    
    if assignment.user_id != auth.user_id {
        return Err(ApiError::forbidden("Assignment belongs to another user"));
    }
    
    // 2. Record rejection
    state.assignment_repo.reject(&RejectAssignment {
        assignment_id: assignment_id.into(),
        reason: serde_json::to_value(&req.reason)?,
    }).await?;
    
    // 3. Set task cooldown (configurable per step, 2 min default)
    // Lookup step config from workflow
    let step_config = get_step_config(&state.pool, assignment.project_id.into(), &assignment.step_id).await?;
    let cooldown_minutes = step_config
        .and_then(|s| s.assignment.as_ref())
        .and_then(|a| a.cooldown_minutes)
        .unwrap_or(2);
    let cooldown_until = Utc::now() + chrono::Duration::minutes(cooldown_minutes as i64);
    state.task_repo.set_cooldown(&assignment.task_id, cooldown_until).await?;
    
    // 4. Broadcast rejection (triggers reassignment in worker)
    state.ws_hub.broadcast_to_user(auth.user_id.into(), QueueEvent::TaskStatusChanged {
        task_id: assignment.task_id.into(),
        assignment_id,
        old_status: "assigned".into(),
        new_status: "rejected".into(),
    }).await;
    
    Ok(StatusCode::NO_CONTENT)
}
```

**4. Add cooldown method to task repo:**
In `libs/db/src/repo/pg_task.rs`:
```rust
pub async fn set_cooldown(&self, task_id: &TaskId, until: DateTime<Utc>) -> Result<(), UpdateTaskError> {
    sqlx::query!(
        "UPDATE tasks SET cooldown_until = $1, updated_at = NOW() WHERE task_id = $2",
        until,
        task_id.as_uuid()
    )
    .execute(&self.pool)
    .await?;
    Ok(())
}
```
  </action>
  <verify>
    cargo check -p glyph-api
  </verify>
  <done>
    Accept/reject endpoints compile with proper validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Priority Scoring and Pool Claiming</name>
  <files>
    apps/api/src/services/assignment_service.rs
    apps/api/src/services/mod.rs
    apps/api/src/routes/queue.rs
  </files>
  <action>
**1. Create `apps/api/src/services/assignment_service.rs`:**

```rust
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// Priority weights (configurable per project)
#[derive(Debug, Clone)]
pub struct PriorityWeights {
    pub deadline: f64,     // 0.4 default
    pub project: f64,      // 0.35 default
    pub age: f64,          // 0.25 default
}

impl Default for PriorityWeights {
    fn default() -> Self {
        Self { deadline: 0.4, project: 0.35, age: 0.25 }
    }
}

pub struct AssignmentServiceImpl<'a> {
    task_repo: &'a dyn TaskRepository,
    assignment_repo: &'a dyn AssignmentRepository,
    user_repo: &'a dyn UserRepository,
}

impl<'a> AssignmentServiceImpl<'a> {
    /// Calculate composite priority score for a task
    pub fn calculate_priority_score(
        &self,
        task_priority: i32,           // -100 to 100
        project_priority: i32,        // Project-level priority
        created_at: DateTime<Utc>,
        deadline: Option<DateTime<Utc>>,
        weights: &PriorityWeights,
    ) -> f64 {
        // Normalize task priority to 0-1
        let task_score = (task_priority + 100) as f64 / 200.0;
        
        // Age score: older tasks get higher scores (max at 7 days)
        let age_hours = (Utc::now() - created_at).num_hours() as f64;
        let age_score = (age_hours / (7.0 * 24.0)).min(1.0);
        
        // Deadline urgency (if exists)
        let deadline_score = deadline.map(|d| {
            let hours_until = (d - Utc::now()).num_hours() as f64;
            if hours_until <= 0.0 { 1.0 }  // Overdue
            else if hours_until <= 24.0 { 0.9 }  // Due within day
            else if hours_until <= 72.0 { 0.6 }  // Due within 3 days
            else { 0.3 }
        }).unwrap_or(0.0);
        
        // Composite score
        (weights.deadline * deadline_score) +
        (weights.project * (project_priority as f64 / 100.0)) +
        (weights.age * age_score) +
        (task_score * 0.1)  // Small bonus for explicit priority
    }
    
    /// Get available tasks for claiming (pool mode)
    /// Assignment mode is stored in WorkflowStep.assignment.mode (AssignmentMode enum)
    /// from libs/domain/src/workflow.rs - mode can be Auto, Manual, or Pool
    pub async fn get_claimable_tasks(
        &self,
        user_id: Uuid,
        project_id: Option<Uuid>,
        step_id: Option<String>,
        limit: i32,
    ) -> Result<Vec<ClaimableTask>, ApiError> {
        let rows = sqlx::query_as!(
            ClaimableTask,
            r#"
            SELECT 
                t.task_id,
                t.project_id,
                p.name as project_name,
                COALESCE(ta.step_id, w.entry_step_id) as step_id,
                t.priority,
                t.created_at as task_created_at,
                (t.priority::float / 100.0 + 
                 EXTRACT(EPOCH FROM (NOW() - t.created_at)) / 604800.0 * 0.25) as "priority_score!"
            FROM tasks t
            JOIN projects p ON t.project_id = p.project_id
            JOIN workflows w ON p.workflow_id = w.workflow_id
            LEFT JOIN task_assignments ta ON t.task_id = ta.task_id 
                AND ta.status IN ('expired', 'reassigned', 'rejected')
            WHERE t.status = 'pending'
              AND (t.cooldown_until IS NULL OR t.cooldown_until < NOW())
              AND ($1::uuid IS NULL OR t.project_id = $1)
              AND NOT EXISTS (
                  SELECT 1 FROM task_assignments prev 
                  WHERE prev.task_id = t.task_id AND prev.user_id = $2
              )
              AND EXISTS (
                  SELECT 1 FROM jsonb_array_elements(w.steps) AS s
                  WHERE s->>'step_id' = COALESCE(ta.step_id, w.entry_step_id)
                    AND s->'assignment'->>'mode' = 'pool'
                    AND ($3::text IS NULL OR s->>'step_id' = $3)
              )
            ORDER BY priority_score DESC
            LIMIT $4
            "#,
            project_id,
            user_id,
            step_id,
            limit as i64
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(rows)
    }
    
    /// Claim a task from the pool using optimistic locking
    pub async fn claim_task(
        &self,
        user_id: Uuid,
        task_id: Uuid,
        step_id: String,
    ) -> Result<TaskAssignment, ApiError> {
        let mut tx = self.pool.begin().await?;
        
        // Optimistic lock with version check + SKIP LOCKED to prevent races
        let task = sqlx::query!(
            r#"SELECT task_id, project_id, version FROM tasks 
               WHERE task_id = $1 
                 AND status = 'pending'
                 AND (cooldown_until IS NULL OR cooldown_until < NOW())
               FOR UPDATE SKIP LOCKED"#,
            task_id
        )
        .fetch_optional(&mut *tx)
        .await?
        .ok_or_else(|| ApiError::conflict("Task unavailable or already claimed"))?;
        
        // Create assignment
        let assignment_id = Uuid::now_v7();
        sqlx::query!(
            r#"INSERT INTO task_assignments (assignment_id, task_id, project_id, step_id, user_id, status, assigned_at)
               VALUES ($1, $2, $3, $4, $5, 'assigned', NOW())"#,
            assignment_id,
            task_id,
            task.project_id,
            step_id,
            user_id
        )
        .execute(&mut *tx)
        .await?;
        
        // Update task version (optimistic lock)
        sqlx::query!(
            "UPDATE tasks SET version = version + 1, updated_at = NOW() WHERE task_id = $1",
            task_id
        )
        .execute(&mut *tx)
        .await?;
        
        tx.commit().await?;
        
        // Fetch and return the created assignment
        let assignment = self.assignment_repo.find_by_id(&assignment_id.into()).await?
            .ok_or_else(|| ApiError::internal("Failed to fetch created assignment"))?;
        Ok(assignment)
    }
}

// Helper to get step config from workflow
async fn get_step_config(pool: &PgPool, project_id: Uuid, step_id: &str) -> Result<Option<WorkflowStep>, sqlx::Error> {
    let row = sqlx::query!(
        r#"SELECT w.steps FROM workflows w
           JOIN projects p ON p.workflow_id = w.workflow_id
           WHERE p.project_id = $1"#,
        project_id
    )
    .fetch_optional(pool)
    .await?;
    
    if let Some(row) = row {
        if let Some(steps) = row.steps {
            let steps: Vec<WorkflowStep> = serde_json::from_value(steps).unwrap_or_default();
            return Ok(steps.into_iter().find(|s| s.step_id == step_id));
        }
    }
    Ok(None)
}
```

**2. Add claim endpoint to queue.rs:**
```rust
#[derive(Debug, Deserialize)]
pub struct ClaimRequest {
    pub task_id: Uuid,
    pub step_id: String,
}

/// POST /api/v1/queue/claim - Claim a task from pool
async fn claim_from_pool(
    State(state): State<AppState>,
    auth: AuthUser,
    Json(req): Json<ClaimRequest>,
) -> Result<Json<AcceptResponse>, ApiError> {
    let assignment = state.assignment_service
        .claim_task(auth.user_id.into(), req.task_id, req.step_id)
        .await?;
    
    Ok(Json(AcceptResponse {
        assignment_id: assignment.assignment_id.into(),
        task_id: req.task_id,
        redirect_url: format!("/annotate/{}", req.task_id),
    }))
}
```

**3. Update routes:**
Add to router:
- `.route("/queue/{assignment_id}/accept", post(accept_task))`
- `.route("/queue/{assignment_id}/reject", post(reject_task))`
- `.route("/queue/claim", post(claim_from_pool))`

**4. Create `apps/api/src/services/mod.rs`:**
```rust
pub mod assignment_service;
pub use assignment_service::*;
```
  </action>
  <verify>
    cargo check -p glyph-api
  </verify>
  <done>
    Priority scoring calculates correct values; claim endpoint handles races
  </done>
</task>

</tasks>

<verification>
```bash
cargo build -p glyph-api
```
- Accept updates assignment to 'accepted' status
- Reject records reason and sets cooldown
- Priority score calculation is deterministic
- Claim uses optimistic locking
</verification>

<success_criteria>
- Accept transitions assignment correctly
- Reject sets cooldown period
- Priority scoring factors in deadline, project, and age
- Pool claiming prevents race conditions
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management/07-04-SUMMARY.md`
</output>
