---
phase: 07-task-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/db/src/repo/pg_task.rs
  - libs/db/src/repo/mod.rs
  - apps/api/src/routes/tasks.rs
  - apps/api/src/routes/mod.rs
autonomous: true

must_haves:
  truths:
    - "Tasks can be created with input data and priority"
    - "Tasks can be retrieved by ID"
    - "Tasks can be listed by project with pagination"
    - "Task status and priority can be updated"
    - "Tasks can be soft-deleted"
  artifacts:
    - path: "libs/db/src/repo/pg_task.rs"
      provides: "PostgreSQL task repository implementation"
      exports: ["PgTaskRepository"]
    - path: "apps/api/src/routes/tasks.rs"
      provides: "Task CRUD API endpoints"
      contains: "async fn create_task"
  key_links:
    - from: "apps/api/src/routes/tasks.rs"
      to: "libs/db/src/repo/pg_task.rs"
      via: "repository injection"
      pattern: "TaskRepository"
---

<objective>
Implement Task CRUD repository and API endpoints

Purpose: Enable task creation, retrieval, update, and deletion - the foundation for all task management operations.

Output: Working Task CRUD API at `/api/v1/tasks` and `/api/v1/projects/{project_id}/tasks`
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-task-management/07-CONTEXT.md
@.planning/phases/07-task-management/07-RESEARCH.md
@libs/db/src/repo/traits.rs
@libs/db/src/repo/pg_stubs.rs
@libs/db/src/repo/pg_project.rs
@libs/domain/src/task.rs
@libs/domain/src/enums.rs
@migrations/0004_create_tasks.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PgTaskRepository</name>
  <files>
    libs/db/src/repo/pg_task.rs
    libs/db/src/repo/mod.rs
  </files>
  <action>
Create `libs/db/src/repo/pg_task.rs` implementing `TaskRepository` trait from `traits.rs`. Follow the pattern in `pg_project.rs`.

**Methods to implement:**

1. **find_by_id**: 
   - Use subquery to get project_id first (needed for partitioned table)
   - Query: `SELECT task_id, project_id, status::text, priority, input_data, workflow_state, metadata, created_at, updated_at, completed_at FROM tasks WHERE task_id = $1`
   - Parse status from text to TaskStatus enum
   - Map to Task domain model

2. **create**: 
   - INSERT with project_id, input_data, priority (default 0), metadata (default {})
   - Use `RETURNING *` to get created task
   - Initialize workflow_state as empty `{}`

3. **update**: 
   - Build dynamic UPDATE query for optional fields (status, priority, metadata)
   - Always set `updated_at = NOW()`
   - If status changes to Completed, set `completed_at = NOW()`
   - Use `sqlx::QueryBuilder` for dynamic query construction

4. **list_by_project**: 
   - SELECT with WHERE project_id = $1 AND status != 'deleted'
   - Order by priority DESC, created_at DESC
   - Apply pagination (limit, offset)
   - Return Page<Task> with total count

5. **soft_delete**: 
   - UPDATE tasks SET status = 'deleted', updated_at = NOW() WHERE task_id = $1

**Important patterns (from pg_project.rs):**
- Use `sqlx::query_as!` macro with inline struct for compile-time checking
- Cast enums: `status::text as "status: _"` 
- Use `#[derive(sqlx::FromRow)]` for intermediate row types
- Handle Option fields carefully
- Map `workflow_state` JSONB to `WorkflowState` via serde

Update `libs/db/src/repo/mod.rs`:
- Add `pub mod pg_task;`
- Add `pub use pg_task::*;`
- Remove `PgTaskRepository` from pg_stubs.rs (it's now real)
  </action>
  <verify>
    cargo check -p glyph-db
  </verify>
  <done>
    PgTaskRepository compiles and implements all TaskRepository trait methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Task API Routes</name>
  <files>
    apps/api/src/routes/tasks.rs
    apps/api/src/routes/mod.rs
  </files>
  <action>
Replace placeholder implementation in `apps/api/src/routes/tasks.rs`:

**Request/Response structs:**
```rust
#[derive(Debug, Deserialize)]
pub struct CreateTaskRequest {
    pub input_data: serde_json::Value,
    pub priority: Option<i32>,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateTaskRequest {
    pub status: Option<TaskStatus>,
    pub priority: Option<i32>,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
pub struct ListTasksQuery {
    pub page: Option<i32>,
    pub per_page: Option<i32>,
    pub status: Option<TaskStatus>,
}
```

**Endpoints:**

1. `POST /api/v1/projects/{project_id}/tasks` - Create task
   - Validate project_id exists (optional for MVP)
   - Create via repository
   - Return 201 with Task

2. `GET /api/v1/projects/{project_id}/tasks` - List tasks  
   - Parse query params for pagination and status filter
   - Default page=1, per_page=20
   - Return paginated response

3. `GET /api/v1/tasks/{task_id}` - Get single task
   - Return Task or 404

4. `PATCH /api/v1/tasks/{task_id}` - Update task
   - Apply partial updates
   - Return updated Task

5. `DELETE /api/v1/tasks/{task_id}` - Soft delete
   - Return 204 No Content

**Router setup:**
- Keep existing `/tasks` routes for global task access
- Add project-scoped routes via nested router in mod.rs:
  `.nest("/projects/{project_id}/tasks", tasks::project_routes())`

Follow existing patterns in projects.rs for error handling and response formatting.
  </action>
  <verify>
    cargo check -p glyph-api
  </verify>
  <done>
    Task API endpoints compile and are registered in router
  </done>
</task>

</tasks>

<verification>
```bash
cargo build -p glyph-api
cargo test -p glyph-db --lib
```
- Task routes registered in `api_v1_routes()`
- PgTaskRepository is used (not stub)
</verification>

<success_criteria>
- Tasks can be created via POST /projects/{id}/tasks
- Tasks can be retrieved by ID
- Task listing returns paginated results
- Task updates work for status/priority/metadata
- Soft delete sets status to 'deleted'
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management/07-01-SUMMARY.md`
</output>
