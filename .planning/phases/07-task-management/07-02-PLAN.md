---
phase: 07-task-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - libs/db/src/repo/pg_assignment.rs
  - libs/db/src/repo/mod.rs
  - libs/db/src/repo/traits.rs
  - libs/workflow-engine/src/assignment.rs
  - libs/domain/src/enums.rs
  - migrations/0017_assignment_extensions.sql
autonomous: true

must_haves:
  truths:
    - "Assignments can be created for user/task/step combinations"
    - "Duplicate assignments (same user, task, step) are prevented"
    - "Assignment status can be tracked through lifecycle"
    - "User's current assignments can be listed"
    - "Cross-step exclusion prevents same user on conflicting steps"
  artifacts:
    - path: "libs/db/src/repo/pg_assignment.rs"
      provides: "PostgreSQL assignment repository"
      exports: ["PgAssignmentRepository"]
    - path: "libs/workflow-engine/src/assignment.rs"
      provides: "Assignment engine implementation"
      contains: "impl AssignmentService"
  key_links:
    - from: "libs/workflow-engine/src/assignment.rs"
      to: "libs/db/src/repo/pg_assignment.rs"
      via: "repository injection"
      pattern: "AssignmentRepository"
---

<objective>
Implement Assignment Repository and Assignment Engine

Purpose: Enable skill-based, load-balanced task assignment with duplicate prevention and cross-step exclusion.

Output: AssignmentRepository for persistence and AssignmentEngine implementing the AssignmentService trait.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-task-management/07-CONTEXT.md
@.planning/phases/07-task-management/07-RESEARCH.md
@libs/workflow-engine/src/assignment.rs
@libs/db/src/repo/traits.rs
@libs/domain/src/task.rs
@libs/domain/src/enums.rs
@migrations/0004_create_tasks.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Assignment Repository Trait and Implementation</name>
  <files>
    libs/db/src/repo/traits.rs
    libs/db/src/repo/pg_assignment.rs
    libs/db/src/repo/mod.rs
    libs/db/src/repo/errors.rs
    migrations/0017_assignment_extensions.sql
  </files>
  <action>
**1. Add migration `migrations/0017_assignment_extensions.sql`:**
```sql
-- Add columns for reject flow and cooldown
ALTER TABLE task_assignments ADD COLUMN IF NOT EXISTS reject_reason JSONB;
ALTER TABLE task_assignments ADD COLUMN IF NOT EXISTS rejected_at TIMESTAMPTZ;

-- Add cooldown tracking to tasks
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS cooldown_until TIMESTAMPTZ;
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS version BIGINT NOT NULL DEFAULT 1;

-- User presence tracking (for queue UI)
CREATE TABLE IF NOT EXISTS user_presence (
    user_id UUID NOT NULL REFERENCES users(user_id),
    project_id UUID NOT NULL REFERENCES projects(project_id),
    last_seen_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (user_id, project_id)
);

-- Index for efficient presence queries
CREATE INDEX IF NOT EXISTS idx_user_presence_project ON user_presence(project_id, last_seen_at DESC);
```

**2. Add to `libs/db/src/repo/traits.rs`:**
```rust
/// Input for creating a new assignment
#[derive(Debug, Clone)]
pub struct NewAssignment {
    pub task_id: TaskId,
    pub project_id: ProjectId,
    pub step_id: String,
    pub user_id: UserId,
}

/// Input for rejecting an assignment
#[derive(Debug, Clone)]
pub struct RejectAssignment {
    pub assignment_id: AssignmentId,
    pub reason: serde_json::Value,
}

#[async_trait]
pub trait AssignmentRepository: Send + Sync {
    async fn find_by_id(&self, id: &AssignmentId) -> Result<Option<TaskAssignment>, FindAssignmentError>;
    async fn create(&self, assignment: &NewAssignment) -> Result<TaskAssignment, CreateAssignmentError>;
    async fn update_status(&self, id: &AssignmentId, status: AssignmentStatus) -> Result<TaskAssignment, UpdateAssignmentError>;
    async fn list_by_user(&self, user_id: &UserId, status: Option<AssignmentStatus>) -> Result<Vec<TaskAssignment>, sqlx::Error>;
    async fn list_by_task(&self, task_id: &TaskId) -> Result<Vec<TaskAssignment>, sqlx::Error>;
    async fn reject(&self, reject: &RejectAssignment) -> Result<(), UpdateAssignmentError>;
    async fn has_user_worked_on_task(&self, user_id: &UserId, task_id: &TaskId, exclude_steps: &[String]) -> Result<bool, sqlx::Error>;
    async fn count_active_by_user(&self, user_id: &UserId) -> Result<i64, sqlx::Error>;
}
```

**3. Create `libs/db/src/repo/pg_assignment.rs`:**
- Implement AssignmentRepository
- Use `SELECT ... FOR UPDATE SKIP LOCKED` for atomic assignment creation (race prevention)
- Check unique constraint `unique_user_task_step` to prevent duplicates
- `has_user_worked_on_task`: Query for any completed assignments on same task (for cross-step exclusion)

**4. Add error types to `errors.rs`:**
- FindAssignmentError, CreateAssignmentError, UpdateAssignmentError

**5. Update `mod.rs`:** Add pg_assignment module and exports
  </action>
  <verify>
    cargo check -p glyph-db
  </verify>
  <done>
    AssignmentRepository trait and PgAssignmentRepository implementation compile
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Assignment Engine</name>
  <files>
    libs/workflow-engine/src/assignment.rs
    libs/domain/src/enums.rs
  </files>
  <action>
Implement the `AssignmentService` trait in `libs/workflow-engine/src/assignment.rs`:

**1. Add load balancing strategies and Rejected status to enums.rs:**
```rust
// Add Rejected to AssignmentStatus enum
#[typeshare]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, sqlx::Type)]
#[serde(rename_all = "snake_case")]
#[sqlx(type_name = "assignment_status", rename_all = "snake_case")]
pub enum AssignmentStatus {
    Assigned,
    Accepted,
    InProgress,
    Submitted,
    Expired,
    Reassigned,
    Rejected,  // ADD THIS for reject flow
}

#[typeshare]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum LoadBalancingStrategy {
    RoundRobin,
    CapacityBased,       // Renamed from LeastLoaded
    PerformanceWeighted, // Renamed from QualityWeighted  
    HybridCapacityPerformance,
}
```

**2. Create AssignmentEngine struct:**
```rust
pub struct AssignmentEngine<R: AssignmentRepository, U: UserRepository> {
    assignment_repo: Arc<R>,
    user_repo: Arc<U>,
    // Optional skill repo for skill-based matching
}
```

**3. Implement find_best_assignee:**
- Get eligible users based on:
  - User status = Active
  - Has required skills (if step has required_skills)
  - Not already assigned to this task/step (duplicate prevention)
  - Has not worked on this task in excluded steps (cross-step exclusion)
  - Under assignment limit (if configured)
- Apply load balancing strategy:
  - RoundRobin: Track last assigned user per step, rotate
  - CapacityBased: User with fewest active assignments
  - PerformanceWeighted: Factor in quality scores (from quality_scores table)
  - Hybrid: Weighted combination of capacity + performance

**4. Implement assign_task:**
- Create assignment via repository
- Handle unique constraint violation gracefully (return existing or error)

**5. Implement release_assignment:**
- Update status to Expired or Reassigned
- Set task cooldown if configured

**6. Add configuration struct:**
```rust
pub struct AssignmentConfig {
    pub max_concurrent_per_user: Option<i32>,
    pub cross_step_exclusion_pairs: Vec<(String, String)>,
    pub cooldown_minutes: u32,
}
```
  </action>
  <verify>
    cargo check -p workflow-engine
  </verify>
  <done>
    AssignmentEngine implements AssignmentService with all strategies
  </done>
</task>

</tasks>

<verification>
```bash
cargo build -p workflow-engine
cargo build -p glyph-db
```
- Migration file exists at migrations/0017_assignment_extensions.sql
- AssignmentEngine can be instantiated with repositories
</verification>

<success_criteria>
- Assignment repository prevents duplicate assignments
- Cross-step exclusion queries work correctly
- Load balancing strategies select appropriate users
- Assignment limits are respected
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management/07-02-SUMMARY.md`
</output>
