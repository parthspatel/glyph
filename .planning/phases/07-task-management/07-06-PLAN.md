---
phase: 07-task-management
plan: 06
type: execute
wave: 5
depends_on: ["07-05"]
files_modified:
  - apps/web/src/pages/TaskDetailPage.tsx
  - apps/web/src/hooks/useWebSocket.ts
  - apps/web/src/hooks/useQueue.ts
  - apps/web/src/stores/queueStore.ts
  - apps/web/src/components/queue/QueueTable.tsx
  - apps/web/src/components/queue/PresenceIndicator.tsx
  - apps/web/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Task detail page shows task input data and assignment info"
    - "WebSocket connects and receives real-time updates"
    - "Queue table updates when new tasks are assigned"
    - "Presence indicators show who is active on same project"
    - "Toast notification appears when task becomes unavailable"
  artifacts:
    - path: "apps/web/src/pages/TaskDetailPage.tsx"
      provides: "Task detail view"
      min_lines: 30
    - path: "apps/web/src/hooks/useWebSocket.ts"
      provides: "WebSocket connection hook"
      exports: ["useQueueWebSocket"]
  key_links:
    - from: "apps/web/src/hooks/useWebSocket.ts"
      to: "apps/web/src/stores/queueStore.ts"
      via: "zustand store"
      pattern: "queueStore"
---

<objective>
Implement Task Detail Page and Real-time WebSocket Integration

Purpose: Complete the task management UI with task details and live queue updates.

Output: TaskDetailPage and WebSocket integration for real-time updates.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-task-management/07-CONTEXT.md
@.planning/phases/07-task-management/07-RESEARCH.md
@.planning/phases/07-task-management/07-05-SUMMARY.md
@apps/web/src/pages/QueuePage.tsx
@apps/web/src/hooks/useQueue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WebSocket Integration</name>
  <files>
    apps/web/src/hooks/useWebSocket.ts
    apps/web/src/stores/queueStore.ts
    apps/web/src/hooks/useQueue.ts
    apps/web/src/hooks/index.ts
  </files>
  <action>
**1. Create `apps/web/src/stores/queueStore.ts`:**
```typescript
import { create } from 'zustand';

interface QueueState {
  wsConnected: boolean;
  lastEvent: QueueEvent | null;
  presenceByProject: Record<string, UserPresence[]>;
  setConnected: (connected: boolean) => void;
  setLastEvent: (event: QueueEvent) => void;
  updatePresence: (projectId: string, users: UserPresence[]) => void;
}

interface QueueEvent {
  type: string;
  [key: string]: unknown;
}

interface UserPresence {
  user_id: string;
  display_name: string;
  avatar_url?: string;
  last_seen_at: string;
}

export const useQueueStore = create<QueueState>((set) => ({
  wsConnected: false,
  lastEvent: null,
  presenceByProject: {},
  setConnected: (connected) => set({ wsConnected: connected }),
  setLastEvent: (event) => set({ lastEvent: event }),
  updatePresence: (projectId, users) => 
    set((state) => ({ 
      presenceByProject: { ...state.presenceByProject, [projectId]: users } 
    })),
}));
```

**2. Create `apps/web/src/hooks/useWebSocket.ts`:**
```typescript
import { useEffect, useRef, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { useQueueStore } from '../stores/queueStore';

const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/v1/queue/ws`;
const RECONNECT_DELAY = 3000;
const MAX_RECONNECT_ATTEMPTS = 5;

export function useQueueWebSocket() {
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectAttempts = useRef(0);
  const queryClient = useQueryClient();
  const { setConnected, setLastEvent } = useQueueStore();

  const connect = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) return;

    const ws = new WebSocket(WS_URL);

    ws.onopen = () => {
      console.log('Queue WebSocket connected');
      setConnected(true);
      reconnectAttempts.current = 0;
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        setLastEvent(data);
        handleQueueEvent(data, queryClient);
      } catch (e) {
        console.error('Failed to parse WS message:', e);
      }
    };

    ws.onclose = () => {
      setConnected(false);
      if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {
        reconnectAttempts.current++;
        setTimeout(connect, RECONNECT_DELAY * reconnectAttempts.current);
      }
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    wsRef.current = ws;
  }, [setConnected, setLastEvent, queryClient]);

  useEffect(() => {
    connect();
    return () => {
      wsRef.current?.close();
    };
  }, [connect]);

  return { connected: useQueueStore((s) => s.wsConnected) };
}

function handleQueueEvent(event: any, queryClient: ReturnType<typeof useQueryClient>) {
  switch (event.type) {
    case 'task_assigned':
      queryClient.invalidateQueries({ queryKey: ['queue'] });
      toast.info('New task assigned to you');
      break;
    case 'task_unavailable':
      queryClient.invalidateQueries({ queryKey: ['queue'] });
      toast.warning(`Task no longer available: ${event.reason}`);
      break;
    case 'task_status_changed':
      queryClient.invalidateQueries({ queryKey: ['queue'] });
      break;
    case 'presence_update':
      // Handled by store
      break;
  }
}
```

**3. Update `apps/web/src/hooks/useQueue.ts`:**
Add hook to listen for queue updates:
```typescript
export function useQueueWithRealtime(filters?: QueueFilters, sort?: QueueSort) {
  useQueueWebSocket(); // Establish connection
  return useQueue(filters, sort);
}
```

**4. Add presence tracking heartbeat:**
```typescript
// In useQueueWebSocket, add presence heartbeat effect:
export function useQueueWebSocket(currentProjectId?: string) {
  // ... existing wsRef and connect logic ...

  // Presence heartbeat - update server every 30s while connected
  useEffect(() => {
    if (!wsConnected || !currentProjectId || !wsRef.current) return;
    
    const sendHeartbeat = () => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ 
          type: 'presence_heartbeat', 
          project_id: currentProjectId 
        }));
      }
    };
    
    // Send immediately on connect, then every 30s
    sendHeartbeat();
    const interval = setInterval(sendHeartbeat, 30000);
    
    return () => clearInterval(interval);
  }, [wsConnected, currentProjectId]);

  return { connected: useQueueStore((s) => s.wsConnected) };
}
```

**5. Handle presence_update events:**
```typescript
// In handleQueueEvent function:
case 'presence_update':
  useQueueStore.getState().updatePresence(
    event.project_id as string,
    event.users as UserPresence[]
  );
  break;
```

**6. Export from hooks/index.ts**
  </action>
  <verify>
    cd apps/web && pnpm build
  </verify>
  <done>
    WebSocket connects and triggers React Query invalidation on events
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Task Detail Page and Presence Indicator</name>
  <files>
    apps/web/src/pages/TaskDetailPage.tsx
    apps/web/src/components/queue/PresenceIndicator.tsx
    apps/web/src/components/queue/QueueTable.tsx
    apps/web/src/pages/QueuePage.tsx
    apps/web/src/App.tsx
  </files>
  <action>
**1. Create `apps/web/src/pages/TaskDetailPage.tsx`:**
```tsx
import { useParams, Link } from 'react-router-dom';
import { useQuery } from '@tanstack/react-query';
import { api } from '@/api/client';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { ArrowLeft, Clock, User, FileText } from 'lucide-react';

interface TaskDetail {
  task_id: string;
  project_id: string;
  project_name: string;
  status: string;
  priority: number;
  input_data: unknown;
  workflow_state: {
    current_step_id: string | null;
    step_states: Array<{ step_id: string; status: string }>;
  };
  created_at: string;
  assignment?: {
    assignment_id: string;
    status: string;
    assigned_at: string;
    step_id: string;
  };
}

export function TaskDetailPage() {
  const { taskId } = useParams<{ taskId: string }>();
  
  const { data: task, isLoading, error } = useQuery({
    queryKey: ['task', taskId],
    queryFn: () => api.get<TaskDetail>(`/tasks/${taskId}`),
  });

  if (isLoading) return <div className="p-8">Loading...</div>;
  if (error || !task) return <div className="p-8">Task not found</div>;

  return (
    <div className="container py-8 space-y-6">
      <div className="flex items-center gap-4">
        <Link to="/queue">
          <Button variant="ghost" size="icon"><ArrowLeft /></Button>
        </Link>
        <h1 className="text-2xl font-bold">Task Details</h1>
        <Badge variant={task.status === 'in_progress' ? 'default' : 'secondary'}>
          {task.status}
        </Badge>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader><CardTitle>Task Info</CardTitle></CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center gap-2">
              <FileText className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm">ID: {task.task_id}</span>
            </div>
            <div className="flex items-center gap-2">
              <Clock className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm">Created: {new Date(task.created_at).toLocaleString()}</span>
            </div>
            <div>Priority: <Badge variant="outline">{task.priority}</Badge></div>
          </CardContent>
        </Card>

        {task.assignment && (
          <Card>
            <CardHeader><CardTitle>Your Assignment</CardTitle></CardHeader>
            <CardContent className="space-y-4">
              <div>Step: <Badge>{task.assignment.step_id}</Badge></div>
              <div>Status: {task.assignment.status}</div>
              <div>Assigned: {new Date(task.assignment.assigned_at).toLocaleString()}</div>
              {task.assignment.status === 'accepted' && (
                <Link to={`/annotate/${task.task_id}`}>
                  <Button>Start Annotation</Button>
                </Link>
              )}
            </CardContent>
          </Card>
        )}
      </div>

      <Card>
        <CardHeader><CardTitle>Input Data</CardTitle></CardHeader>
        <CardContent>
          <pre className="bg-muted p-4 rounded-md overflow-auto text-sm">
            {JSON.stringify(task.input_data, null, 2)}
          </pre>
        </CardContent>
      </Card>
    </div>
  );
}
```

**2. Create `apps/web/src/components/queue/PresenceIndicator.tsx`:**
```tsx
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { useQueueStore } from '@/stores/queueStore';

interface PresenceIndicatorProps {
  projectId: string;
}

export function PresenceIndicator({ projectId }: PresenceIndicatorProps) {
  const presence = useQueueStore((s) => s.presenceByProject[projectId] ?? []);
  
  if (presence.length === 0) return null;

  return (
    <div className="flex -space-x-2">
      {presence.slice(0, 5).map((user) => (
        <Tooltip key={user.user_id}>
          <TooltipTrigger>
            <Avatar className="h-6 w-6 border-2 border-background">
              <AvatarImage src={user.avatar_url} />
              <AvatarFallback>{user.display_name[0]}</AvatarFallback>
            </Avatar>
          </TooltipTrigger>
          <TooltipContent>{user.display_name}</TooltipContent>
        </Tooltip>
      ))}
      {presence.length > 5 && (
        <div className="h-6 w-6 rounded-full bg-muted flex items-center justify-center text-xs">
          +{presence.length - 5}
        </div>
      )}
    </div>
  );
}
```

**3. Update QueuePage to use real-time hook:**
Replace `useQueue` with `useQueueWithRealtime`

**4. Add presence indicator to QueueTable:**
Show presence avatars per project in the table

**5. Update App.tsx routes:**
Add: `<Route path="/tasks/:taskId" element={<TaskDetailPage />} />`
  </action>
  <verify>
    cd apps/web && pnpm build && pnpm lint
  </verify>
  <done>
    TaskDetailPage shows task info; WebSocket updates queue in real-time
  </done>
</task>

</tasks>

<verification>
```bash
cd apps/web && pnpm build
```
- TaskDetailPage route at /tasks/:taskId works
- WebSocket connects on QueuePage load
- Toast appears when task becomes unavailable
- Presence avatars show for active users
</verification>

<success_criteria>
- Task detail displays input data and assignment info
- WebSocket establishes connection
- Queue updates automatically on WS events
- Presence indicators render correctly
- Navigation between queue and task detail works
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management/07-06-SUMMARY.md`
</output>
