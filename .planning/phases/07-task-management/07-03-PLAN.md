---
phase: 07-task-management
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - apps/api/src/routes/queue.rs
  - apps/api/src/routes/mod.rs
  - apps/api/src/ws/mod.rs
  - apps/api/src/ws/hub.rs
  - apps/api/src/ws/events.rs
  - apps/api/src/main.rs
autonomous: true

must_haves:
  truths:
    - "Annotators can view their assigned task queue"
    - "Queue can be filtered by project, status, step type"
    - "Queue can be sorted by priority, age, project"
    - "WebSocket connection receives real-time queue updates"
    - "Presence indicators show who is active on same project"
  artifacts:
    - path: "apps/api/src/routes/queue.rs"
      provides: "Queue REST API endpoints"
      exports: ["routes"]
    - path: "apps/api/src/ws/hub.rs"
      provides: "WebSocket broadcast hub"
      exports: ["QueueUpdateHub"]
  key_links:
    - from: "apps/api/src/routes/queue.rs"
      to: "libs/db/src/repo/pg_assignment.rs"
      via: "repository query"
      pattern: "list_by_user"
    - from: "apps/api/src/ws/hub.rs"
      to: "apps/api/src/routes/queue.rs"
      via: "event emission"
      pattern: "broadcast"
---

<objective>
Implement Queue API and WebSocket Hub for real-time updates

Purpose: Enable annotators to view their task queue with real-time updates when assignments change.

Output: REST endpoints for queue operations and WebSocket endpoint for live updates.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-task-management/07-CONTEXT.md
@.planning/phases/07-task-management/07-RESEARCH.md
@.planning/phases/07-task-management/07-01-SUMMARY.md
@.planning/phases/07-task-management/07-02-SUMMARY.md
@apps/api/src/routes/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Queue REST API</name>
  <files>
    apps/api/src/routes/queue.rs
    apps/api/src/routes/mod.rs
  </files>
  <action>
Create `apps/api/src/routes/queue.rs`:

**Data types:**
```rust
#[derive(Debug, Serialize)]
pub struct QueueItem {
    pub assignment_id: Uuid,
    pub task_id: Uuid,
    pub project_id: Uuid,
    pub project_name: String,
    pub step_id: String,
    pub step_type: StepType,
    pub status: AssignmentStatus,
    pub priority: i32,
    pub assigned_at: DateTime<Utc>,
    pub time_in_queue_seconds: i64,
    pub estimated_duration_minutes: Option<i32>,
}

#[derive(Debug, Deserialize)]
pub struct QueueFilters {
    pub project_id: Option<Uuid>,
    pub step_type: Option<StepType>,
    pub status: Option<AssignmentStatus>,
}

#[derive(Debug, Deserialize)]
pub struct QueueSort {
    pub by: Option<String>,  // priority, age, project
    pub order: Option<String>,  // asc, desc
}

#[derive(Debug, Serialize)]
pub struct QueueStats {
    pub total_pending: i64,
    pub total_in_progress: i64,
    pub by_project: HashMap<Uuid, ProjectQueueStats>,
}
```

**Endpoints:**

1. `GET /api/v1/queue` - Get current user's queue
   - Uses auth context to get user_id
   - Query params: QueueFilters, QueueSort, pagination
   - Join tasks + task_assignments + projects for full QueueItem data
   - Default sort: priority DESC, assigned_at ASC

2. `GET /api/v1/queue/stats` - Get queue statistics
   - Aggregate counts by status and project
   - Return QueueStats

3. `GET /api/v1/queue/presence/{project_id}` - Get active users on project
   - Query user_presence table
   - Return list of UserPresence { user_id, display_name, avatar_url, last_seen_at }

**SQL for queue listing (complex join):**
```sql
SELECT 
    ta.assignment_id,
    ta.task_id,
    ta.project_id,
    p.name as project_name,
    ta.step_id,
    (SELECT s->>'step_type' 
     FROM jsonb_array_elements(w.steps) AS s 
     WHERE s->>'step_id' = ta.step_id) as step_type,
    ta.status::text,
    t.priority,
    ta.assigned_at,
    EXTRACT(EPOCH FROM (NOW() - ta.assigned_at))::bigint as time_in_queue_seconds
FROM task_assignments ta
JOIN tasks t ON ta.task_id = t.task_id AND ta.project_id = t.project_id
JOIN projects p ON ta.project_id = p.project_id
LEFT JOIN workflows w ON p.workflow_id = w.workflow_id
WHERE ta.user_id = $1
  AND ta.status IN ('assigned', 'accepted', 'in_progress')
ORDER BY t.priority DESC, ta.assigned_at ASC
LIMIT $2 OFFSET $3
```

Update `routes/mod.rs` to add `.nest("/queue", queue::routes())`
  </action>
  <verify>
    cargo check -p glyph-api
  </verify>
  <done>
    Queue API endpoints compile and are registered
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket Hub</name>
  <files>
    apps/api/src/ws/mod.rs
    apps/api/src/ws/hub.rs
    apps/api/src/ws/events.rs
    apps/api/src/routes/queue.rs
    apps/api/src/main.rs
  </files>
  <action>
Create WebSocket infrastructure:

**1. Create `apps/api/src/ws/events.rs`:**
```rust
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum QueueEvent {
    TaskAssigned {
        task_id: Uuid,
        assignment_id: Uuid,
        project_id: Uuid,
        step_id: String,
        priority: i32,
    },
    TaskReassigned {
        task_id: Uuid,
        old_user_id: Uuid,
        new_user_id: Uuid,
        reason: String,
    },
    TaskStatusChanged {
        task_id: Uuid,
        assignment_id: Uuid,
        old_status: String,
        new_status: String,
    },
    QueueCountChanged {
        total: i64,
        by_project: std::collections::HashMap<Uuid, i64>,
    },
    TaskUnavailable {
        task_id: Uuid,
        reason: String,
    },
    PresenceUpdate {
        project_id: Uuid,
        user_id: Uuid,
        action: String, // "joined" | "left" | "active"
    },
}
```

**2. Create `apps/api/src/ws/hub.rs`:**
```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use uuid::Uuid;

use super::events::QueueEvent;

const CHANNEL_CAPACITY: usize = 256;

pub struct QueueUpdateHub {
    /// Per-user broadcast channels
    user_channels: Arc<RwLock<HashMap<Uuid, broadcast::Sender<QueueEvent>>>>,
    /// Per-project broadcast channels (for presence)
    project_channels: Arc<RwLock<HashMap<Uuid, broadcast::Sender<QueueEvent>>>>,
}

impl QueueUpdateHub {
    pub fn new() -> Self { ... }
    
    pub async fn subscribe_user(&self, user_id: Uuid) -> broadcast::Receiver<QueueEvent> { ... }
    
    pub async fn subscribe_project(&self, project_id: Uuid) -> broadcast::Receiver<QueueEvent> { ... }
    
    pub async fn broadcast_to_user(&self, user_id: Uuid, event: QueueEvent) { ... }
    
    pub async fn broadcast_to_project(&self, project_id: Uuid, event: QueueEvent) { ... }
    
    pub async fn unsubscribe_user(&self, user_id: Uuid) { ... }
}
```

**3. Create `apps/api/src/ws/mod.rs`:**
```rust
pub mod events;
pub mod hub;

pub use events::QueueEvent;
pub use hub::QueueUpdateHub;
```

**4. Add WebSocket endpoint to queue.rs:**
```rust
use axum::extract::ws::{WebSocketUpgrade, WebSocket, Message};

pub async fn queue_websocket(
    ws: WebSocketUpgrade,
    State(hub): State<Arc<QueueUpdateHub>>,
    // Extract user_id from auth cookie/header
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| handle_socket(socket, hub, user_id))
}

async fn handle_socket(mut socket: WebSocket, hub: Arc<QueueUpdateHub>, user_id: Uuid) {
    let mut rx = hub.subscribe_user(user_id).await;
    
    loop {
        tokio::select! {
            // Forward hub events to WebSocket
            Ok(event) = rx.recv() => {
                let msg = serde_json::to_string(&event).unwrap();
                if socket.send(Message::Text(msg)).await.is_err() {
                    break;
                }
            }
            // Handle incoming messages (ping/pong, presence)
            Some(msg) = socket.recv() => {
                match msg {
                    Ok(Message::Ping(data)) => { socket.send(Message::Pong(data)).await.ok(); }
                    Ok(Message::Close(_)) => break,
                    Err(_) => break,
                    _ => {}
                }
            }
        }
    }
    
    hub.unsubscribe_user(user_id).await;
}

// Upsert user presence for active projects on connect
async fn update_user_presence(pool: &PgPool, user_id: Uuid, project_ids: &[Uuid]) -> Result<(), sqlx::Error> {
    for project_id in project_ids {
        sqlx::query!(
            r#"INSERT INTO user_presence (user_id, project_id, last_seen_at)
               VALUES ($1, $2, NOW())
               ON CONFLICT (user_id, project_id) 
               DO UPDATE SET last_seen_at = NOW()"#,
            user_id,
            project_id
        )
        .execute(pool)
        .await?;
    }
    Ok(())
}
```

**5. Update main.rs:**
- Create `QueueUpdateHub` instance
- Add as AppState
- Register WebSocket route: `.route("/api/v1/queue/ws", get(queue::queue_websocket))`
  </action>
  <verify>
    cargo check -p glyph-api
  </verify>
  <done>
    WebSocket hub compiles and endpoint is registered
  </done>
</task>

</tasks>

<verification>
```bash
cargo build -p glyph-api
```
- GET /api/v1/queue returns structured queue items
- WebSocket endpoint accepts connections at /api/v1/queue/ws
</verification>

<success_criteria>
- Queue API returns user's assigned tasks with all required fields
- Queue can be filtered and sorted
- WebSocket connection can be established
- Hub broadcasts events to subscribed users
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management/07-03-SUMMARY.md`
</output>
