---
phase: 07-task-management
plan: 05
type: execute
wave: 4
depends_on: ["07-03", "07-04"]
files_modified:
  - apps/web/src/api/queue.ts
  - apps/web/src/hooks/useQueue.ts
  - apps/web/src/pages/QueuePage.tsx
  - apps/web/src/components/queue/QueueTable.tsx
  - apps/web/src/components/queue/QueueFilters.tsx
  - apps/web/src/components/queue/index.ts
  - apps/web/src/App.tsx
  - apps/web/package.json
autonomous: true

must_haves:
  truths:
    - "Annotators see their task queue in a table"
    - "Queue can be filtered by project, status, step type"
    - "Queue can be sorted by priority, age, project"
    - "Accept/reject buttons work on each queue item"
    - "Rejected items show reason selection"
  artifacts:
    - path: "apps/web/src/pages/QueuePage.tsx"
      provides: "Queue page component"
      min_lines: 50
    - path: "apps/web/src/components/queue/QueueTable.tsx"
      provides: "Queue table with actions"
      contains: "Accept"
  key_links:
    - from: "apps/web/src/pages/QueuePage.tsx"
      to: "apps/web/src/api/queue.ts"
      via: "React Query hook"
      pattern: "useQueue"
---

<objective>
Implement Frontend Queue View

Purpose: Provide annotators with a responsive task queue interface with filtering, sorting, and accept/reject actions.

Output: QueuePage with QueueTable, filters, and action buttons.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-task-management/07-CONTEXT.md
@.planning/phases/07-task-management/07-RESEARCH.md
@.planning/phases/07-task-management/07-03-SUMMARY.md
@.planning/phases/07-task-management/07-04-SUMMARY.md
@apps/web/src/api/client.ts
@apps/web/src/components/project/ProjectTable.tsx
@apps/web/src/pages/ProjectsPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Queue API Client and Hook</name>
  <files>
    apps/web/src/api/queue.ts
    apps/web/src/api/index.ts
    apps/web/src/hooks/useQueue.ts
    apps/web/src/hooks/index.ts
    apps/web/package.json
  </files>
  <action>
**1. Add @tanstack/react-virtual to package.json:**
```bash
cd apps/web && pnpm add @tanstack/react-virtual
```

**2. Create `apps/web/src/api/queue.ts`:**
```typescript
import { api } from './client';

// Types (should match TypeScript generated types from typeshare)
export interface QueueItem {
  assignment_id: string;
  task_id: string;
  project_id: string;
  project_name: string;
  step_id: string;
  step_type: 'annotation' | 'review' | 'adjudication';
  status: 'assigned' | 'accepted' | 'in_progress';
  priority: number;
  assigned_at: string;
  time_in_queue_seconds: number;
  estimated_duration_minutes?: number;
}

export interface QueueStats {
  total_pending: number;
  total_in_progress: number;
  by_project: Record<string, { pending: number; in_progress: number }>;
}

export interface QueueFilters {
  project_id?: string;
  step_type?: string;
  status?: string;
}

export interface QueueSort {
  by?: 'priority' | 'age' | 'project';
  order?: 'asc' | 'desc';
}

export type RejectReason = 
  | { type: 'conflict_of_interest' }
  | { type: 'unclear_instructions' }
  | { type: 'missing_context' }
  | { type: 'outside_expertise' }
  | { type: 'schedule_conflict' }
  | { type: 'technical_issues' }
  | { type: 'other'; details: string };

export interface AcceptResponse {
  assignment_id: string;
  task_id: string;
  redirect_url: string;
}

// API functions
export const queueApi = {
  getQueue: (filters?: QueueFilters, sort?: QueueSort, page = 1, perPage = 20) =>
    api.get<{ items: QueueItem[]; total: number; page: number; per_page: number }>(
      '/queue',
      { params: { ...filters, ...sort, page, per_page: perPage } }
    ),

  getStats: () => api.get<QueueStats>('/queue/stats'),

  acceptTask: (assignmentId: string) =>
    api.post<AcceptResponse>(`/queue/${assignmentId}/accept`),

  rejectTask: (assignmentId: string, reason: RejectReason) =>
    api.post(`/queue/${assignmentId}/reject`, { reason }),
};
```

**3. Create `apps/web/src/hooks/useQueue.ts`:**
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import { queueApi, QueueFilters, QueueSort, RejectReason } from '../api/queue';
import { toast } from 'sonner';

export function useQueue(filters?: QueueFilters, sort?: QueueSort) {
  return useQuery({
    queryKey: ['queue', filters, sort],
    queryFn: () => queueApi.getQueue(filters, sort),
    refetchInterval: 30000, // Refetch every 30s as backup to WebSocket
  });
}

export function useQueueStats() {
  return useQuery({
    queryKey: ['queue', 'stats'],
    queryFn: queueApi.getStats,
    refetchInterval: 60000,
  });
}

export function useAcceptTask() {
  const queryClient = useQueryClient();
  const navigate = useNavigate();

  return useMutation({
    mutationFn: (assignmentId: string) => queueApi.acceptTask(assignmentId),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['queue'] });
      toast.success('Task accepted');
      navigate(data.redirect_url);
    },
    onError: (error: Error) => {
      toast.error(`Failed to accept: ${error.message}`);
    },
  });
}

export function useRejectTask() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ assignmentId, reason }: { assignmentId: string; reason: RejectReason }) =>
      queueApi.rejectTask(assignmentId, reason),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['queue'] });
      toast.success('Task rejected');
    },
    onError: (error: Error) => {
      toast.error(`Failed to reject: ${error.message}`);
    },
  });
}
```

**4. Update `apps/web/src/api/index.ts`:** Add `export * from './queue';`

**5. Update `apps/web/src/hooks/index.ts`:** Add `export * from './useQueue';`
  </action>
  <verify>
    cd apps/web && pnpm build
  </verify>
  <done>
    Queue API client and React Query hooks compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Queue UI Components</name>
  <files>
    apps/web/src/pages/QueuePage.tsx
    apps/web/src/components/queue/QueueTable.tsx
    apps/web/src/components/queue/QueueFilters.tsx
    apps/web/src/components/queue/RejectDialog.tsx
    apps/web/src/components/queue/index.ts
    apps/web/src/App.tsx
  </files>
  <action>
**1. Create `apps/web/src/components/queue/QueueFilters.tsx`:**
```tsx
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { QueueFilters as FilterType, QueueSort } from '@/api/queue';

interface QueueFiltersProps {
  filters: FilterType;
  sort: QueueSort;
  onFiltersChange: (filters: FilterType) => void;
  onSortChange: (sort: QueueSort) => void;
  projects: { id: string; name: string }[];
}

export function QueueFilters({ filters, sort, onFiltersChange, onSortChange, projects }: QueueFiltersProps) {
  return (
    <div className="flex gap-4 flex-wrap">
      <Select value={filters.project_id ?? 'all'} onValueChange={(v) => onFiltersChange({ ...filters, project_id: v === 'all' ? undefined : v })}>
        <SelectTrigger className="w-[180px]"><SelectValue placeholder="All Projects" /></SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All Projects</SelectItem>
          {projects.map((p) => <SelectItem key={p.id} value={p.id}>{p.name}</SelectItem>)}
        </SelectContent>
      </Select>
      
      <Select value={filters.step_type ?? 'all'} onValueChange={(v) => onFiltersChange({ ...filters, step_type: v === 'all' ? undefined : v })}>
        <SelectTrigger className="w-[150px]"><SelectValue placeholder="All Types" /></SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All Types</SelectItem>
          <SelectItem value="annotation">Annotation</SelectItem>
          <SelectItem value="review">Review</SelectItem>
          <SelectItem value="adjudication">Adjudication</SelectItem>
        </SelectContent>
      </Select>
      
      <Select value={sort.by ?? 'priority'} onValueChange={(v) => onSortChange({ ...sort, by: v as any })}>
        <SelectTrigger className="w-[150px]"><SelectValue placeholder="Sort by" /></SelectTrigger>
        <SelectContent>
          <SelectItem value="priority">Priority</SelectItem>
          <SelectItem value="age">Age</SelectItem>
          <SelectItem value="project">Project</SelectItem>
        </SelectContent>
      </Select>
    </div>
  );
}
```

**2. Create `apps/web/src/components/queue/RejectDialog.tsx`:**
```tsx
import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { RejectReason } from '@/api/queue';

const REJECT_OPTIONS = [
  { value: 'conflict_of_interest', label: 'Conflict of Interest' },
  { value: 'unclear_instructions', label: 'Unclear Instructions' },
  { value: 'missing_context', label: 'Missing Context' },
  { value: 'outside_expertise', label: 'Outside My Expertise' },
  { value: 'schedule_conflict', label: 'Schedule Conflict' },
  { value: 'technical_issues', label: 'Technical Issues' },
  { value: 'other', label: 'Other' },
];

interface RejectDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (reason: RejectReason) => void;
  isLoading: boolean;
}

export function RejectDialog({ open, onClose, onConfirm, isLoading }: RejectDialogProps) {
  const [selected, setSelected] = useState<string>('');
  const [otherDetails, setOtherDetails] = useState('');

  const handleConfirm = () => {
    if (!selected) return;
    const reason: RejectReason = selected === 'other' 
      ? { type: 'other', details: otherDetails }
      : { type: selected as any };
    onConfirm(reason);
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader><DialogTitle>Reject Task</DialogTitle></DialogHeader>
        <RadioGroup value={selected} onValueChange={setSelected}>
          {REJECT_OPTIONS.map((opt) => (
            <div key={opt.value} className="flex items-center space-x-2">
              <RadioGroupItem value={opt.value} id={opt.value} />
              <Label htmlFor={opt.value}>{opt.label}</Label>
            </div>
          ))}
        </RadioGroup>
        {selected === 'other' && (
          <Textarea placeholder="Please describe..." value={otherDetails} onChange={(e) => setOtherDetails(e.target.value)} />
        )}
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={handleConfirm} disabled={!selected || isLoading}>
            {isLoading ? 'Rejecting...' : 'Reject'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**3. Create `apps/web/src/components/queue/QueueTable.tsx`:**
Follow ProjectTable.tsx pattern - use @tanstack/react-table with columns:
- Task ID (link to task)
- Project Name
- Step Type (badge)
- Priority (visual indicator)
- Time in Queue (formatted)
- Actions (Accept/Reject buttons)

**Add virtual scrolling for large queues (> 100 items):**
```tsx
import { useVirtualizer } from "@tanstack/react-virtual";
import { useRef } from "react";

// In QueueTable component:
const parentRef = useRef<HTMLDivElement>(null);

const virtualizer = useVirtualizer({
  count: table.getRowModel().rows.length,
  getScrollElement: () => parentRef.current,
  estimateSize: () => 52, // Row height in px
  overscan: 10,
});

// Wrap table body in scrollable container with virtualizer
return (
  <div ref={parentRef} className="h-[600px] overflow-auto">
    <Table>
      <TableHeader>...</TableHeader>
      <TableBody style={{ height: virtualizer.getTotalSize() }} className="relative">
        {virtualizer.getVirtualItems().map((virtualRow) => {
          const row = table.getRowModel().rows[virtualRow.index];
          return (
            <TableRow
              key={row.id}
              data-state={row.getIsSelected() && "selected"}
              style={{
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: `${virtualRow.size}px`,
                transform: `translateY(${virtualRow.start}px)`,
              }}
            >
              {row.getVisibleCells().map((cell) => (
                <TableCell key={cell.id}>
                  {flexRender(cell.column.columnDef.cell, cell.getContext())}
                </TableCell>
              ))}
            </TableRow>
          );
        })}
      </TableBody>
    </Table>
  </div>
);
```

**4. Create `apps/web/src/pages/QueuePage.tsx`:**
```tsx
import { useState } from 'react';
import { QueueTable, QueueFilters, RejectDialog } from '@/components/queue';
import { useQueue, useAcceptTask, useRejectTask } from '@/hooks';
import { QueueFilters as FilterType, QueueSort, QueueItem } from '@/api/queue';

export function QueuePage() {
  const [filters, setFilters] = useState<FilterType>({});
  const [sort, setSort] = useState<QueueSort>({ by: 'priority', order: 'desc' });
  const [rejectItem, setRejectItem] = useState<QueueItem | null>(null);
  
  const { data, isLoading } = useQueue(filters, sort);
  const acceptMutation = useAcceptTask();
  const rejectMutation = useRejectTask();

  // ... render with QueueFilters, QueueTable, RejectDialog
}
```

**5. Update `apps/web/src/App.tsx`:**
Add route: `<Route path="/queue" element={<QueuePage />} />`

**6. Create `apps/web/src/components/queue/index.ts`:** Export all components
  </action>
  <verify>
    cd apps/web && pnpm build && pnpm lint
  </verify>
  <done>
    QueuePage renders with table, filters, and working accept/reject actions
  </done>
</task>

</tasks>

<verification>
```bash
cd apps/web && pnpm build
```
- QueuePage route accessible at /queue
- Table displays queue items
- Filters update query
- Accept navigates to annotation
- Reject shows dialog with reasons
</verification>

<success_criteria>
- Queue table shows all required columns
- Filters work (project, step type)
- Sort works (priority, age, project)
- Accept button triggers API and redirects
- Reject dialog collects reason
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management/07-05-SUMMARY.md`
</output>
