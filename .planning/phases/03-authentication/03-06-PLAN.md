---
phase: 03-authentication
plan: 06
type: execute
wave: 5
depends_on: ["03-05"]
files_modified:
  - libs/auth/src/audit.rs
  - libs/auth/src/lib.rs
  - apps/api/src/middleware/audit.rs
  - apps/api/src/middleware/mod.rs
  - apps/api/src/routes/auth.rs
autonomous: true

must_haves:
  truths:
    - "All auth events are logged with required metadata"
    - "Audit logs use OpenTelemetry format"
    - "Audit logging is async and non-blocking"
  artifacts:
    - path: "libs/auth/src/audit.rs"
      provides: "AuditEvent struct and emit function"
      exports: ["AuditEvent", "AuditEventType", "emit_audit_event"]
    - path: "apps/api/src/middleware/audit.rs"
      provides: "Audit middleware for auth events"
      exports: ["audit_context"]
  key_links:
    - from: "apps/api/src/middleware/audit.rs"
      to: "libs/auth/src/audit.rs"
      via: "emit_audit_event"
      pattern: "emit_audit_event"
    - from: "apps/api/src/routes/auth.rs"
      to: "libs/auth/src/audit.rs"
      via: "emit_audit_event"
      pattern: "AuditEvent|emit_audit_event"
---

<objective>
Implement audit logging for authentication events with OpenTelemetry format.

Purpose: Capture auth events for security review and compliance per CONTEXT.md requirements.
Output: AuditEvent type, emit function, middleware for automatic capture.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@libs/auth/src/lib.rs
@apps/api/src/middleware/mod.rs
@apps/api/src/routes/auth.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement audit event types and emitter</name>
  <files>
    libs/auth/src/audit.rs
    libs/auth/src/lib.rs
  </files>
  <action>
Create libs/auth/src/audit.rs with audit logging support.

Per CONTEXT.md audit requirements, capture:
- timestamp, user_id, event_type, IP address, user_agent
- success/failure, request_path, request_id, session_id

```rust
use chrono::{DateTime, Utc};
use serde::Serialize;
use tracing::info;

/// Types of audit events per CONTEXT.md
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuditEventType {
    Login,
    LoginFailed,
    Logout,
    TokenRefresh,
    TokenRefreshFailed,
    SessionCreated,
    SessionRevoked,
    PermissionDenied,
    ProtectedResourceAccess,
}

/// Audit event structure matching OpenTelemetry semantic conventions
#[derive(Debug, Clone, Serialize)]
pub struct AuditEvent {
    pub timestamp: DateTime<Utc>,
    pub event_type: AuditEventType,
    pub user_id: Option<String>,
    pub session_id: Option<String>,
    pub request_id: String,
    pub request_path: String,
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
    pub success: bool,
    pub error_code: Option<String>,
    pub details: Option<serde_json::Value>,
}

impl AuditEvent {
    pub fn new(event_type: AuditEventType, request_id: String, request_path: String) -> Self {
        Self {
            timestamp: Utc::now(),
            event_type,
            user_id: None,
            session_id: None,
            request_id,
            request_path,
            ip_address: None,
            user_agent: None,
            success: true,
            error_code: None,
            details: None,
        }
    }

    // Builder methods for optional fields
    pub fn with_user(mut self, user_id: impl Into<String>) -> Self { ... }
    pub fn with_session(mut self, session_id: impl Into<String>) -> Self { ... }
    pub fn with_ip(mut self, ip: impl Into<String>) -> Self { ... }
    pub fn with_user_agent(mut self, ua: impl Into<String>) -> Self { ... }
    pub fn with_failure(mut self, error_code: impl Into<String>) -> Self { ... }
    pub fn with_details(mut self, details: serde_json::Value) -> Self { ... }
}

/// Emit audit event asynchronously (non-blocking per CONTEXT.md)
pub fn emit_audit_event(event: AuditEvent) {
    // Use tracing with structured logging for OpenTelemetry format
    // This integrates with existing tracing infrastructure
    info!(
        target: "audit",
        timestamp = %event.timestamp,
        event_type = ?event.event_type,
        user_id = ?event.user_id,
        session_id = ?event.session_id,
        request_id = %event.request_id,
        request_path = %event.request_path,
        ip_address = ?event.ip_address,
        success = event.success,
        error_code = ?event.error_code,
        "auth_event"
    );
}
```

Update libs/auth/src/lib.rs:
- pub mod audit;
- pub use audit::{AuditEvent, AuditEventType, emit_audit_event};
  </action>
  <verify>`cargo check -p glyph-auth` compiles</verify>
  <done>AuditEvent captures all required metadata per CONTEXT.md</done>
</task>

<task type="auto">
  <name>Task 2: Add audit logging to auth routes and middleware</name>
  <files>
    apps/api/src/middleware/audit.rs
    apps/api/src/middleware/mod.rs
    apps/api/src/routes/auth.rs
  </files>
  <action>
Create apps/api/src/middleware/audit.rs with helper to extract audit context:

```rust
use axum::http::Request;

/// Extract audit context from request (IP, user agent, request ID)
pub fn audit_context<B>(req: &Request<B>) -> (Option<String>, Option<String>, String) {
    let ip = req.headers()
        .get("x-forwarded-for")
        .or_else(|| req.headers().get("x-real-ip"))
        .and_then(|v| v.to_str().ok())
        .map(|s| s.split(',').next().unwrap_or(s).trim().to_string());

    let user_agent = req.headers()
        .get("user-agent")
        .and_then(|v| v.to_str().ok())
        .map(String::from);

    let request_id = req.headers()
        .get("x-request-id")
        .and_then(|v| v.to_str().ok())
        .unwrap_or_default()
        .to_string();

    (ip, user_agent, request_id)
}
```

Update apps/api/src/middleware/mod.rs:
- pub mod audit;
- pub use audit::audit_context;

Update apps/api/src/routes/auth.rs to emit audit events.

IMPORTANT: Extract audit context (IP, user_agent, request_id) at the START of each handler using:
```rust
let (ip, user_agent, request_id) = audit_context(&req);
```

Then consistently include IP and user_agent in ALL audit events (both success and failure cases).

In login handler:
```rust
let (ip, user_agent, request_id) = audit_context(&req);
emit_audit_event(
    AuditEvent::new(AuditEventType::Login, request_id.clone(), "/api/auth/login".into())
        .with_ip(ip.unwrap_or_default())
        .with_user_agent(user_agent.unwrap_or_default())
);
```

In callback handler (success):
```rust
let (ip, user_agent, request_id) = audit_context(&req);
// ... on success:
emit_audit_event(
    AuditEvent::new(AuditEventType::SessionCreated, request_id.clone(), "/api/auth/callback".into())
        .with_user(&claims.sub)
        .with_ip(ip.clone().unwrap_or_default())
        .with_user_agent(user_agent.clone().unwrap_or_default())
);
```

In callback handler (failure - capture before user exists):
```rust
// ... on failure (no user yet):
emit_audit_event(
    AuditEvent::new(AuditEventType::LoginFailed, request_id.clone(), "/api/auth/callback".into())
        .with_failure("token_exchange_failed")
        .with_ip(ip.clone().unwrap_or_default())
        .with_user_agent(user_agent.clone().unwrap_or_default())
);
```

In logout handler:
```rust
let (ip, user_agent, request_id) = audit_context(&req);
emit_audit_event(
    AuditEvent::new(AuditEventType::Logout, request_id.clone(), "/api/auth/logout".into())
        .with_user(&current_user.auth0_id)
        .with_ip(ip.unwrap_or_default())
        .with_user_agent(user_agent.unwrap_or_default())
);
```

In refresh handler (success):
```rust
let (ip, user_agent, request_id) = audit_context(&req);
emit_audit_event(
    AuditEvent::new(AuditEventType::TokenRefresh, request_id.clone(), "/api/auth/refresh".into())
        .with_ip(ip.clone().unwrap_or_default())
        .with_user_agent(user_agent.clone().unwrap_or_default())
);
```

In refresh handler (failure):
```rust
emit_audit_event(
    AuditEvent::new(AuditEventType::TokenRefreshFailed, request_id.clone(), "/api/auth/refresh".into())
        .with_failure("refresh_failed")
        .with_ip(ip.unwrap_or_default())
        .with_user_agent(user_agent.unwrap_or_default())
);
  </action>
  <verify>`cargo check -p glyph-api` compiles, logs show audit events with `RUST_LOG=audit=info`</verify>
  <done>Auth routes emit audit events for all auth actions per CONTEXT.md</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p glyph-auth -p glyph-api` compiles
- [ ] Login emits Login audit event
- [ ] Failed login emits LoginFailed audit event
- [ ] Successful callback emits SessionCreated event
- [ ] Logout emits Logout event
- [ ] Token refresh emits TokenRefresh event
- [ ] Failed refresh emits TokenRefreshFailed event
- [ ] Events include: timestamp, event_type, user_id, request_id, ip, user_agent
- [ ] Events logged via tracing (OpenTelemetry compatible)
</verification>

<success_criteria>
- All auth events logged with required metadata
- OpenTelemetry format via tracing structured logging
- Non-blocking async emission
- Events visible with RUST_LOG=audit=info
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-06-SUMMARY.md`
</output>
