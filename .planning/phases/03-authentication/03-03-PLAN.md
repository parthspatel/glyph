---
phase: 03-authentication
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - libs/auth/src/oidc.rs
  - libs/auth/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "OIDC authorization URL can be generated with PKCE"
    - "Authorization code can be exchanged for tokens"
    - "Federated logout URL can be generated"
  artifacts:
    - path: "libs/auth/src/oidc.rs"
      provides: "Auth0Client with authorize_url, exchange_code, logout_url"
      exports: ["Auth0Client", "AuthorizationData", "TokenResponse"]
  key_links:
    - from: "libs/auth/src/oidc.rs"
      to: "Auth0 authorization endpoint"
      via: "openidconnect CoreClient"
      pattern: "authorize_url"
    - from: "libs/auth/src/oidc.rs"
      to: "Auth0 token endpoint"
      via: "exchange_code"
      pattern: "token_endpoint"
---

<objective>
Implement Auth0 OIDC client for authorization code flow with PKCE.

Purpose: Handle OAuth2/OIDC flows including login initiation, callback handling, and logout.
Output: Auth0Client with methods for authorization URL generation, code exchange, and logout.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@libs/auth/src/lib.rs
@libs/auth/src/config.rs
@libs/auth/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Auth0Client with OIDC discovery</name>
  <files>libs/auth/src/oidc.rs</files>
  <action>
Create libs/auth/src/oidc.rs implementing Auth0Client using openidconnect crate.

Use openidconnect types:
- CoreClient for OIDC client
- CoreProviderMetadata for discovery
- CsrfToken, Nonce, PkceCodeChallenge, PkceCodeVerifier for security
- AuthorizationCode for callback

```rust
pub struct Auth0Client {
    client: CoreClient,
    config: Auth0Config,
}
```

Implement:
- async new(config: Auth0Config) -> AuthResult<Self>:
  1. Create reqwest::Client with no redirects
  2. Build IssuerUrl from config.issuer()
  3. Call CoreProviderMetadata::discover_async for automatic endpoint discovery
  4. Build CoreClient::from_provider_metadata with client_id, client_secret
  5. Set redirect_uri from config.callback_url
  Return DiscoveryError on failure.

- authorize_url(&self) -> AuthorizationData:
  1. Generate PkceCodeChallenge::new_random_sha256()
  2. Call client.authorize_url() with:
     - CoreAuthenticationFlow::AuthorizationCode
     - CsrfToken::new_random
     - Nonce::new_random
  3. Add scopes: openid, profile, email, offline_access (for refresh tokens)
  4. Set PKCE challenge
  5. Return AuthorizationData { url, csrf_token, nonce, pkce_verifier }

Create AuthorizationData struct to hold CSRF, nonce, and PKCE verifier for storage.
  </action>
  <verify>`cargo check -p glyph-auth` compiles</verify>
  <done>Auth0Client discovers endpoints and generates authorization URLs with PKCE</done>
</task>

<task type="auto">
  <name>Task 2: Implement code exchange and logout</name>
  <files>
    libs/auth/src/oidc.rs
    libs/auth/src/lib.rs
  </files>
  <action>
Add to Auth0Client in libs/auth/src/oidc.rs:

- async exchange_code(&self, code: AuthorizationCode, pkce_verifier: PkceCodeVerifier, expected_nonce: &Nonce) -> AuthResult<TokenResponse>:
  1. Call client.exchange_code(code).set_pkce_verifier(pkce_verifier).request_async()
  2. Verify ID token nonce matches expected_nonce (per RESEARCH.md pitfall)
  3. Extract access_token, refresh_token, id_token, expires_in
  4. Return TokenResponse struct
  Return TokenExchangeError on failure, InvalidNonce if nonce mismatch.

- logout_url(&self, return_to: &str) -> String:
  Per CONTEXT.md decision for federated logout:
  ```
  https://{domain}/v2/logout?client_id={client_id}&returnTo={return_to}&federated
  ```
  URL-encode return_to parameter.

Create TokenResponse struct:
- access_token: String
- refresh_token: Option<String>
- id_token: String
- expires_in: std::time::Duration

Update libs/auth/src/lib.rs to add:
- pub mod oidc;
- pub use oidc::{Auth0Client, AuthorizationData, TokenResponse};
  </action>
  <verify>`cargo check -p glyph-auth` compiles, doc comments for all public items</verify>
  <done>Code exchange validates nonce, logout uses federated logout</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p glyph-auth` compiles
- [ ] Auth0Client discovers endpoints from .well-known/openid-configuration
- [ ] authorize_url generates PKCE challenge with SHA256
- [ ] authorize_url includes offline_access scope for refresh tokens
- [ ] exchange_code validates nonce (prevents replay attacks)
- [ ] logout_url uses federated logout per CONTEXT.md
- [ ] TokenResponse includes refresh_token when offline_access granted
</verification>

<success_criteria>
- OIDC discovery finds Auth0 endpoints automatically
- Authorization URL has CSRF, nonce, PKCE for security
- Code exchange validates nonce and extracts all tokens
- Federated logout clears Auth0 session
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-03-SUMMARY.md`
</output>
