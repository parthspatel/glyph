---
phase: 03-authentication
plan: 04
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - libs/auth/src/tokens.rs
  - libs/auth/src/lib.rs
  - apps/api/src/extractors/mod.rs
  - apps/api/src/extractors/current_user.rs
  - apps/api/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Tokens are stored in encrypted HttpOnly cookies"
    - "CurrentUser extractor validates JWT and provides typed user context"
    - "Refresh token has restricted path for security"
  artifacts:
    - path: "libs/auth/src/tokens.rs"
      provides: "Cookie helpers for token storage"
      exports: ["set_auth_cookies", "clear_auth_cookies", "ACCESS_TOKEN_COOKIE", "REFRESH_TOKEN_COOKIE"]
    - path: "apps/api/src/extractors/current_user.rs"
      provides: "CurrentUser extractor with UserId, email, roles"
      exports: ["CurrentUser"]
  key_links:
    - from: "apps/api/src/extractors/current_user.rs"
      to: "libs/auth/src/jwt.rs"
      via: "validate_jwt"
      pattern: "glyph_auth::validate_jwt"
    - from: "apps/api/src/extractors/current_user.rs"
      to: "axum_extra::cookie"
      via: "PrivateCookieJar"
      pattern: "CookieJar|get.*access_token"
---

<objective>
Implement secure token storage in HttpOnly cookies and CurrentUser extractor for authenticated handlers.

Purpose: Provide XSS-proof token storage and type-safe authentication in route handlers.
Output: Cookie helpers, CurrentUser extractor with UserId and claims.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@libs/auth/src/lib.rs
@libs/auth/src/jwt.rs
@apps/api/src/extractors/mod.rs
@apps/api/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement token cookie helpers</name>
  <files>
    libs/auth/src/tokens.rs
    libs/auth/src/lib.rs
  </files>
  <action>
Create libs/auth/src/tokens.rs with cookie constants and helpers.

Per CONTEXT.md decisions:
- Access tokens: 30 minutes validity
- Refresh tokens: 7 days validity
- HttpOnly cookies for XSS protection
- Secure flag for HTTPS only
- SameSite=Strict for CSRF protection

```rust
pub const ACCESS_TOKEN_COOKIE: &str = "glyph_access_token";
pub const REFRESH_TOKEN_COOKIE: &str = "glyph_refresh_token";
pub const PKCE_COOKIE: &str = "glyph_pkce_state";

/// Token durations matching CONTEXT.md
pub const ACCESS_TOKEN_DURATION: Duration = Duration::minutes(30);
pub const REFRESH_TOKEN_DURATION: Duration = Duration::days(7);
```

Implement:
- set_auth_cookies(access_token: &str, refresh_token: Option<&str>) -> (Cookie, Option<Cookie>):
  Build access token cookie with:
  - http_only(true), secure(true), same_site(SameSite::Strict)
  - max_age(ACCESS_TOKEN_DURATION), path("/")
  
  Build refresh token cookie with:
  - http_only(true), secure(true), same_site(SameSite::Strict)
  - max_age(REFRESH_TOKEN_DURATION), path("/api/auth/refresh") (restricted path per RESEARCH.md)

- clear_auth_cookies() -> (Cookie, Cookie):
  Return cookies with max_age(0) to delete them

- set_pkce_cookie(csrf: &str, nonce: &str, verifier: &str) -> Cookie:
  Store PKCE state for callback validation, short TTL (10 min)

- parse_pkce_cookie(value: &str) -> Option<(String, String, String)>:
  Parse stored PKCE state

Update libs/auth/src/lib.rs:
- pub mod tokens;
- pub use tokens::{set_auth_cookies, clear_auth_cookies, ACCESS_TOKEN_COOKIE, REFRESH_TOKEN_COOKIE};
  </action>
  <verify>`cargo check -p glyph-auth` compiles</verify>
  <done>Cookie helpers implement secure storage per CONTEXT.md requirements</done>
</task>

<task type="auto">
  <name>Task 2: Implement CurrentUser extractor</name>
  <files>apps/api/src/extractors/current_user.rs</files>
  <action>
Replace placeholder apps/api/src/extractors/current_user.rs with full implementation.

```rust
use axum::extract::FromRequestParts;
use axum::http::request::Parts;
use axum_extra::extract::cookie::CookieJar;
use glyph_auth::{validate_jwt, Claims, JwksCache, Auth0Config, ACCESS_TOKEN_COOKIE};
use glyph_domain::UserId;
use crate::ApiError;

/// Authenticated user context extracted from JWT
#[derive(Debug, Clone)]
pub struct CurrentUser {
    pub user_id: UserId,
    pub auth0_id: String,  // sub claim
    pub email: Option<String>,
    pub email_verified: bool,
    pub name: Option<String>,
    pub roles: Vec<String>,
}

impl CurrentUser {
    pub fn from_claims(claims: Claims) -> Result<Self, ApiError> {
        // Parse user_id from custom claim or look up from database
        // For now, generate from auth0_id - will be resolved in Phase 4
        Ok(Self {
            user_id: UserId::new(), // Placeholder - real lookup in Phase 4
            auth0_id: claims.sub,
            email: claims.email,
            email_verified: claims.email_verified.unwrap_or(false),
            name: claims.name,
            roles: claims.roles.unwrap_or_default(),
        })
    }
}
```

Implement FromRequestParts:
1. Get CookieJar from parts
2. Get ACCESS_TOKEN_COOKIE value, return Unauthorized if missing
3. Get JwksCache from parts.extensions (set by middleware layer)
4. Get Auth0Config from parts.extensions
5. Call validate_jwt(token, jwks, config).await
6. Map AuthError to ApiError (TokenExpired/InvalidToken -> Unauthorized)
7. Build CurrentUser from Claims

Add extension requirement:
```rust
// JwksCache and Auth0Config must be in request extensions
// Set up in main.rs via Extension layer
```
  </action>
  <verify>`cargo check -p glyph-api` compiles</verify>
  <done>CurrentUser extracts authenticated user from JWT cookie</done>
</task>

<task type="auto">
  <name>Task 3: Update extractors module and add state types</name>
  <files>
    apps/api/src/extractors/mod.rs
    apps/api/src/lib.rs
  </files>
  <action>
Update apps/api/src/extractors/mod.rs:

```rust
//! Custom Axum extractors

mod current_user;

pub use current_user::CurrentUser;
```

Add AuthState to apps/api/src/lib.rs or create apps/api/src/state.rs:

```rust
/// Shared authentication state
#[derive(Clone)]
pub struct AuthState {
    pub jwks_cache: Arc<glyph_auth::JwksCache>,
    pub auth0_config: Arc<glyph_auth::Auth0Config>,
    pub auth0_client: Arc<glyph_auth::Auth0Client>,
}
```

This state will be initialized in main.rs and added as Extension layer. The CurrentUser extractor accesses it from request extensions.

Add to lib.rs public exports:
- pub mod extractors;
- pub use extractors::CurrentUser;
  </action>
  <verify>`cargo check -p glyph-api` compiles, CurrentUser can be used in handler signatures</verify>
  <done>CurrentUser extractor ready for use in protected route handlers</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p glyph-auth -p glyph-api` compiles
- [ ] Access token cookie is HttpOnly, Secure, SameSite=Strict
- [ ] Refresh token cookie has restricted path /api/auth/refresh
- [ ] CurrentUser extracts from cookie (not Authorization header per CONTEXT.md)
- [ ] Missing token returns 401 Unauthorized
- [ ] Invalid token returns 401 Unauthorized
- [ ] Expired token returns 401 Unauthorized
- [ ] CurrentUser provides UserId, email, roles
</verification>

<success_criteria>
- Tokens stored in encrypted HttpOnly cookies
- CurrentUser works as Axum extractor in handler signature
- Token validation uses JWKS cache (not fetching per request)
- Error responses use RFC 7807 format via ApiError
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-04-SUMMARY.md`
</output>
