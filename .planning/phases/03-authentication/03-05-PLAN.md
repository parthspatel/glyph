---
phase: 03-authentication
plan: 05
type: execute
wave: 4
depends_on: ["03-03", "03-04"]
files_modified:
  - apps/api/src/routes/auth.rs
  - apps/api/src/routes/mod.rs
  - apps/api/src/main.rs
autonomous: true
user_setup:
  - service: auth0
    why: "OAuth2/OIDC identity provider"
    env_vars:
      - name: AUTH0_DOMAIN
        source: "Auth0 Dashboard -> Applications -> Settings -> Domain"
      - name: AUTH0_CLIENT_ID
        source: "Auth0 Dashboard -> Applications -> Settings -> Client ID"
      - name: AUTH0_CLIENT_SECRET
        source: "Auth0 Dashboard -> Applications -> Settings -> Client Secret"
      - name: AUTH0_API_IDENTIFIER
        source: "Auth0 Dashboard -> APIs -> API Identifier"
    dashboard_config:
      - task: "Create Regular Web Application"
        location: "Auth0 Dashboard -> Applications -> Create Application"
      - task: "Add callback URL (http://localhost:3000/api/auth/callback)"
        location: "Auth0 Dashboard -> Applications -> Settings -> Allowed Callback URLs"
      - task: "Add logout URL (http://localhost:3000)"
        location: "Auth0 Dashboard -> Applications -> Settings -> Allowed Logout URLs"
      - task: "Enable Refresh Token Rotation"
        location: "Auth0 Dashboard -> Applications -> Settings -> Refresh Token Rotation"

must_haves:
  truths:
    - "Login redirects to Auth0 with PKCE"
    - "Callback exchanges code and sets cookies"
    - "Logout clears cookies and redirects to Auth0 federated logout"
    - "Refresh endpoint rotates tokens"
  artifacts:
    - path: "apps/api/src/routes/auth.rs"
      provides: "Auth endpoints: login, callback, logout, refresh, me"
      exports: ["auth_router"]
  key_links:
    - from: "apps/api/src/routes/auth.rs"
      to: "libs/auth/src/oidc.rs"
      via: "Auth0Client"
      pattern: "auth0_client\\.authorize_url|exchange_code"
    - from: "apps/api/src/routes/auth.rs"
      to: "libs/auth/src/tokens.rs"
      via: "set_auth_cookies, set_pkce_cookie, parse_pkce_cookie"
      pattern: "set_auth_cookies|clear_auth_cookies|set_pkce_cookie|parse_pkce_cookie"
    - from: "apps/api/src/routes/auth.rs (GET /me)"
      to: "apps/api/src/extractors/current_user.rs"
      via: "CurrentUser extractor"
      pattern: "CurrentUser|from_claims"
    - from: "apps/api/src/routes/auth.rs"
      to: "axum_extra::cookie::PrivateCookieJar"
      via: "Cookie encryption layer"
      pattern: "PrivateCookieJar|jar\\.add"
---

<objective>
Implement authentication endpoints for login, callback, logout, and token refresh.

Purpose: Complete the OAuth2/OIDC flow with Auth0 for user authentication.
Output: /api/auth/* endpoints handling full auth lifecycle.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-authentication/03-CONTEXT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@libs/auth/src/oidc.rs
@libs/auth/src/tokens.rs
@apps/api/src/routes/mod.rs
@apps/api/src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auth routes</name>
  <files>apps/api/src/routes/auth.rs</files>
  <action>
Create apps/api/src/routes/auth.rs with auth endpoints.

Use axum_extra::extract::cookie::PrivateCookieJar for encrypted cookies.

Endpoints:

GET /api/auth/login?redirect_to={url}:
1. Get Auth0Client from state
2. Call auth0_client.authorize_url() to get (url, csrf_token, nonce, pkce_verifier)
3. Call glyph_auth::set_pkce_cookie(csrf_token.secret(), nonce.secret(), pkce_verifier.secret()) to create PKCE cookie
4. Add PKCE cookie to PrivateCookieJar via jar.add(pkce_cookie)
5. Store redirect_to in separate cookie for post-callback redirect
6. Return Redirect to authorization URL with updated cookie jar

GET /api/auth/callback?code={code}&state={state}:
1. Get PKCE cookie from PrivateCookieJar, call glyph_auth::parse_pkce_cookie(value) to extract (csrf, nonce, verifier)
2. Verify state query param matches csrf from cookie (return 400 BadRequest if mismatch)
3. Get Auth0Client from state
4. Call exchange_code(AuthorizationCode::new(code), PkceCodeVerifier::new(verifier), &Nonce::new(nonce))
5. Get (access_cookie, refresh_cookie) from glyph_auth::set_auth_cookies(access_token, refresh_token)
6. Add access_cookie and refresh_cookie to PrivateCookieJar via jar.add()
7. Clear PKCE cookie with max_age(0)
8. Get redirect_to from cookie (default to "/")
9. Return Redirect to redirect_to with updated cookie jar

POST /api/auth/logout:
1. Call clear_auth_cookies()
2. Get Auth0Client from state
3. Build federated logout URL
4. Return Redirect to logout URL (or JSON { logout_url } for SPA)

POST /api/auth/refresh:
1. Get refresh token from cookie (restricted path /api/auth/refresh)
2. Call Auth0 token endpoint with grant_type=refresh_token
3. Get new access_token (and rotated refresh_token if rotation enabled)
4. Call set_auth_cookies with new tokens
5. Return 200 OK

GET /api/auth/me:
1. Use CurrentUser extractor
2. Return JSON with user info (id, email, name, roles)
3. Returns 401 if not authenticated

Create auth_router() function returning Router with all routes.
  </action>
  <verify>`cargo check -p glyph-api` compiles</verify>
  <done>Auth endpoints handle full OAuth2 flow with PKCE and cookie storage</done>
</task>

<task type="auto">
  <name>Task 2: Wire up auth routes and state</name>
  <files>
    apps/api/src/routes/mod.rs
    apps/api/src/main.rs
  </files>
  <action>
Update apps/api/src/routes/mod.rs:
- Add `pub mod auth;`
- Add `pub use auth::auth_router;`

Update apps/api/src/main.rs to:

1. Load Auth0Config from environment:
```rust
let auth0_config = Arc::new(glyph_auth::Auth0Config::from_env()?);
```

2. Initialize JWKS cache and trigger initial fetch:
```rust
let jwks_cache = Arc::new(glyph_auth::JwksCache::new(auth0_config.jwks_url()));
jwks_cache.refresh().await?;
```

3. Initialize Auth0Client:
```rust
let auth0_client = Arc::new(glyph_auth::Auth0Client::new((*auth0_config).clone()).await?);
```

4. Create AuthState and add as Extension:
```rust
let auth_state = AuthState { jwks_cache, auth0_config, auth0_client };
```

5. Generate cookie key for PrivateCookieJar:
```rust
use axum_extra::extract::cookie::Key;
let cookie_key = Key::from(std::env::var("COOKIE_SECRET")?.as_bytes());
```

6. Mount auth router:
```rust
.nest("/api/auth", auth_router())
.layer(Extension(auth_state))
.layer(Extension(cookie_key))
```

Add COOKIE_SECRET to required env vars (32+ bytes for encryption key).
  </action>
  <verify>`cargo check -p glyph-api` compiles, `cargo run -p glyph-api` starts without panics</verify>
  <done>Auth routes mounted at /api/auth/*, AuthState available to handlers</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p glyph-api` compiles
- [ ] GET /api/auth/login redirects to Auth0
- [ ] GET /api/auth/callback sets cookies on success
- [ ] POST /api/auth/logout clears cookies and redirects
- [ ] POST /api/auth/refresh rotates tokens
- [ ] GET /api/auth/me returns user info (authenticated) or 401 (unauthenticated)
- [ ] PKCE state validated on callback
- [ ] CSRF state validated on callback
- [ ] Federated logout used per CONTEXT.md
</verification>

<success_criteria>
- Complete OAuth2 authorization code flow with PKCE works
- Tokens stored in encrypted HttpOnly cookies
- Login remembers redirect destination
- Logout clears app and Auth0 session
- Token refresh rotates both tokens
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-05-SUMMARY.md`
</output>
