---
phase: 03-authentication
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - libs/auth/src/jwks.rs
  - libs/auth/src/jwt.rs
  - libs/auth/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "JWKS keys are fetched and cached from Auth0"
    - "JWT tokens are validated with RS256 against cached JWKS"
    - "Token claims include issuer, audience, and expiration validation"
  artifacts:
    - path: "libs/auth/src/jwks.rs"
      provides: "JwksCache with async refresh and key lookup by kid"
      exports: ["JwksCache"]
    - path: "libs/auth/src/jwt.rs"
      provides: "Claims struct and validate_jwt function"
      exports: ["Claims", "validate_jwt"]
  key_links:
    - from: "libs/auth/src/jwt.rs"
      to: "libs/auth/src/jwks.rs"
      via: "JwksCache::get_key"
      pattern: "jwks\\.get_key"
    - from: "libs/auth/src/jwks.rs"
      to: "Auth0 JWKS endpoint"
      via: "reqwest HTTP fetch"
      pattern: "\\.well-known/jwks\\.json"
---

<objective>
Implement JWKS caching and JWT validation against Auth0's public keys.

Purpose: Enable secure token validation without fetching keys on every request.
Output: JwksCache with background refresh, validate_jwt function with proper claim checks.
</objective>

<execution_context>
@/Users/parthpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/parthpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-authentication/03-RESEARCH.md
@libs/auth/src/lib.rs
@libs/auth/src/config.rs
@libs/auth/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JWKS cache</name>
  <files>libs/auth/src/jwks.rs</files>
  <action>
Create libs/auth/src/jwks.rs implementing JwksCache:

Use jsonwebtoken::jwk::JwkSet for key storage. Use tokio::sync::RwLock for thread-safe access. Use reqwest::Client for HTTP fetches.

```rust
pub struct JwksCache {
    keys: Arc<RwLock<JwkSet>>,
    jwks_url: String,
    http_client: reqwest::Client,
}
```

Implement:
- new(jwks_url: String) -> Self - create cache with empty JwkSet
- async refresh(&self) -> AuthResult<()> - fetch from jwks_url, parse JwkSet, update RwLock. Return JwksFetchError on failure.
- async get_key(&self, kid: &str) -> AuthResult<DecodingKey> - read lock, find JWK by kid, convert to DecodingKey. Return KeyNotFound if missing.
- async get_or_refresh_key(&self, kid: &str) -> AuthResult<DecodingKey> - try get_key, if KeyNotFound try refresh once then get_key again (handles key rotation).

Use reqwest with timeout (10s) and no redirects for security. Log JWKS refresh with tracing::info!.
  </action>
  <verify>`cargo check -p glyph-auth` compiles, unit test for JwkSet parsing</verify>
  <done>JWKS cache fetches keys from Auth0 and provides DecodingKey by kid</done>
</task>

<task type="auto">
  <name>Task 2: Implement JWT validation</name>
  <files>
    libs/auth/src/jwt.rs
    libs/auth/src/lib.rs
  </files>
  <action>
Create libs/auth/src/jwt.rs with Claims struct and validate_jwt function.

Claims struct (derive Debug, Clone, Serialize, Deserialize):
- sub: String (subject - Auth0 user ID)
- iss: String (issuer)
- aud: Vec<String> (audience - can be string or array in JWT)
- exp: i64 (expiration timestamp)
- iat: i64 (issued at)
- email: Option<String>
- email_verified: Option<bool>
- name: Option<String>
- picture: Option<String>
- roles: Option<Vec<String>> (custom claim for RBAC, namespace TBD)

Implement validate_jwt:
```rust
pub async fn validate_jwt(
    token: &str,
    jwks: &JwksCache,
    config: &Auth0Config,
) -> AuthResult<Claims>
```

1. Use jsonwebtoken::decode_header to get kid from header
2. Get DecodingKey from JwksCache (with refresh on miss)
3. Build Validation with:
   - Algorithm::RS256 (explicit, prevents algorithm confusion)
   - set_issuer to config.issuer()
   - set_audience to [config.api_identifier]
   - set_leeway(60) for clock skew
4. Call jsonwebtoken::decode::<Claims>(token, &key, &validation)
5. Map errors: ExpiredSignature -> TokenExpired, others -> InvalidToken

Update libs/auth/src/lib.rs to add:
- pub mod jwks;
- pub mod jwt;
- pub use jwks::JwksCache;
- pub use jwt::{Claims, validate_jwt};
  </action>
  <verify>`cargo check -p glyph-auth` compiles, `cargo test -p glyph-auth` passes</verify>
  <done>JWT validation enforces RS256, issuer, audience, expiration with clock skew tolerance</done>
</task>

</tasks>

<verification>
- [ ] `cargo check -p glyph-auth` compiles
- [ ] JwksCache fetches and caches JWK set
- [ ] JwksCache refreshes on key miss (handles rotation)
- [ ] validate_jwt rejects HS256 tokens (algorithm confusion prevention)
- [ ] validate_jwt checks issuer matches config
- [ ] validate_jwt checks audience matches api_identifier
- [ ] validate_jwt allows 60-second clock skew
- [ ] TokenExpired returned for expired tokens
</verification>

<success_criteria>
- JWKS keys cached and refreshed on demand
- JWT validation uses RS256 explicitly
- Claims extracted include sub, email, roles
- Invalid tokens produce specific AuthError variants
</success_criteria>

<output>
After completion, create `.planning/phases/03-authentication/03-02-SUMMARY.md`
</output>
