---
phase: 08-layout-system
plan: 07
type: execute
wave: 2
depends_on: [08-03]
files_modified:
  - libs/domain/src/layout/mod.rs
  - libs/domain/src/layout/version.rs
  - apps/api/src/routes/layouts.rs
  - migrations/YYYYMMDD_layout_versions.sql
autonomous: true

must_haves:
  truths:
    - "Layout versions are immutable once published"
    - "Lifecycle: draft -> published -> deprecated"
    - "Tasks keep the layout version they started with"
    - "API supports version listing, publishing, deprecation"
  artifacts:
    - path: "libs/domain/src/layout/version.rs"
      provides: "LayoutVersion domain type"
      exports: ["LayoutVersion", "LayoutStatus"]
    - path: "apps/api/src/routes/layouts.rs"
      provides: "Layout version REST endpoints"
      exports: ["layout_routes"]
---

<objective>
Implement layout versioning system with immutable published versions.

Purpose: Per PRD and CONTEXT, layouts have draft/published/deprecated lifecycle. Tasks keep the version they started with, ensuring consistency during annotation.

Output: Domain types, database schema, and API endpoints for layout version management.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
@libs/domain/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout domain types</name>
  <files>
    libs/domain/src/layout/mod.rs
    libs/domain/src/layout/version.rs
  </files>
  <action>
Create layout domain model in Rust:

**layout/mod.rs:**
```rust
mod version;

pub use version::*;
```

**layout/version.rs:**
```rust
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;
use uuid::Uuid;

use crate::ids::LayoutId;
use crate::ids::LayoutVersionId;
use crate::ids::ProjectTypeId;

/// Layout status lifecycle
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "layout_status", rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum LayoutStatus {
    Draft,
    Published,
    Deprecated,
}

/// Template format
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "template_format", rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum TemplateFormat {
    Nunjucks,
    Mdx,
    Tsx,
}

/// Layout settings per PRD ยง5.2
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayoutSettings {
    pub auto_save: bool,
    pub auto_save_interval: u32,  // milliseconds
    pub show_progress: bool,
    pub keyboard_shortcuts: bool,
    pub confirm_submit: bool,
    pub allow_skip: bool,
    pub custom_css: Option<String>,
}

impl Default for LayoutSettings {
    fn default() -> Self {
        Self {
            auto_save: true,
            auto_save_interval: 5000,
            show_progress: true,
            keyboard_shortcuts: true,
            confirm_submit: true,
            allow_skip: true,
            custom_css: None,
        }
    }
}

/// A layout template (header entity, multiple versions)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Layout {
    pub id: LayoutId,
    pub name: String,
    pub description: Option<String>,
    pub project_type_id: Option<ProjectTypeId>,
    pub created_at: OffsetDateTime,
    pub updated_at: OffsetDateTime,
}

/// A specific version of a layout (immutable once published)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayoutVersion {
    pub id: LayoutVersionId,
    pub layout_id: LayoutId,
    pub version: String,  // Semantic version: "1.0.0"
    pub status: LayoutStatus,
    pub template_format: TemplateFormat,
    pub content: String,  // Template content
    pub input_schema: Option<serde_json::Value>,
    pub output_schema: Option<serde_json::Value>,
    pub settings: LayoutSettings,
    pub allowed_components: Vec<String>,
    pub shortcuts: serde_json::Value,
    pub created_at: OffsetDateTime,
    pub published_at: Option<OffsetDateTime>,
    pub deprecated_at: Option<OffsetDateTime>,
    pub created_by: Uuid,
}

impl LayoutVersion {
    /// Check if this version can be edited (only drafts)
    pub fn can_edit(&self) -> bool {
        self.status == LayoutStatus::Draft
    }
    
    /// Check if this version can be published
    pub fn can_publish(&self) -> bool {
        self.status == LayoutStatus::Draft
    }
    
    /// Check if this version can be deprecated
    pub fn can_deprecate(&self) -> bool {
        self.status == LayoutStatus::Published
    }
}

/// Request to create a new layout version
#[derive(Debug, Deserialize)]
pub struct CreateLayoutVersionRequest {
    pub layout_id: LayoutId,
    pub version: String,
    pub template_format: TemplateFormat,
    pub content: String,
    pub input_schema: Option<serde_json::Value>,
    pub output_schema: Option<serde_json::Value>,
    pub settings: Option<LayoutSettings>,
    pub allowed_components: Option<Vec<String>>,
    pub shortcuts: Option<serde_json::Value>,
}

/// Request to update a draft version
#[derive(Debug, Deserialize)]
pub struct UpdateLayoutVersionRequest {
    pub content: Option<String>,
    pub input_schema: Option<serde_json::Value>,
    pub output_schema: Option<serde_json::Value>,
    pub settings: Option<LayoutSettings>,
    pub allowed_components: Option<Vec<String>>,
    pub shortcuts: Option<serde_json::Value>,
}
```

Update libs/domain/src/lib.rs to include layout module.
  </action>
  <verify>Types compile and serialize correctly</verify>
  <done>Layout domain types created</done>
</task>

<task type="auto">
  <name>Task 2: Create database migration</name>
  <files>migrations/YYYYMMDD_layout_versions.sql</files>
  <action>
Create migration for layout tables:

```sql
-- Layout status enum
CREATE TYPE layout_status AS ENUM ('draft', 'published', 'deprecated');

-- Template format enum
CREATE TYPE template_format AS ENUM ('nunjucks', 'mdx', 'tsx');

-- Layouts table (header entity)
CREATE TABLE layouts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    project_type_id UUID REFERENCES project_types(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Layout versions table (immutable once published)
CREATE TABLE layout_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    layout_id UUID NOT NULL REFERENCES layouts(id) ON DELETE CASCADE,
    version VARCHAR(50) NOT NULL,
    status layout_status NOT NULL DEFAULT 'draft',
    template_format template_format NOT NULL DEFAULT 'nunjucks',
    content TEXT NOT NULL,
    input_schema JSONB,
    output_schema JSONB,
    settings JSONB NOT NULL DEFAULT '{}',
    allowed_components TEXT[] DEFAULT '{}',
    shortcuts JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    published_at TIMESTAMPTZ,
    deprecated_at TIMESTAMPTZ,
    created_by UUID NOT NULL REFERENCES users(id),
    
    -- Only one published version per layout
    CONSTRAINT unique_published_version 
        EXCLUDE (layout_id WITH =) WHERE (status = 'published'),
    
    -- Unique version string per layout
    UNIQUE (layout_id, version)
);

-- Indexes
CREATE INDEX idx_layout_versions_layout_id ON layout_versions(layout_id);
CREATE INDEX idx_layout_versions_status ON layout_versions(status);
CREATE INDEX idx_layouts_project_type ON layouts(project_type_id);

-- Trigger to prevent editing published/deprecated versions
CREATE OR REPLACE FUNCTION prevent_published_edit()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status != 'draft' AND (
        NEW.content != OLD.content OR
        NEW.input_schema IS DISTINCT FROM OLD.input_schema OR
        NEW.output_schema IS DISTINCT FROM OLD.output_schema OR
        NEW.settings != OLD.settings OR
        NEW.allowed_components != OLD.allowed_components OR
        NEW.shortcuts != OLD.shortcuts
    ) THEN
        RAISE EXCEPTION 'Cannot edit published or deprecated layout versions';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER layout_version_immutable
    BEFORE UPDATE ON layout_versions
    FOR EACH ROW
    EXECUTE FUNCTION prevent_published_edit();
```
  </action>
  <verify>Migration runs successfully</verify>
  <done>Database schema created with immutability constraints</done>
</task>

<task type="auto">
  <name>Task 3: Create layout repository</name>
  <files>libs/infra/src/repositories/layout_repository.rs</files>
  <action>
Create repository for layout operations:

```rust
use async_trait::async_trait;
use sqlx::PgPool;
use domain::layout::{Layout, LayoutVersion, LayoutStatus, CreateLayoutVersionRequest, UpdateLayoutVersionRequest};
use domain::ids::{LayoutId, LayoutVersionId};

#[async_trait]
pub trait LayoutRepository: Send + Sync {
    // Layout operations
    async fn create_layout(&self, name: &str, description: Option<&str>, project_type_id: Option<Uuid>) -> Result<Layout, Error>;
    async fn get_layout(&self, id: LayoutId) -> Result<Option<Layout>, Error>;
    async fn list_layouts(&self, project_type_id: Option<Uuid>) -> Result<Vec<Layout>, Error>;
    
    // Version operations
    async fn create_version(&self, req: CreateLayoutVersionRequest, created_by: Uuid) -> Result<LayoutVersion, Error>;
    async fn get_version(&self, id: LayoutVersionId) -> Result<Option<LayoutVersion>, Error>;
    async fn get_published_version(&self, layout_id: LayoutId) -> Result<Option<LayoutVersion>, Error>;
    async fn list_versions(&self, layout_id: LayoutId) -> Result<Vec<LayoutVersion>, Error>;
    async fn update_version(&self, id: LayoutVersionId, req: UpdateLayoutVersionRequest) -> Result<LayoutVersion, Error>;
    
    // Lifecycle operations
    async fn publish_version(&self, id: LayoutVersionId) -> Result<LayoutVersion, Error>;
    async fn deprecate_version(&self, id: LayoutVersionId) -> Result<LayoutVersion, Error>;
}

pub struct PgLayoutRepository {
    pool: PgPool,
}

impl PgLayoutRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl LayoutRepository for PgLayoutRepository {
    async fn publish_version(&self, id: LayoutVersionId) -> Result<LayoutVersion, Error> {
        // First check current status
        let version = self.get_version(id).await?.ok_or(Error::NotFound)?;
        if !version.can_publish() {
            return Err(Error::InvalidState("Can only publish draft versions"));
        }
        
        // Deprecate any existing published version
        sqlx::query!(
            "UPDATE layout_versions SET status = 'deprecated', deprecated_at = NOW() 
             WHERE layout_id = $1 AND status = 'published'",
            version.layout_id.as_uuid()
        )
        .execute(&self.pool)
        .await?;
        
        // Publish this version
        let updated = sqlx::query_as!(
            LayoutVersion,
            "UPDATE layout_versions SET status = 'published', published_at = NOW()
             WHERE id = $1 RETURNING *",
            id.as_uuid()
        )
        .fetch_one(&self.pool)
        .await?;
        
        Ok(updated)
    }
    
    // ... implement other methods
}
```
  </action>
  <verify>Repository CRUD operations work</verify>
  <done>Layout repository implemented</done>
</task>

<task type="auto">
  <name>Task 4: Create API routes</name>
  <files>apps/api/src/routes/layouts.rs</files>
  <action>
Create REST endpoints for layout management:

```rust
use axum::{
    extract::{Path, State, Query},
    routing::{get, post, put, patch},
    Json, Router,
};
use domain::layout::*;
use crate::auth::CurrentUser;

pub fn layout_routes() -> Router<AppState> {
    Router::new()
        // Layout CRUD
        .route("/layouts", get(list_layouts).post(create_layout))
        .route("/layouts/:id", get(get_layout))
        
        // Version CRUD
        .route("/layouts/:id/versions", get(list_versions).post(create_version))
        .route("/layouts/:layout_id/versions/:version_id", get(get_version).put(update_version))
        
        // Lifecycle
        .route("/layouts/:layout_id/versions/:version_id/publish", post(publish_version))
        .route("/layouts/:layout_id/versions/:version_id/deprecate", post(deprecate_version))
        
        // Convenience: get published version
        .route("/layouts/:id/published", get(get_published))
}

async fn create_version(
    State(state): State<AppState>,
    Path(layout_id): Path<LayoutId>,
    user: CurrentUser,
    Json(mut req): Json<CreateLayoutVersionRequest>,
) -> Result<Json<LayoutVersion>, ApiError> {
    req.layout_id = layout_id;
    let version = state.layout_repo.create_version(req, user.id).await?;
    Ok(Json(version))
}

async fn publish_version(
    State(state): State<AppState>,
    Path((layout_id, version_id)): Path<(LayoutId, LayoutVersionId)>,
    user: CurrentUser,
) -> Result<Json<LayoutVersion>, ApiError> {
    // Verify version belongs to layout
    let version = state.layout_repo.get_version(version_id).await?
        .ok_or(ApiError::NotFound)?;
    if version.layout_id != layout_id {
        return Err(ApiError::NotFound);
    }
    
    let published = state.layout_repo.publish_version(version_id).await?;
    Ok(Json(published))
}

// ... implement other handlers
```

Wire routes in apps/api/src/routes/mod.rs.
  </action>
  <verify>API endpoints respond correctly</verify>
  <done>Layout API routes created</done>
</task>

</tasks>

<verification>
- Create draft version, edit it, publish it
- Cannot edit published version (DB constraint)
- Publishing deprecates previous published version
- Get published version returns correct version
- Tasks reference specific version ID
</verification>

<success_criteria>
- Layout versions are immutable once published
- Lifecycle transitions work (draft -> published -> deprecated)
- Tasks can reference specific version IDs
- API supports full version management
</success_criteria>
