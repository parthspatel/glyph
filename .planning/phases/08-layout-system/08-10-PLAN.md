---
phase: 08-layout-system
plan: 10
type: execute
wave: 3
depends_on: [08-05]
files_modified:
  - packages/@glyph/components/src/layout/Section.tsx
  - packages/@glyph/components/src/layout/Grid.tsx
  - packages/@glyph/components/src/layout/Box.tsx
  - packages/@glyph/components/src/layout/index.ts
  - packages/@glyph/components/src/form/Select.tsx
  - packages/@glyph/components/src/form/TextArea.tsx
  - packages/@glyph/components/src/form/Checkbox.tsx
  - packages/@glyph/components/src/form/RadioGroup.tsx
  - packages/@glyph/components/src/form/index.ts
autonomous: true

must_haves:
  truths:
    - "Layout components support responsive design"
    - "Form components support validation feedback"
    - "All components use design tokens from Phase 3.1"
    - "Components work in dark and light mode"
  artifacts:
    - path: "packages/@glyph/components/src/layout/index.ts"
      provides: "Layout primitives"
      exports: ["Section", "Grid", "Box", "Column", "Header"]
    - path: "packages/@glyph/components/src/form/index.ts"
      provides: "Form components"
      exports: ["Select", "TextArea", "Checkbox", "RadioGroup"]
---

<objective>
Implement layout primitives and form components.

Purpose: Layout components (Section, Grid, Box) structure annotation interfaces. Form components (Select, TextArea, etc.) capture supplementary data. All use Tailwind design tokens.

Output: Responsive layout primitives and validated form components.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@packages/@glyph/components/src/interfaces/layout.ts
@packages/@glyph/components/src/interfaces/form.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout primitives</name>
  <files>
    packages/@glyph/components/src/layout/Section.tsx
    packages/@glyph/components/src/layout/Grid.tsx
    packages/@glyph/components/src/layout/Box.tsx
  </files>
  <action>
**Section.tsx:**
```typescript
import { useState, ReactNode } from 'react';
import { cn } from '@/lib/utils';
import { ChevronDown } from 'lucide-react';

export interface SectionProps {
  title?: string;
  description?: string;
  collapsible?: boolean;
  defaultExpanded?: boolean;
  children: ReactNode;
  className?: string;
}

export function Section({
  title,
  description,
  collapsible = false,
  defaultExpanded = true,
  children,
  className,
}: SectionProps) {
  const [expanded, setExpanded] = useState(defaultExpanded);
  
  return (
    <section className={cn('mb-6', className)}>
      {(title || description) && (
        <header 
          className={cn(
            'mb-4',
            collapsible && 'cursor-pointer select-none'
          )}
          onClick={collapsible ? () => setExpanded(!expanded) : undefined}
        >
          <div className="flex items-center gap-2">
            {title && (
              <h2 className="text-lg font-semibold text-foreground">{title}</h2>
            )}
            {collapsible && (
              <ChevronDown 
                className={cn(
                  'w-4 h-4 transition-transform',
                  !expanded && '-rotate-90'
                )}
              />
            )}
          </div>
          {description && (
            <p className="text-sm text-muted-foreground mt-1">{description}</p>
          )}
        </header>
      )}
      
      {(!collapsible || expanded) && (
        <div className="space-y-4">{children}</div>
      )}
    </section>
  );
}
```

**Grid.tsx:**
```typescript
import { ReactNode } from 'react';
import { cn } from '@/lib/utils';

export interface GridProps {
  columns?: 1 | 2 | 3 | 4 | 6 | 12;
  gap?: 'none' | 'sm' | 'md' | 'lg';
  minChildWidth?: string;  // For auto-fit
  children: ReactNode;
  className?: string;
}

export function Grid({
  columns = 2,
  gap = 'md',
  minChildWidth,
  children,
  className,
}: GridProps) {
  const columnClasses = {
    1: 'grid-cols-1',
    2: 'grid-cols-1 md:grid-cols-2',
    3: 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3',
    4: 'grid-cols-1 md:grid-cols-2 lg:grid-cols-4',
    6: 'grid-cols-2 md:grid-cols-3 lg:grid-cols-6',
    12: 'grid-cols-4 md:grid-cols-6 lg:grid-cols-12',
  };
  
  const gapClasses = {
    none: 'gap-0',
    sm: 'gap-2',
    md: 'gap-4',
    lg: 'gap-6',
  };
  
  const style = minChildWidth
    ? { gridTemplateColumns: `repeat(auto-fit, minmax(${minChildWidth}, 1fr))` }
    : undefined;
  
  return (
    <div 
      className={cn(
        'grid',
        !minChildWidth && columnClasses[columns],
        gapClasses[gap],
        className
      )}
      style={style}
    >
      {children}
    </div>
  );
}
```

**Box.tsx:**
```typescript
import { ReactNode } from 'react';
import { cn } from '@/lib/utils';

export interface BoxProps {
  padding?: 'none' | 'sm' | 'md' | 'lg';
  border?: boolean;
  rounded?: boolean;
  shadow?: boolean;
  background?: 'none' | 'muted' | 'card';
  children: ReactNode;
  className?: string;
}

export function Box({
  padding = 'md',
  border = false,
  rounded = false,
  shadow = false,
  background = 'none',
  children,
  className,
}: BoxProps) {
  const paddingClasses = {
    none: 'p-0',
    sm: 'p-2',
    md: 'p-4',
    lg: 'p-6',
  };
  
  const bgClasses = {
    none: '',
    muted: 'bg-muted',
    card: 'bg-card',
  };
  
  return (
    <div 
      className={cn(
        paddingClasses[padding],
        bgClasses[background],
        border && 'border border-border',
        rounded && 'rounded-lg',
        shadow && 'shadow-sm',
        className
      )}
    >
      {children}
    </div>
  );
}
```

Also create Column.tsx for grid columns and Header.tsx for headings.
  </action>
  <verify>Layout components render correctly</verify>
  <done>Layout primitives created</done>
</task>

<task type="auto">
  <name>Task 2: Create form components</name>
  <files>
    packages/@glyph/components/src/form/Select.tsx
    packages/@glyph/components/src/form/TextArea.tsx
    packages/@glyph/components/src/form/Checkbox.tsx
    packages/@glyph/components/src/form/RadioGroup.tsx
  </files>
  <action>
**Select.tsx:**
```typescript
import { useState, useRef, useEffect } from 'react';
import { cn } from '@/lib/utils';
import { ChevronDown, Check, X } from 'lucide-react';

export interface SelectOption {
  value: string;
  label: string;
  disabled?: boolean;
}

export interface SelectProps {
  options: SelectOption[];
  value: string | string[];
  onChange: (value: string | string[]) => void;
  placeholder?: string;
  multiple?: boolean;
  searchable?: boolean;
  required?: boolean;
  disabled?: boolean;
  error?: string;
  className?: string;
}

export function Select({
  options,
  value,
  onChange,
  placeholder = 'Select...',
  multiple = false,
  searchable = false,
  required = false,
  disabled = false,
  error,
  className,
}: SelectProps) {
  const [open, setOpen] = useState(false);
  const [search, setSearch] = useState('');
  const containerRef = useRef<HTMLDivElement>(null);
  
  const selectedValues = Array.isArray(value) ? value : value ? [value] : [];
  const selectedOptions = options.filter(o => selectedValues.includes(o.value));
  
  const filteredOptions = searchable && search
    ? options.filter(o => o.label.toLowerCase().includes(search.toLowerCase()))
    : options;
  
  // Close on outside click
  useEffect(() => {
    const handleClick = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClick);
    return () => document.removeEventListener('mousedown', handleClick);
  }, []);
  
  const handleSelect = (optionValue: string) => {
    if (multiple) {
      const newValue = selectedValues.includes(optionValue)
        ? selectedValues.filter(v => v !== optionValue)
        : [...selectedValues, optionValue];
      onChange(newValue);
    } else {
      onChange(optionValue);
      setOpen(false);
    }
    setSearch('');
  };
  
  const removeValue = (optionValue: string, e: React.MouseEvent) => {
    e.stopPropagation();
    onChange(selectedValues.filter(v => v !== optionValue));
  };
  
  return (
    <div ref={containerRef} className={cn('relative', className)}>
      <button
        type="button"
        onClick={() => !disabled && setOpen(!open)}
        className={cn(
          'w-full flex items-center justify-between px-3 py-2 text-left',
          'border rounded-md bg-background',
          'focus:outline-none focus:ring-2 focus:ring-primary',
          error ? 'border-destructive' : 'border-input',
          disabled && 'opacity-50 cursor-not-allowed'
        )}
        aria-haspopup="listbox"
        aria-expanded={open}
      >
        <span className="flex flex-wrap gap-1 flex-1">
          {selectedOptions.length === 0 ? (
            <span className="text-muted-foreground">{placeholder}</span>
          ) : multiple ? (
            selectedOptions.map(opt => (
              <span 
                key={opt.value}
                className="inline-flex items-center gap-1 px-2 py-0.5 rounded bg-muted text-sm"
              >
                {opt.label}
                <X 
                  className="w-3 h-3 cursor-pointer" 
                  onClick={(e) => removeValue(opt.value, e)}
                />
              </span>
            ))
          ) : (
            <span>{selectedOptions[0]?.label}</span>
          )}
        </span>
        <ChevronDown className={cn('w-4 h-4 transition-transform', open && 'rotate-180')} />
      </button>
      
      {open && (
        <div className="absolute z-50 w-full mt-1 bg-popover border rounded-md shadow-lg">
          {searchable && (
            <input
              type="text"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              placeholder="Search..."
              className="w-full px-3 py-2 border-b bg-transparent focus:outline-none"
              autoFocus
            />
          )}
          <ul 
            className="max-h-60 overflow-auto py-1" 
            role="listbox"
            aria-multiselectable={multiple}
          >
            {filteredOptions.map(option => {
              const selected = selectedValues.includes(option.value);
              return (
                <li
                  key={option.value}
                  role="option"
                  aria-selected={selected}
                  onClick={() => !option.disabled && handleSelect(option.value)}
                  className={cn(
                    'px-3 py-2 cursor-pointer flex items-center justify-between',
                    'hover:bg-accent',
                    selected && 'bg-accent',
                    option.disabled && 'opacity-50 cursor-not-allowed'
                  )}
                >
                  <span>{option.label}</span>
                  {selected && <Check className="w-4 h-4 text-primary" />}
                </li>
              );
            })}
            {filteredOptions.length === 0 && (
              <li className="px-3 py-2 text-muted-foreground">No options found</li>
            )}
          </ul>
        </div>
      )}
      
      {error && <p className="mt-1 text-sm text-destructive">{error}</p>}
    </div>
  );
}
```

**TextArea.tsx:**
```typescript
export interface TextAreaProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  rows?: number;
  maxLength?: number;
  required?: boolean;
  disabled?: boolean;
  error?: string;
}

export function TextArea({
  value,
  onChange,
  placeholder,
  rows = 4,
  maxLength,
  required = false,
  disabled = false,
  error,
}: TextAreaProps) {
  const remaining = maxLength ? maxLength - value.length : null;
  
  return (
    <div>
      <textarea
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        rows={rows}
        maxLength={maxLength}
        required={required}
        disabled={disabled}
        className={cn(
          'w-full px-3 py-2 rounded-md border bg-background',
          'focus:outline-none focus:ring-2 focus:ring-primary resize-y',
          error ? 'border-destructive' : 'border-input',
          disabled && 'opacity-50 cursor-not-allowed'
        )}
      />
      <div className="flex justify-between mt-1">
        {error && <p className="text-sm text-destructive">{error}</p>}
        {remaining !== null && (
          <p className={cn('text-sm ml-auto', remaining < 20 && 'text-warning')}>
            {remaining} characters remaining
          </p>
        )}
      </div>
    </div>
  );
}
```

Create similar Checkbox.tsx and RadioGroup.tsx.
  </action>
  <verify>Form components handle validation states</verify>
  <done>Form components created</done>
</task>

<task type="auto">
  <name>Task 3: Export layout and form modules</name>
  <files>
    packages/@glyph/components/src/layout/index.ts
    packages/@glyph/components/src/form/index.ts
  </files>
  <action>
**layout/index.ts:**
```typescript
export { Section, type SectionProps } from './Section';
export { Grid, type GridProps } from './Grid';
export { Box, type BoxProps } from './Box';
export { Column, type ColumnProps } from './Column';
export { Header, type HeaderProps } from './Header';
```

**form/index.ts:**
```typescript
export { Select, type SelectProps, type SelectOption } from './Select';
export { TextArea, type TextAreaProps } from './TextArea';
export { Checkbox, type CheckboxProps } from './Checkbox';
export { RadioGroup, type RadioGroupProps } from './RadioGroup';
```
  </action>
  <verify>Exports work correctly</verify>
  <done>Layout and form modules exported</done>
</task>

</tasks>

<verification>
- Grid responsive breakpoints work
- Section collapses and expands
- Select handles multiple selection
- Form components show validation errors
- All components use design tokens
- Dark/light mode works
</verification>

<success_criteria>
- Layout components support responsive design
- Form components support validation feedback
- All use Tailwind design tokens
- Components work in dark and light mode
</success_criteria>
