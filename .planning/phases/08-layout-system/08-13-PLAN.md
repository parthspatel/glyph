---
phase: 08-layout-system
plan: 13
type: execute
wave: 4
depends_on: [08-06]
files_modified:
  - packages/@glyph/layout-runtime/src/monaco/nunjucks-language.ts
  - packages/@glyph/layout-runtime/src/monaco/completion-provider.ts
  - packages/@glyph/layout-runtime/src/monaco/hover-provider.ts
  - packages/@glyph/layout-runtime/src/monaco/diagnostic-provider.ts
  - packages/@glyph/layout-runtime/src/monaco/index.ts
autonomous: true

must_haves:
  truths:
    - "Monaco syntax highlighting for Nunjucks templates"
    - "Autocomplete for bindings (input., output., context.)"
    - "Hover shows component documentation"
    - "Inline errors for template validation"
  artifacts:
    - path: "packages/@glyph/layout-runtime/src/monaco/nunjucks-language.ts"
      provides: "Nunjucks language definition for Monaco"
      exports: ["registerNunjucksLanguage"]
    - path: "packages/@glyph/layout-runtime/src/monaco/completion-provider.ts"
      provides: "Autocomplete for template bindings"
      exports: ["NunjucksCompletionProvider"]
---

<objective>
Implement Monaco custom language service for Nunjucks templates.

Purpose: Per CONTEXT, Monaco provides VS Code-like editing experience with inline error highlighting, autocomplete for bindings, and hover documentation.

Output: Nunjucks language definition, completion provider, hover provider, and diagnostic provider.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Nunjucks language definition</name>
  <files>packages/@glyph/layout-runtime/src/monaco/nunjucks-language.ts</files>
  <action>
Define Nunjucks syntax for Monaco:

```typescript
import * as monaco from 'monaco-editor';

/**
 * Nunjucks language configuration for Monaco.
 */
export const nunjucksLanguageConfig: monaco.languages.LanguageConfiguration = {
  comments: {
    blockComment: ['{#', '#}'],
  },
  brackets: [
    ['{%', '%}'],
    ['{{', '}}'],
    ['{#', '#}'],
    ['[', ']'],
    ['(', ')'],
  ],
  autoClosingPairs: [
    { open: '{{', close: '}}' },
    { open: '{%', close: '%}' },
    { open: '{#', close: '#}' },
    { open: '"', close: '"' },
    { open: "'", close: "'" },
    { open: '(', close: ')' },
    { open: '[', close: ']' },
  ],
  surroundingPairs: [
    { open: '{{', close: '}}' },
    { open: '{%', close: '%}' },
    { open: '"', close: '"' },
    { open: "'", close: "'" },
  ],
};

/**
 * Nunjucks syntax highlighting (Monarch tokenizer).
 */
export const nunjucksTokenProvider: monaco.languages.IMonarchLanguage = {
  defaultToken: '',
  tokenPostfix: '.njk',
  
  keywords: [
    'if', 'elif', 'else', 'endif',
    'for', 'endfor', 'in',
    'block', 'endblock',
    'extends', 'include', 'import', 'from',
    'macro', 'endmacro', 'call', 'endcall',
    'set', 'endset',
    'filter', 'endfilter',
    'raw', 'endraw',
    'component', 'endcomponent',
    'not', 'and', 'or', 'is',
    'true', 'false', 'none', 'null',
  ],
  
  operators: ['==', '!=', '<=', '>=', '<', '>', '+', '-', '*', '/', '%', '|', '.'],
  
  tokenizer: {
    root: [
      // Comments
      [/\{#/, 'comment', '@comment'],
      
      // Blocks {% ... %}
      [/\{%[-]?/, { token: 'delimiter.block', next: '@block' }],
      
      // Expressions {{ ... }}
      [/\{\{[-]?/, { token: 'delimiter.expression', next: '@expression' }],
      
      // HTML content
      [/<[\w]+/, 'tag', '@tag'],
      [/<\/[\w]+>/, 'tag'],
      [/[^<{]+/, ''],
    ],
    
    comment: [
      [/#\}/, 'comment', '@pop'],
      [/./, 'comment'],
    ],
    
    block: [
      [/[-]?%\}/, { token: 'delimiter.block', next: '@pop' }],
      [/"([^"\\]|\\.)*$/, 'string.invalid'],
      [/"/, 'string', '@string_double'],
      [/'([^'\\]|\\.)*$/, 'string.invalid'],
      [/'/, 'string', '@string_single'],
      [/\d+(\.\d+)?/, 'number'],
      [/[a-zA-Z_]\w*/, {
        cases: {
          '@keywords': 'keyword',
          '@default': 'variable',
        },
      }],
      [/[|.]/, 'operator'],
      [/\s+/, ''],
    ],
    
    expression: [
      [/[-]?\}\}/, { token: 'delimiter.expression', next: '@pop' }],
      [/"([^"\\]|\\.)*$/, 'string.invalid'],
      [/"/, 'string', '@string_double'],
      [/'([^'\\]|\\.)*$/, 'string.invalid'],
      [/'/, 'string', '@string_single'],
      [/\d+(\.\d+)?/, 'number'],
      [/[a-zA-Z_][\w.]*/, {
        cases: {
          'input|output|context|config|user': 'variable.predefined',
          '@keywords': 'keyword',
          '@default': 'variable',
        },
      }],
      [/[|.]/, 'operator'],
      [/\s+/, ''],
    ],
    
    string_double: [
      [/[^\\"]+/, 'string'],
      [/\\./, 'string.escape'],
      [/"/, 'string', '@pop'],
    ],
    
    string_single: [
      [/[^\\']+/, 'string'],
      [/\\./, 'string.escape'],
      [/'/, 'string', '@pop'],
    ],
    
    tag: [
      [/>/, 'tag', '@pop'],
      [/"[^"]*"/, 'attribute.value'],
      [/'[^']*'/, 'attribute.value'],
      [/[\w-]+/, 'attribute.name'],
      [/=/, 'delimiter'],
      [/\s+/, ''],
    ],
  },
};

/**
 * Register Nunjucks language with Monaco.
 */
export function registerNunjucksLanguage() {
  monaco.languages.register({ id: 'nunjucks', extensions: ['.njk', '.html.njk'] });
  monaco.languages.setLanguageConfiguration('nunjucks', nunjucksLanguageConfig);
  monaco.languages.setMonarchTokensProvider('nunjucks', nunjucksTokenProvider);
}
```
  </action>
  <verify>Syntax highlighting works for Nunjucks templates</verify>
  <done>Nunjucks language definition created</done>
</task>

<task type="auto">
  <name>Task 2: Create completion provider</name>
  <files>packages/@glyph/layout-runtime/src/monaco/completion-provider.ts</files>
  <action>
Create autocomplete for bindings and components:

```typescript
import * as monaco from 'monaco-editor';
import type { ComponentInterface } from '@glyph/components/interfaces';

interface CompletionContext {
  inputSchema?: Record<string, unknown>;
  outputSchema?: Record<string, unknown>;
  contextSchema?: Record<string, unknown>;
  componentInterfaces: Record<string, ComponentInterface>;
}

export class NunjucksCompletionProvider implements monaco.languages.CompletionItemProvider {
  triggerCharacters = ['.', '{', '%', ' '];
  
  constructor(private context: CompletionContext) {}
  
  provideCompletionItems(
    model: monaco.editor.ITextModel,
    position: monaco.Position
  ): monaco.languages.ProviderResult<monaco.languages.CompletionList> {
    const lineContent = model.getLineContent(position.lineNumber);
    const textUntilPosition = lineContent.substring(0, position.column - 1);
    
    // Check if we're inside {{ }} (expression)
    const inExpression = this.isInExpression(textUntilPosition);
    
    // Check if we're inside {% %} (block)
    const inBlock = this.isInBlock(textUntilPosition);
    
    const suggestions: monaco.languages.CompletionItem[] = [];
    
    if (inExpression) {
      // Check if user typed a root variable
      const match = textUntilPosition.match(/(input|output|context|config|user)\.(\w*)$/);
      
      if (match) {
        // Provide property completions
        const [, root, partial] = match;
        const schema = this.getSchemaForRoot(root);
        
        if (schema && typeof schema === 'object') {
          for (const [key, value] of Object.entries(schema)) {
            if (key.startsWith(partial)) {
              suggestions.push({
                label: key,
                kind: monaco.languages.CompletionItemKind.Property,
                detail: this.getTypeString(value),
                insertText: key,
                range: this.getRange(model, position, partial.length),
              });
            }
          }
        }
      } else if (textUntilPosition.match(/\{\{[-]?\s*(\w*)$/)) {
        // Root variable completions
        suggestions.push(
          this.createRootCompletion('input', 'Task input data'),
          this.createRootCompletion('output', 'Annotation output'),
          this.createRootCompletion('context', 'Layout context'),
          this.createRootCompletion('config', 'Layout settings'),
          this.createRootCompletion('user', 'Current user'),
        );
      }
    }
    
    if (inBlock) {
      // Check for component tag
      const componentMatch = textUntilPosition.match(/\{%\s*component\s+"(\w*)$/);
      
      if (componentMatch) {
        // Component name completions
        for (const [name, iface] of Object.entries(this.context.componentInterfaces)) {
          if (name.toLowerCase().startsWith(componentMatch[1].toLowerCase())) {
            suggestions.push({
              label: name,
              kind: monaco.languages.CompletionItemKind.Class,
              detail: iface.meta.description,
              documentation: this.formatComponentDocs(iface),
              insertText: name,
              range: this.getRange(model, position, componentMatch[1].length),
            });
          }
        }
      }
      
      // Check for component props
      const propsMatch = textUntilPosition.match(/\{%\s*component\s+"(\w+)"\s+(.*)$/);
      
      if (propsMatch) {
        const componentName = propsMatch[1];
        const iface = this.context.componentInterfaces[componentName];
        
        if (iface) {
          // Already used props
          const usedProps = new Set(
            [...propsMatch[2].matchAll(/(\w+)=/g)].map(m => m[1])
          );
          
          for (const [propName, propDef] of Object.entries(iface.props)) {
            if (!usedProps.has(propName)) {
              suggestions.push({
                label: propName,
                kind: monaco.languages.CompletionItemKind.Property,
                detail: propDef.type + (propDef.required ? ' (required)' : ''),
                documentation: propDef.description,
                insertText: `${propName}=`,
                range: this.getRange(model, position, 0),
              });
            }
          }
        }
      }
      
      // Block keyword completions
      if (!componentMatch && !propsMatch) {
        const keywords = ['if', 'for', 'set', 'include', 'block', 'macro', 'component'];
        for (const kw of keywords) {
          suggestions.push({
            label: kw,
            kind: monaco.languages.CompletionItemKind.Keyword,
            insertText: kw + ' ',
            range: this.getRange(model, position, 0),
          });
        }
      }
    }
    
    return { suggestions };
  }
  
  private isInExpression(text: string): boolean {
    const lastOpen = text.lastIndexOf('{{');
    const lastClose = text.lastIndexOf('}}');
    return lastOpen > lastClose;
  }
  
  private isInBlock(text: string): boolean {
    const lastOpen = text.lastIndexOf('{%');
    const lastClose = text.lastIndexOf('%}');
    return lastOpen > lastClose;
  }
  
  private getSchemaForRoot(root: string): Record<string, unknown> | null {
    switch (root) {
      case 'input': return this.context.inputSchema ?? null;
      case 'output': return this.context.outputSchema ?? null;
      case 'context': return this.context.contextSchema ?? null;
      default: return null;
    }
  }
  
  private createRootCompletion(name: string, detail: string): monaco.languages.CompletionItem {
    return {
      label: name,
      kind: monaco.languages.CompletionItemKind.Variable,
      detail,
      insertText: name + '.',
      range: undefined as any,
    };
  }
  
  private getTypeString(schema: unknown): string {
    if (typeof schema !== 'object' || !schema) return 'unknown';
    const s = schema as Record<string, unknown>;
    return (s.type as string) || 'object';
  }
  
  private formatComponentDocs(iface: ComponentInterface): string {
    const required = Object.entries(iface.props)
      .filter(([, def]) => def.required)
      .map(([name]) => name);
    return `Required props: ${required.join(', ')}`;
  }
  
  private getRange(model: monaco.editor.ITextModel, position: monaco.Position, replaceLength: number): monaco.IRange {
    return {
      startLineNumber: position.lineNumber,
      startColumn: position.column - replaceLength,
      endLineNumber: position.lineNumber,
      endColumn: position.column,
    };
  }
}

export function registerCompletionProvider(context: CompletionContext) {
  return monaco.languages.registerCompletionItemProvider('nunjucks', new NunjucksCompletionProvider(context));
}
```
  </action>
  <verify>Autocomplete shows bindings and components</verify>
  <done>Completion provider created</done>
</task>

<task type="auto">
  <name>Task 3: Create hover and diagnostic providers</name>
  <files>
    packages/@glyph/layout-runtime/src/monaco/hover-provider.ts
    packages/@glyph/layout-runtime/src/monaco/diagnostic-provider.ts
  </files>
  <action>
**hover-provider.ts:**
```typescript
import * as monaco from 'monaco-editor';
import type { ComponentInterface } from '@glyph/components/interfaces';

interface HoverContext {
  componentInterfaces: Record<string, ComponentInterface>;
}

export class NunjucksHoverProvider implements monaco.languages.HoverProvider {
  constructor(private context: HoverContext) {}
  
  provideHover(
    model: monaco.editor.ITextModel,
    position: monaco.Position
  ): monaco.languages.ProviderResult<monaco.languages.Hover> {
    const word = model.getWordAtPosition(position);
    if (!word) return null;
    
    // Check if hovering over a component name
    const lineContent = model.getLineContent(position.lineNumber);
    const componentMatch = lineContent.match(/component\s+"(\w+)"/);
    
    if (componentMatch && word.word === componentMatch[1]) {
      const iface = this.context.componentInterfaces[word.word];
      if (iface) {
        return {
          contents: [
            { value: `**${iface.meta.name}** (${iface.meta.category})` },
            { value: iface.meta.description },
            { value: this.formatPropsTable(iface) },
          ],
          range: new monaco.Range(
            position.lineNumber,
            word.startColumn,
            position.lineNumber,
            word.endColumn
          ),
        };
      }
    }
    
    // Check for binding variables
    if (['input', 'output', 'context', 'config', 'user'].includes(word.word)) {
      return {
        contents: [{ value: this.getBindingDocs(word.word) }],
        range: new monaco.Range(
          position.lineNumber,
          word.startColumn,
          position.lineNumber,
          word.endColumn
        ),
      };
    }
    
    return null;
  }
  
  private formatPropsTable(iface: ComponentInterface): string {
    let table = '| Prop | Type | Required | Description |\n|------|------|----------|-------------|\n';
    for (const [name, def] of Object.entries(iface.props)) {
      table += `| ${name} | ${def.type} | ${def.required ? 'âœ“' : ''} | ${def.description} |\n`;
    }
    return table;
  }
  
  private getBindingDocs(root: string): string {
    const docs: Record<string, string> = {
      input: '**input** - Task input data. Read-only.\n\nAccess with `input.fieldName`',
      output: '**output** - Annotation output. Read-write.\n\nComponents write to `output.fieldName`',
      context: '**context** - Layout context. Read-only.\n\nAdditional data passed to layout',
      config: '**config** - Layout settings. Read-only.\n\nLayout configuration options',
      user: '**user** - Current user. Read-only.\n\nProperties: `id`, `name`, `role`',
    };
    return docs[root] || '';
  }
}

export function registerHoverProvider(context: HoverContext) {
  return monaco.languages.registerHoverProvider('nunjucks', new NunjucksHoverProvider(context));
}
```

**diagnostic-provider.ts:**
```typescript
import * as monaco from 'monaco-editor';
import nunjucks from 'nunjucks';
import { validateExpression } from '../nunjucks/security';

interface DiagnosticContext {
  allowedComponents?: string[];
}

/**
 * Validate Nunjucks template and return diagnostics.
 */
export function validateTemplate(
  content: string,
  context: DiagnosticContext = {}
): monaco.editor.IMarkerData[] {
  const markers: monaco.editor.IMarkerData[] = [];
  
  try {
    // Try to compile template
    nunjucks.compile(content);
  } catch (error: any) {
    // Parse Nunjucks error
    const match = error.message?.match(/line (\d+)/i);
    const line = match ? parseInt(match[1]) : 1;
    
    markers.push({
      severity: monaco.MarkerSeverity.Error,
      message: error.message || 'Template syntax error',
      startLineNumber: line,
      startColumn: 1,
      endLineNumber: line,
      endColumn: 1000,
    });
  }
  
  // Check for security issues
  const lines = content.split('\n');
  lines.forEach((line, i) => {
    // Check expression bindings
    const expressions = [...line.matchAll(/\{\{\s*([^}]+)\s*\}\}/g)];
    for (const match of expressions) {
      const expr = match[1].trim().split('|')[0].trim();
      if (!validateExpression(expr)) {
        markers.push({
          severity: monaco.MarkerSeverity.Warning,
          message: `Binding "${expr}" may not be allowed`,
          startLineNumber: i + 1,
          startColumn: match.index! + 1,
          endLineNumber: i + 1,
          endColumn: match.index! + match[0].length + 1,
        });
      }
    }
    
    // Check component names against allowlist
    if (context.allowedComponents) {
      const componentMatches = [...line.matchAll(/component\s+"(\w+)"/g)];
      for (const match of componentMatches) {
        const name = match[1];
        if (!context.allowedComponents.includes(name)) {
          markers.push({
            severity: monaco.MarkerSeverity.Error,
            message: `Component "${name}" not in allowlist`,
            startLineNumber: i + 1,
            startColumn: match.index! + 1,
            endLineNumber: i + 1,
            endColumn: match.index! + match[0].length + 1,
          });
        }
      }
    }
  });
  
  return markers;
}

/**
 * Set up diagnostic validation for editor.
 */
export function setupDiagnostics(
  editor: monaco.editor.IStandaloneCodeEditor,
  context: DiagnosticContext = {}
) {
  const model = editor.getModel();
  if (!model) return;
  
  const validate = () => {
    const content = model.getValue();
    const markers = validateTemplate(content, context);
    monaco.editor.setModelMarkers(model, 'nunjucks', markers);
  };
  
  // Validate on change (debounced)
  let timeout: NodeJS.Timeout;
  const disposable = model.onDidChangeContent(() => {
    clearTimeout(timeout);
    timeout = setTimeout(validate, 500);
  });
  
  // Initial validation
  validate();
  
  return disposable;
}
```
  </action>
  <verify>Hover shows docs, diagnostics show errors</verify>
  <done>Hover and diagnostic providers created</done>
</task>

<task type="auto">
  <name>Task 4: Export Monaco module</name>
  <files>packages/@glyph/layout-runtime/src/monaco/index.ts</files>
  <action>
```typescript
export { registerNunjucksLanguage, nunjucksLanguageConfig, nunjucksTokenProvider } from './nunjucks-language';
export { NunjucksCompletionProvider, registerCompletionProvider } from './completion-provider';
export { NunjucksHoverProvider, registerHoverProvider } from './hover-provider';
export { validateTemplate, setupDiagnostics } from './diagnostic-provider';

/**
 * Initialize all Monaco extensions for Nunjucks.
 */
export function initializeNunjucksMonaco(context: {
  inputSchema?: Record<string, unknown>;
  outputSchema?: Record<string, unknown>;
  componentInterfaces: Record<string, ComponentInterface>;
  allowedComponents?: string[];
}) {
  registerNunjucksLanguage();
  registerCompletionProvider(context);
  registerHoverProvider(context);
  
  return {
    setupDiagnostics: (editor: monaco.editor.IStandaloneCodeEditor) =>
      setupDiagnostics(editor, { allowedComponents: context.allowedComponents }),
  };
}
```
  </action>
  <verify>All Monaco extensions export correctly</verify>
  <done>Monaco module exported</done>
</task>

</tasks>

<verification>
- Nunjucks syntax highlighting colors correctly
- Typing "input." shows schema properties
- Hover over component shows documentation
- Template errors show inline
- Disallowed components show warning
</verification>

<success_criteria>
- Monaco syntax highlighting for Nunjucks
- Autocomplete for bindings and components
- Hover shows component documentation
- Inline errors for validation issues
</success_criteria>
