---
phase: 08-layout-system
plan: 12
type: execute
wave: 4
depends_on: [08-06, 08-08, 08-09, 08-10, 08-11]
files_modified:
  - packages/@glyph/layout-runtime/src/sandbox/iframe.ts
  - packages/@glyph/layout-runtime/src/sandbox/messenger.ts
  - packages/@glyph/layout-runtime/src/binding/context.tsx
  - packages/@glyph/layout-runtime/src/binding/handlers.ts
  - packages/@glyph/layout-runtime/src/renderer/LayoutRenderer.tsx
autonomous: true

must_haves:
  truths:
    - "Templates render in sandboxed iframe (security)"
    - "postMessage communication for data binding"
    - "Input/output/context variables available in templates"
    - "Change handlers auto-generated for output bindings"
  artifacts:
    - path: "packages/@glyph/layout-runtime/src/sandbox/iframe.ts"
      provides: "Secure iframe sandbox creation"
      exports: ["createSandbox", "SandboxManager"]
    - path: "packages/@glyph/layout-runtime/src/binding/context.tsx"
      provides: "Data binding context"
      exports: ["BindingProvider", "useBinding"]
---

<objective>
Implement secure template renderer with data binding.

Purpose: Per RESEARCH, Nunjucks has NO sandboxing. Templates MUST render in iframe with CSP. Data flows via postMessage. Change handlers auto-update output.

Output: Iframe sandbox manager, postMessage protocol, and data binding system.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create iframe sandbox</name>
  <files>packages/@glyph/layout-runtime/src/sandbox/iframe.ts</files>
  <action>
Create secure iframe for template rendering:

```typescript
export interface SandboxOptions {
  allowScripts?: boolean;
  csp?: string;
}

const DEFAULT_CSP = "script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self'; connect-src 'self'";

/**
 * Create a sandboxed iframe for template rendering.
 * CRITICAL: sandbox="allow-scripts" but NOT allow-same-origin
 * This prevents the iframe from accessing the parent's DOM/storage.
 */
export function createSandbox(container: HTMLElement, options: SandboxOptions = {}): HTMLIFrameElement {
  const iframe = document.createElement('iframe');
  
  // Sandbox attribute - allow scripts but NOT same-origin
  iframe.sandbox.add('allow-scripts');
  
  // Generate srcdoc with CSP
  const csp = options.csp || DEFAULT_CSP;
  iframe.srcdoc = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="${csp}">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="module">
    // Layout runtime loaded via parent postMessage
    window.addEventListener('message', async (event) => {
      const { type, payload } = event.data;
      
      if (type === 'INIT') {
        // Load runtime bundle
        const { runtimeUrl, styles } = payload;
        
        // Inject styles
        if (styles) {
          const style = document.createElement('style');
          style.textContent = styles;
          document.head.appendChild(style);
        }
        
        // Load runtime
        const runtime = await import(runtimeUrl);
        window.__layoutRuntime = runtime;
        
        parent.postMessage({ type: 'READY' }, '*');
      }
      
      if (type === 'RENDER') {
        const { template, context } = payload;
        try {
          const result = window.__layoutRuntime.render(template, context);
          document.getElementById('root').innerHTML = result;
          window.__layoutRuntime.hydrate(document.getElementById('root'));
          parent.postMessage({ type: 'RENDERED' }, '*');
        } catch (error) {
          parent.postMessage({ type: 'ERROR', error: error.message }, '*');
        }
      }
      
      if (type === 'UPDATE_CONTEXT') {
        const { path, value } = payload;
        window.__layoutRuntime.updateContext(path, value);
      }
    });
    
    // Forward output changes to parent
    window.emitChange = (field, value) => {
      parent.postMessage({ type: 'OUTPUT_CHANGE', field, value }, '*');
    };
  </script>
</body>
</html>
  `;
  
  iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
  container.appendChild(iframe);
  
  return iframe;
}

export class SandboxManager {
  private iframe: HTMLIFrameElement;
  private messageQueue: Array<{ type: string; payload: any }> = [];
  private ready = false;
  
  constructor(container: HTMLElement, options?: SandboxOptions) {
    this.iframe = createSandbox(container, options);
    
    window.addEventListener('message', this.handleMessage);
  }
  
  private handleMessage = (event: MessageEvent) => {
    if (event.source !== this.iframe.contentWindow) return;
    
    const { type } = event.data;
    
    if (type === 'READY') {
      this.ready = true;
      this.flushQueue();
    }
    
    if (type === 'OUTPUT_CHANGE') {
      this.onOutputChange?.(event.data.field, event.data.value);
    }
    
    if (type === 'ERROR') {
      this.onError?.(new Error(event.data.error));
    }
  };
  
  onOutputChange?: (field: string, value: unknown) => void;
  onError?: (error: Error) => void;
  
  init(runtimeUrl: string, styles?: string) {
    this.postMessage('INIT', { runtimeUrl, styles });
  }
  
  render(template: string, context: Record<string, unknown>) {
    this.postMessage('RENDER', { template, context });
  }
  
  updateContext(path: string, value: unknown) {
    this.postMessage('UPDATE_CONTEXT', { path, value });
  }
  
  private postMessage(type: string, payload: any) {
    if (this.ready) {
      this.iframe.contentWindow?.postMessage({ type, payload }, '*');
    } else {
      this.messageQueue.push({ type, payload });
    }
  }
  
  private flushQueue() {
    for (const msg of this.messageQueue) {
      this.iframe.contentWindow?.postMessage(msg, '*');
    }
    this.messageQueue = [];
  }
  
  destroy() {
    window.removeEventListener('message', this.handleMessage);
    this.iframe.remove();
  }
}
```
  </action>
  <verify>Iframe loads with CSP and receives messages</verify>
  <done>Sandbox iframe manager created</done>
</task>

<task type="auto">
  <name>Task 2: Create data binding context</name>
  <files>
    packages/@glyph/layout-runtime/src/binding/context.tsx
    packages/@glyph/layout-runtime/src/binding/handlers.ts
  </files>
  <action>
**context.tsx:**
```typescript
import { createContext, useContext, useCallback, ReactNode } from 'react';
import type * as Y from 'yjs';

export interface BindingContextValue {
  input: Record<string, unknown>;
  output: Y.Map<unknown>;
  context: Record<string, unknown>;
  config: Record<string, unknown>;
  user: { id: string; name: string; role: string };
  
  // Setters (for output only)
  setOutput: (field: string, value: unknown) => void;
  
  // Computed getters
  getBinding: (path: string) => unknown;
}

const BindingContext = createContext<BindingContextValue | null>(null);

export interface BindingProviderProps {
  input: Record<string, unknown>;
  outputMap: Y.Map<unknown>;
  context?: Record<string, unknown>;
  config?: Record<string, unknown>;
  user: { id: string; name: string; role: string };
  children: ReactNode;
}

export function BindingProvider({
  input,
  outputMap,
  context = {},
  config = {},
  user,
  children,
}: BindingProviderProps) {
  const setOutput = useCallback((field: string, value: unknown) => {
    outputMap.set(field, value as Y.Map<unknown>);
  }, [outputMap]);
  
  const getBinding = useCallback((path: string): unknown => {
    const [root, ...parts] = path.split('.');
    
    let source: Record<string, unknown>;
    switch (root) {
      case 'input': source = input; break;
      case 'output': source = Object.fromEntries(outputMap.entries()); break;
      case 'context': source = context; break;
      case 'config': source = config; break;
      case 'user': source = user as unknown as Record<string, unknown>; break;
      default: return undefined;
    }
    
    let current: unknown = source;
    for (const part of parts) {
      if (current == null || typeof current !== 'object') return undefined;
      current = (current as Record<string, unknown>)[part];
    }
    
    return current;
  }, [input, outputMap, context, config, user]);
  
  return (
    <BindingContext.Provider value={{
      input,
      output: outputMap,
      context,
      config,
      user,
      setOutput,
      getBinding,
    }}>
      {children}
    </BindingContext.Provider>
  );
}

export function useBinding() {
  const ctx = useContext(BindingContext);
  if (!ctx) throw new Error('useBinding must be used within BindingProvider');
  return ctx;
}

/**
 * Hook to bind a component prop to a binding path.
 */
export function useBoundValue<T>(path: string, defaultValue: T): T {
  const { getBinding } = useBinding();
  const value = getBinding(path);
  return (value as T) ?? defaultValue;
}

/**
 * Hook to get an output setter that writes to output.{field}.
 */
export function useOutputSetter(field: string) {
  const { setOutput } = useBinding();
  return useCallback((value: unknown) => setOutput(field, value), [setOutput, field]);
}
```

**handlers.ts:**
```typescript
import type { BindingContextValue } from './context';

/**
 * Generate change handler for a field.
 * Convention: on{FieldName}Change writes to output.{fieldName}
 */
export function createChangeHandler(
  fieldName: string,
  setOutput: (field: string, value: unknown) => void
) {
  return (value: unknown) => {
    setOutput(fieldName, value);
  };
}

/**
 * Auto-generate handlers for all output fields in a component.
 */
export function createHandlers(
  outputFields: string[],
  setOutput: (field: string, value: unknown) => void
): Record<string, (value: unknown) => void> {
  const handlers: Record<string, (value: unknown) => void> = {};
  
  for (const field of outputFields) {
    const handlerName = `on${field.charAt(0).toUpperCase()}${field.slice(1)}Change`;
    handlers[handlerName] = createChangeHandler(field, setOutput);
  }
  
  return handlers;
}

/**
 * Parse binding expression and extract field name.
 * e.g., "output.entities" -> "entities"
 */
export function extractOutputField(bindingPath: string): string | null {
  if (!bindingPath.startsWith('output.')) return null;
  return bindingPath.slice(7); // Remove "output."
}
```
  </action>
  <verify>Binding context provides input/output access</verify>
  <done>Data binding context created</done>
</task>

<task type="auto">
  <name>Task 3: Create layout renderer component</name>
  <files>packages/@glyph/layout-runtime/src/renderer/LayoutRenderer.tsx</files>
  <action>
Create the main layout rendering component:

```typescript
import { useEffect, useRef, useState, useMemo } from 'react';
import { SandboxManager } from '../sandbox/iframe';
import { createNunjucksEnv } from '../nunjucks/environment';
import { BindingProvider, useBinding } from '../binding/context';
import { useResolver, RegistryProvider } from '../registry';
import { SyncProvider } from '../sync';
import { UndoProvider } from '../undo';
import type { Layout, LayoutSettings } from '../validation';

export interface LayoutRendererProps {
  layout: Layout;
  taskId: string;
  input: Record<string, unknown>;
  userId: string;
  userName: string;
  wsUrl: string;
  onSubmit: (output: Record<string, unknown>) => void;
  onSkip?: () => void;
}

export function LayoutRenderer({
  layout,
  taskId,
  input,
  userId,
  userName,
  wsUrl,
  onSubmit,
  onSkip,
}: LayoutRendererProps) {
  // If using iframe sandbox (for Nunjucks templates)
  if (layout.template === 'nunjucks') {
    return (
      <SandboxedRenderer
        layout={layout}
        taskId={taskId}
        input={input}
        userId={userId}
        userName={userName}
        wsUrl={wsUrl}
        onSubmit={onSubmit}
        onSkip={onSkip}
      />
    );
  }
  
  // For TSX templates, render directly (trusted templates only)
  return (
    <DirectRenderer
      layout={layout}
      taskId={taskId}
      input={input}
      userId={userId}
      userName={userName}
      wsUrl={wsUrl}
      onSubmit={onSubmit}
      onSkip={onSkip}
    />
  );
}

function SandboxedRenderer(props: LayoutRendererProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const sandboxRef = useRef<SandboxManager | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
    
    const sandbox = new SandboxManager(containerRef.current, {
      csp: props.layout.settings?.custom_css 
        ? "script-src 'self'; style-src 'self' 'unsafe-inline';"
        : undefined,
    });
    
    sandboxRef.current = sandbox;
    
    sandbox.onOutputChange = (field, value) => {
      // Update Y.js output map
      // This is handled by the sync context
    };
    
    sandbox.onError = (err) => {
      setError(err.message);
    };
    
    // Initialize sandbox
    sandbox.init('/layout-runtime.js', props.layout.settings?.custom_css);
    
    // Render template
    sandbox.render(props.layout.content, {
      input: props.input,
      output: {},
      context: {},
      config: props.layout.settings || {},
      user: { id: props.userId, name: props.userName },
    });
    
    return () => sandbox.destroy();
  }, [props.layout.content, props.input]);
  
  if (error) {
    return (
      <div className="p-4 bg-destructive/10 border border-destructive rounded-lg">
        <h3 className="font-semibold text-destructive">Template Error</h3>
        <pre className="mt-2 text-sm overflow-auto">{error}</pre>
      </div>
    );
  }
  
  return (
    <div ref={containerRef} className="w-full h-full min-h-[400px]" />
  );
}

function DirectRenderer(props: LayoutRendererProps) {
  // For TSX templates - render React directly with providers
  return (
    <SyncProvider options={{
      taskId: props.taskId,
      wsUrl: props.wsUrl,
      userId: props.userId,
      userName: props.userName,
    }}>
      <RegistryProvider resolverOptions={{ allowedComponents: props.layout.components }}>
        <BindingProvider
          input={props.input}
          outputMap={/* Y.js map from sync */}
          config={props.layout.settings || {}}
          user={{ id: props.userId, name: props.userName, role: 'annotator' }}
        >
          <UndoProvider outputMap={/* Y.js map */}>
            {/* Render TSX template */}
            <LayoutContent 
              content={props.layout.content} 
              onSubmit={props.onSubmit}
              onSkip={props.onSkip}
            />
          </UndoProvider>
        </BindingProvider>
      </RegistryProvider>
    </SyncProvider>
  );
}

function LayoutContent({ 
  content, 
  onSubmit, 
  onSkip 
}: { 
  content: string; 
  onSubmit: (output: Record<string, unknown>) => void;
  onSkip?: () => void;
}) {
  const { output } = useBinding();
  const resolver = useResolver();
  
  // Dynamic component rendering based on content
  // For TSX, this would be a pre-compiled React component
  
  const handleSubmit = () => {
    const outputData = Object.fromEntries(output.entries());
    onSubmit(outputData);
  };
  
  return (
    <div className="layout-container">
      {/* Template content rendered here */}
      <div className="layout-actions mt-4 flex gap-2">
        {onSkip && (
          <button onClick={onSkip} className="px-4 py-2 border rounded">
            Skip
          </button>
        )}
        <button onClick={handleSubmit} className="px-4 py-2 bg-primary text-primary-foreground rounded">
          Submit
        </button>
      </div>
    </div>
  );
}
```
  </action>
  <verify>LayoutRenderer renders templates in sandbox</verify>
  <done>Layout renderer component created</done>
</task>

<task type="auto">
  <name>Task 4: Export renderer module</name>
  <files>
    packages/@glyph/layout-runtime/src/renderer/index.ts
    packages/@glyph/layout-runtime/src/index.ts
  </files>
  <action>
**renderer/index.ts:**
```typescript
export { LayoutRenderer, type LayoutRendererProps } from './LayoutRenderer';
```

**Update src/index.ts:**
```typescript
export * from './shortcuts';
export * from './undo';
export * from './validation';
export * from './sync';
export * from './registry';
export * from './nunjucks';
export * from './binding';
export * from './sandbox';
export * from './renderer';
```
  </action>
  <verify>All modules export correctly</verify>
  <done>Renderer module exported</done>
</task>

</tasks>

<verification>
- Iframe loads with CSP headers
- postMessage sends/receives correctly
- Input data available in templates
- Output changes propagate to parent
- Change handlers auto-generated
</verification>

<success_criteria>
- Templates render in sandboxed iframe
- postMessage communication works
- Input/output/context available in templates
- Change handlers auto-generated for output
</success_criteria>
