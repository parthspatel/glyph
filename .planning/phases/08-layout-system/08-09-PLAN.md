---
phase: 08-layout-system
plan: 09
type: execute
wave: 3
depends_on: [08-05]
files_modified:
  - packages/@glyph/components/src/annotation/Classification.tsx
  - packages/@glyph/components/src/annotation/BoundingBox.tsx
  - packages/@glyph/components/src/annotation/Relation.tsx
  - packages/@glyph/components/src/annotation/AudioSegment.tsx
  - packages/@glyph/components/src/annotation/index.ts
autonomous: true

must_haves:
  truths:
    - "Classification supports single and multiple selection"
    - "BoundingBox renders boxes on images with handles"
    - "All components use props-only data flow"
    - "All components emit changes via on{FieldName}Change"
  artifacts:
    - path: "packages/@glyph/components/src/annotation/Classification.tsx"
      provides: "Classification annotation component"
      exports: ["Classification", "ClassificationProps"]
    - path: "packages/@glyph/components/src/annotation/BoundingBox.tsx"
      provides: "Image bounding box annotation"
      exports: ["BoundingBox", "BoundingBoxProps"]
---

<objective>
Implement remaining annotation components: Classification, BoundingBox, Relation, AudioSegment.

Purpose: These are the core annotation components per REQ-LAYOUT-002. All follow WASM-compatible interface contract (props-only, serializable callbacks).

Output: Four annotation components with keyboard shortcuts and accessibility.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@packages/@glyph/components/src/interfaces/annotation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Classification component</name>
  <files>packages/@glyph/components/src/annotation/Classification.tsx</files>
  <action>
Create classification/labeling component:

```typescript
import { useState, useEffect, useCallback } from 'react';
import { cn } from '@/lib/utils';

export interface ClassificationOption {
  id: string;
  label: string;
  description?: string;
  shortcut?: string;  // e.g., '1', '2', '3'
}

export interface ClassificationProps {
  options: ClassificationOption[];
  value: string | string[];  // Single or multiple selection
  onChange: (value: string | string[]) => void;
  multiple?: boolean;
  required?: boolean;
  readOnly?: boolean;
  enableHotkeys?: boolean;
  shortcuts?: Record<string, string>;  // option id -> key
  layout?: 'horizontal' | 'vertical' | 'grid';
}

export function Classification({
  options,
  value,
  onChange,
  multiple = false,
  required = false,
  readOnly = false,
  enableHotkeys = true,
  shortcuts = {},
  layout = 'vertical',
}: ClassificationProps) {
  const selectedIds = Array.isArray(value) ? value : value ? [value] : [];
  
  const toggleOption = useCallback((optionId: string) => {
    if (readOnly) return;
    
    if (multiple) {
      const newValue = selectedIds.includes(optionId)
        ? selectedIds.filter(id => id !== optionId)
        : [...selectedIds, optionId];
      onChange(newValue);
    } else {
      onChange(optionId);
    }
  }, [readOnly, multiple, selectedIds, onChange]);
  
  // Keyboard shortcuts
  useEffect(() => {
    if (!enableHotkeys || readOnly) return;
    
    const handleKeyDown = (e: KeyboardEvent) => {
      // Check number keys 1-9
      if (e.key >= '1' && e.key <= '9') {
        const index = parseInt(e.key) - 1;
        if (options[index]) {
          e.preventDefault();
          toggleOption(options[index].id);
        }
      }
      
      // Check custom shortcuts
      for (const [optionId, key] of Object.entries(shortcuts)) {
        if (e.key.toLowerCase() === key.toLowerCase()) {
          e.preventDefault();
          toggleOption(optionId);
        }
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [enableHotkeys, readOnly, options, shortcuts, toggleOption]);
  
  const layoutClasses = {
    horizontal: 'flex flex-row flex-wrap gap-2',
    vertical: 'flex flex-col gap-2',
    grid: 'grid grid-cols-2 md:grid-cols-3 gap-2',
  };
  
  return (
    <div 
      className={cn(layoutClasses[layout])}
      role="group"
      aria-label="Classification options"
    >
      {options.map((option, index) => {
        const isSelected = selectedIds.includes(option.id);
        const shortcut = option.shortcut || shortcuts[option.id] || (index < 9 ? String(index + 1) : undefined);
        
        return (
          <button
            key={option.id}
            type="button"
            role={multiple ? 'checkbox' : 'radio'}
            aria-checked={isSelected}
            disabled={readOnly}
            onClick={() => toggleOption(option.id)}
            className={cn(
              'flex items-center gap-3 p-3 rounded-lg border transition-colors text-left',
              'hover:bg-accent focus:outline-none focus:ring-2 focus:ring-primary',
              isSelected ? 'border-primary bg-primary/10' : 'border-border',
              readOnly && 'opacity-60 cursor-not-allowed'
            )}
          >
            <div className={cn(
              'w-5 h-5 rounded-full border-2 flex items-center justify-center',
              multiple ? 'rounded-md' : 'rounded-full',
              isSelected ? 'border-primary bg-primary' : 'border-muted-foreground'
            )}>
              {isSelected && (
                <svg className="w-3 h-3 text-primary-foreground" fill="currentColor" viewBox="0 0 12 12">
                  <path d="M10.28 2.28L4.5 8.06 1.72 5.28a.75.75 0 0 0-1.06 1.06l3.5 3.5a.75.75 0 0 0 1.06 0l6.5-6.5a.75.75 0 0 0-1.06-1.06z"/>
                </svg>
              )}
            </div>
            
            <div className="flex-1">
              <div className="font-medium">{option.label}</div>
              {option.description && (
                <div className="text-sm text-muted-foreground">{option.description}</div>
              )}
            </div>
            
            {shortcut && enableHotkeys && (
              <kbd className="px-2 py-0.5 text-xs rounded bg-muted text-muted-foreground">
                {shortcut}
              </kbd>
            )}
          </button>
        );
      })}
      
      {required && selectedIds.length === 0 && (
        <p className="text-sm text-destructive" role="alert">
          Please select {multiple ? 'at least one option' : 'an option'}
        </p>
      )}
    </div>
  );
}
```
  </action>
  <verify>Classification handles single and multiple selection</verify>
  <done>Classification component created</done>
</task>

<task type="auto">
  <name>Task 2: Create BoundingBox component</name>
  <files>packages/@glyph/components/src/annotation/BoundingBox.tsx</files>
  <action>
Create image bounding box annotation:

```typescript
import { useState, useRef, useCallback, useEffect } from 'react';
import { cn } from '@/lib/utils';

export interface Box {
  id: string;
  label: string;
  x: number;      // 0-1 relative to image
  y: number;      // 0-1 relative to image
  width: number;  // 0-1 relative to image
  height: number; // 0-1 relative to image
}

export interface BoxLabel {
  id: string;
  name: string;
  color: string;
  shortcut?: string;
}

export interface BoundingBoxProps {
  imageUrl: string;
  boxes: Box[];
  onChange: (boxes: Box[]) => void;
  labels: BoxLabel[];
  selectedBoxId?: string;
  onSelectBox?: (boxId: string | null) => void;
  allowOverlapping?: boolean;
  readOnly?: boolean;
  enableHotkeys?: boolean;
}

export function BoundingBox({
  imageUrl,
  boxes,
  onChange,
  labels,
  selectedBoxId,
  onSelectBox,
  allowOverlapping = true,
  readOnly = false,
  enableHotkeys = true,
}: BoundingBoxProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [drawStart, setDrawStart] = useState<{ x: number; y: number } | null>(null);
  const [currentBox, setCurrentBox] = useState<Partial<Box> | null>(null);
  const [activeLabel, setActiveLabel] = useState(labels[0]?.id ?? '');
  const [imageSize, setImageSize] = useState({ width: 0, height: 0 });
  
  // Convert pixel coordinates to relative
  const toRelative = useCallback((px: number, py: number) => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return { x: 0, y: 0 };
    return {
      x: (px - rect.left) / rect.width,
      y: (py - rect.top) / rect.height,
    };
  }, []);
  
  // Start drawing
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (readOnly || e.button !== 0) return;
    
    const { x, y } = toRelative(e.clientX, e.clientY);
    setIsDrawing(true);
    setDrawStart({ x, y });
    setCurrentBox({ x, y, width: 0, height: 0, label: activeLabel });
  }, [readOnly, toRelative, activeLabel]);
  
  // Update drawing
  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isDrawing || !drawStart) return;
    
    const { x, y } = toRelative(e.clientX, e.clientY);
    setCurrentBox({
      x: Math.min(drawStart.x, x),
      y: Math.min(drawStart.y, y),
      width: Math.abs(x - drawStart.x),
      height: Math.abs(y - drawStart.y),
      label: activeLabel,
    });
  }, [isDrawing, drawStart, toRelative, activeLabel]);
  
  // Finish drawing
  const handleMouseUp = useCallback(() => {
    if (!isDrawing || !currentBox) return;
    
    setIsDrawing(false);
    setDrawStart(null);
    
    // Only add if box has meaningful size
    if (currentBox.width && currentBox.width > 0.01 && currentBox.height && currentBox.height > 0.01) {
      const newBox: Box = {
        id: crypto.randomUUID(),
        label: currentBox.label!,
        x: currentBox.x!,
        y: currentBox.y!,
        width: currentBox.width,
        height: currentBox.height,
      };
      onChange([...boxes, newBox]);
    }
    
    setCurrentBox(null);
  }, [isDrawing, currentBox, boxes, onChange]);
  
  // Delete selected box
  const deleteSelected = useCallback(() => {
    if (readOnly || !selectedBoxId) return;
    onChange(boxes.filter(b => b.id !== selectedBoxId));
    onSelectBox?.(null);
  }, [readOnly, selectedBoxId, boxes, onChange, onSelectBox]);
  
  // Keyboard shortcuts
  useEffect(() => {
    if (!enableHotkeys) return;
    
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Backspace' || e.key === 'Delete') {
        e.preventDefault();
        deleteSelected();
      }
      
      // Number keys for label selection
      if (e.key >= '1' && e.key <= '9') {
        const index = parseInt(e.key) - 1;
        if (labels[index]) {
          setActiveLabel(labels[index].id);
        }
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [enableHotkeys, deleteSelected, labels]);
  
  return (
    <div className="flex flex-col gap-4">
      {/* Label selector */}
      <div className="flex gap-2 flex-wrap">
        {labels.map((label, index) => (
          <button
            key={label.id}
            onClick={() => setActiveLabel(label.id)}
            className={cn(
              'px-3 py-1 rounded text-sm flex items-center gap-2',
              activeLabel === label.id ? 'ring-2 ring-primary' : ''
            )}
            style={{ backgroundColor: `${label.color}40` }}
          >
            <span className="w-3 h-3 rounded" style={{ backgroundColor: label.color }} />
            {label.name}
            {enableHotkeys && index < 9 && (
              <kbd className="text-xs opacity-60">{index + 1}</kbd>
            )}
          </button>
        ))}
      </div>
      
      {/* Image canvas */}
      <div
        ref={containerRef}
        className="relative cursor-crosshair select-none"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      >
        <img
          src={imageUrl}
          alt="Annotation target"
          className="w-full h-auto"
          onLoad={(e) => setImageSize({ 
            width: e.currentTarget.naturalWidth, 
            height: e.currentTarget.naturalHeight 
          })}
          draggable={false}
        />
        
        {/* Existing boxes */}
        {boxes.map(box => {
          const label = labels.find(l => l.id === box.label);
          const isSelected = box.id === selectedBoxId;
          
          return (
            <div
              key={box.id}
              className={cn(
                'absolute border-2 cursor-pointer',
                isSelected ? 'ring-2 ring-white' : ''
              )}
              style={{
                left: `${box.x * 100}%`,
                top: `${box.y * 100}%`,
                width: `${box.width * 100}%`,
                height: `${box.height * 100}%`,
                borderColor: label?.color,
                backgroundColor: `${label?.color}20`,
              }}
              onClick={(e) => {
                e.stopPropagation();
                onSelectBox?.(box.id);
              }}
            >
              <span
                className="absolute -top-6 left-0 px-1 text-xs text-white rounded"
                style={{ backgroundColor: label?.color }}
              >
                {label?.name}
              </span>
            </div>
          );
        })}
        
        {/* Current drawing */}
        {currentBox && currentBox.width && currentBox.height && (
          <div
            className="absolute border-2 border-dashed pointer-events-none"
            style={{
              left: `${currentBox.x! * 100}%`,
              top: `${currentBox.y! * 100}%`,
              width: `${currentBox.width * 100}%`,
              height: `${currentBox.height * 100}%`,
              borderColor: labels.find(l => l.id === activeLabel)?.color,
            }}
          />
        )}
      </div>
    </div>
  );
}
```
  </action>
  <verify>BoundingBox draws and resizes boxes</verify>
  <done>BoundingBox component created</done>
</task>

<task type="auto">
  <name>Task 3: Create Relation and AudioSegment components</name>
  <files>
    packages/@glyph/components/src/annotation/Relation.tsx
    packages/@glyph/components/src/annotation/AudioSegment.tsx
  </files>
  <action>
**Relation.tsx** - For linking entities with relationship types:
- Renders entities as nodes
- Draw arrows between related entities
- Click entity, then click another to create relation
- Dropdown for relation type selection

**AudioSegment.tsx** - For audio time range annotation:
- Audio waveform display (use wavesurfer.js or similar)
- Click-drag to create time segments
- Segment labels with time display
- Playback controls

Both follow same patterns:
- Props-only data flow
- onChange callback with serializable data
- Keyboard shortcuts via enableHotkeys
- Accessibility with ARIA roles
  </action>
  <verify>Components render and emit changes</verify>
  <done>Relation and AudioSegment components created</done>
</task>

<task type="auto">
  <name>Task 4: Export annotation components</name>
  <files>packages/@glyph/components/src/annotation/index.ts</files>
  <action>
Update index to export all annotation components:

```typescript
export { NERTagger, type NERTaggerProps, type Entity, type EntityType } from './NERTagger';
export { Classification, type ClassificationProps, type ClassificationOption } from './Classification';
export { BoundingBox, type BoundingBoxProps, type Box, type BoxLabel } from './BoundingBox';
export { Relation, type RelationProps } from './Relation';
export { AudioSegment, type AudioSegmentProps } from './AudioSegment';
```
  </action>
  <verify>All annotation components export correctly</verify>
  <done>Annotation module exports complete</done>
</task>

</tasks>

<verification>
- Classification single/multiple selection works
- BoundingBox draw, resize, delete boxes
- All components receive props, emit via callbacks
- Keyboard shortcuts work when enabled
- Screen reader announces state changes
</verification>

<success_criteria>
- Classification supports single and multiple selection
- BoundingBox renders boxes with handles
- Props-only data flow for all components
- Serializable callback events
</success_criteria>
