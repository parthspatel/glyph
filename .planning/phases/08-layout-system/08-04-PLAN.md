---
phase: 08-layout-system
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/@glyph/layout-runtime/src/sync/provider.ts
  - packages/@glyph/layout-runtime/src/sync/awareness.ts
  - packages/@glyph/layout-runtime/src/sync/hooks.ts
  - packages/@glyph/layout-runtime/src/sync/offline.ts
autonomous: true

must_haves:
  truths:
    - "Y.js CRDT syncs annotation state across tabs/devices"
    - "Awareness API tracks user presence (cursors, selection)"
    - "Changes persist offline via IndexedDB"
    - "Awareness state cleaned up on disconnect (no memory leak)"
  artifacts:
    - path: "packages/@glyph/layout-runtime/src/sync/provider.ts"
      provides: "Y.js document and WebSocket provider"
      exports: ["SyncProvider", "useSyncProvider"]
    - path: "packages/@glyph/layout-runtime/src/sync/awareness.ts"
      provides: "User presence tracking"
      exports: ["useAwareness", "AwarenessState"]
---

<objective>
Implement Y.js-based real-time sync for annotation collaboration.

Purpose: Per CONTEXT decisions, changes sync immediately across tabs/devices (like Google Docs). Y.js is the fastest CRDT (10x faster than Automerge) per RESEARCH.

Output: Y.js document provider, WebSocket sync, awareness (presence), and IndexedDB offline persistence.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Y.js sync provider</name>
  <files>packages/@glyph/layout-runtime/src/sync/provider.ts</files>
  <action>
Install dependencies: `pnpm add yjs y-websocket y-indexeddb`

Create sync provider:

```typescript
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';
import { IndexeddbPersistence } from 'y-indexeddb';

interface SyncProviderOptions {
  taskId: string;
  wsUrl: string;  // e.g., wss://glyph.example.com/sync
  userId: string;
  userName: string;
  userColor?: string;
}

export function createSyncProvider(options: SyncProviderOptions) {
  const doc = new Y.Doc();
  const outputMap = doc.getMap<Y.Map<unknown>>('output');
  
  // WebSocket provider for real-time sync
  const wsProvider = new WebsocketProvider(
    options.wsUrl,
    `task:${options.taskId}`,
    doc,
    { connect: true }
  );

  // IndexedDB for offline persistence
  const idbProvider = new IndexeddbPersistence(
    `glyph:task:${options.taskId}`,
    doc
  );

  // Set user awareness state
  wsProvider.awareness.setLocalState({
    user: {
      id: options.userId,
      name: options.userName,
      color: options.userColor || generateColor(options.userId),
    },
    cursor: null,
    selection: null,
  });

  return {
    doc,
    outputMap,
    awareness: wsProvider.awareness,
    wsProvider,
    idbProvider,
    
    // Connection state
    get connected() { return wsProvider.wsconnected; },
    get synced() { return wsProvider.synced; },
    
    // Cleanup
    destroy: () => {
      // CRITICAL: Clear awareness to prevent memory leak
      wsProvider.awareness.setLocalState(null);
      wsProvider.destroy();
      idbProvider.destroy();
      doc.destroy();
    },
  };
}

function generateColor(seed: string): string {
  // Generate consistent color from user ID
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    hash = seed.charCodeAt(i) + ((hash << 5) - hash);
  }
  const h = hash % 360;
  return `hsl(${h}, 70%, 60%)`;
}
```
  </action>
  <verify>Y.Doc syncs between two browser tabs</verify>
  <done>Sync provider created with WebSocket and IndexedDB</done>
</task>

<task type="auto">
  <name>Task 2: Create awareness hooks</name>
  <files>packages/@glyph/layout-runtime/src/sync/awareness.ts</files>
  <action>
Create hooks for tracking user presence:

```typescript
import { useState, useEffect } from 'react';
import type { Awareness } from 'y-protocols/awareness';

export interface UserState {
  id: string;
  name: string;
  color: string;
}

export interface AwarenessState {
  user: UserState;
  cursor?: { x: number; y: number } | null;
  selection?: { start: number; end: number } | null;
  activeComponent?: string | null;
}

/**
 * Hook to track all users' awareness state.
 */
export function useAwareness(awareness: Awareness) {
  const [states, setStates] = useState<Map<number, AwarenessState>>(new Map());

  useEffect(() => {
    const update = () => {
      const newStates = new Map<number, AwarenessState>();
      awareness.getStates().forEach((state, clientId) => {
        if (state && clientId !== awareness.clientID) {
          newStates.set(clientId, state as AwarenessState);
        }
      });
      setStates(newStates);
    };

    awareness.on('change', update);
    update(); // Initial state

    return () => {
      awareness.off('change', update);
    };
  }, [awareness]);

  return states;
}

/**
 * Hook to update local user's awareness state.
 */
export function useLocalAwareness(awareness: Awareness) {
  const updateCursor = (cursor: { x: number; y: number } | null) => {
    const current = awareness.getLocalState() as AwarenessState | null;
    awareness.setLocalStateField('cursor', cursor);
  };

  const updateSelection = (selection: { start: number; end: number } | null) => {
    awareness.setLocalStateField('selection', selection);
  };

  const updateActiveComponent = (componentId: string | null) => {
    awareness.setLocalStateField('activeComponent', componentId);
  };

  return { updateCursor, updateSelection, updateActiveComponent };
}

/**
 * Get remote users (excluding self).
 */
export function useRemoteUsers(awareness: Awareness): UserState[] {
  const states = useAwareness(awareness);
  return Array.from(states.values())
    .filter(s => s.user)
    .map(s => s.user);
}
```
  </action>
  <verify>useAwareness updates when remote user state changes</verify>
  <done>Awareness hooks created for presence tracking</done>
</task>

<task type="auto">
  <name>Task 3: Create React context and hooks</name>
  <files>packages/@glyph/layout-runtime/src/sync/hooks.ts</files>
  <action>
Create convenient React integration:

```typescript
import { createContext, useContext, useEffect, useMemo, useState, ReactNode } from 'react';
import type * as Y from 'yjs';
import { createSyncProvider, type SyncProviderOptions } from './provider';

interface SyncContextValue {
  outputMap: Y.Map<unknown>;
  awareness: Awareness;
  connected: boolean;
  synced: boolean;
  pendingChanges: number;
}

const SyncContext = createContext<SyncContextValue | null>(null);

export function SyncProvider({ 
  options, 
  children 
}: { 
  options: SyncProviderOptions; 
  children: ReactNode 
}) {
  const provider = useMemo(() => createSyncProvider(options), [options.taskId]);
  const [connected, setConnected] = useState(false);
  const [synced, setSynced] = useState(false);
  const [pendingChanges, setPendingChanges] = useState(0);

  useEffect(() => {
    // Track connection state
    provider.wsProvider.on('status', ({ status }: { status: string }) => {
      setConnected(status === 'connected');
    });
    provider.wsProvider.on('sync', (synced: boolean) => {
      setSynced(synced);
    });

    // Track pending changes (offline indicator)
    const checkPending = () => {
      // Count unsynced updates
      const pending = provider.doc.clientID; // Simplified
      setPendingChanges(pending > 0 ? 1 : 0);
    };
    provider.doc.on('update', checkPending);

    return () => {
      provider.destroy();
    };
  }, [provider]);

  return (
    <SyncContext.Provider value={{
      outputMap: provider.outputMap,
      awareness: provider.awareness,
      connected,
      synced,
      pendingChanges,
    }}>
      {children}
    </SyncContext.Provider>
  );
}

export function useSync() {
  const context = useContext(SyncContext);
  if (!context) throw new Error('useSync must be used within SyncProvider');
  return context;
}

/**
 * Hook to read and write a specific output field.
 */
export function useOutputField<T>(field: string, defaultValue: T): [T, (value: T) => void] {
  const { outputMap } = useSync();
  const [value, setValue] = useState<T>(() => (outputMap.get(field) as T) ?? defaultValue);

  useEffect(() => {
    const observer = () => {
      setValue((outputMap.get(field) as T) ?? defaultValue);
    };
    outputMap.observe(observer);
    return () => outputMap.unobserve(observer);
  }, [outputMap, field, defaultValue]);

  const setOutputValue = (newValue: T) => {
    outputMap.set(field, newValue as unknown as Y.Map<unknown>);
  };

  return [value, setOutputValue];
}
```
  </action>
  <verify>useOutputField syncs value between tabs</verify>
  <done>React sync context and hooks created</done>
</task>

<task type="auto">
  <name>Task 4: Export sync module</name>
  <files>
    packages/@glyph/layout-runtime/src/sync/index.ts
    packages/@glyph/layout-runtime/src/index.ts
  </files>
  <action>
**sync/index.ts:**
```typescript
export { createSyncProvider, type SyncProviderOptions } from './provider';
export { useAwareness, useLocalAwareness, useRemoteUsers, type AwarenessState, type UserState } from './awareness';
export { SyncProvider, useSync, useOutputField } from './hooks';
```

**Update src/index.ts:**
```typescript
export * from './shortcuts';
export * from './undo';
export * from './validation';
export * from './sync';
```
  </action>
  <verify>Sync exports work correctly</verify>
  <done>Sync module exported from package</done>
</task>

</tasks>

<verification>
- Y.js document syncs between browser tabs
- Awareness shows remote users' cursors/selections
- Changes persist offline in IndexedDB
- Awareness state null'd on disconnect (check memory)
- Connection status indicator updates correctly
</verification>

<success_criteria>
- Real-time sync works across tabs/devices
- User presence shows other annotators
- Offline changes persist and sync on reconnect
- No awareness memory leak on disconnect
</success_criteria>
