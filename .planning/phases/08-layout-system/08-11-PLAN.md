---
phase: 08-layout-system
plan: 11
type: execute
wave: 3
depends_on: [08-05]
files_modified:
  - packages/@glyph/components/src/display/TextDisplay.tsx
  - packages/@glyph/components/src/display/ImageViewer.tsx
  - packages/@glyph/components/src/display/PDFViewer.tsx
  - packages/@glyph/components/src/display/index.ts
  - packages/@glyph/components/src/control/Show.tsx
  - packages/@glyph/components/src/control/ForEach.tsx
  - packages/@glyph/components/src/control/Button.tsx
  - packages/@glyph/components/src/control/index.ts
autonomous: true

must_haves:
  truths:
    - "Display components render various media types"
    - "Control components enable conditional and iterative rendering"
    - "Show component evaluates boolean conditions"
    - "ForEach component iterates over arrays"
  artifacts:
    - path: "packages/@glyph/components/src/display/index.ts"
      provides: "Display components"
      exports: ["TextDisplay", "ImageViewer", "PDFViewer", "AudioPlayer"]
    - path: "packages/@glyph/components/src/control/index.ts"
      provides: "Control flow components"
      exports: ["Show", "ForEach", "Switch", "Button"]
---

<objective>
Implement display and control flow components.

Purpose: Display components show task input (text, images, PDFs, audio). Control components enable template logic (conditional rendering, iteration).

Output: Media viewers and control flow components for templates.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@packages/@glyph/components/src/interfaces/display.ts
@packages/@glyph/components/src/interfaces/control.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create display components</name>
  <files>
    packages/@glyph/components/src/display/TextDisplay.tsx
    packages/@glyph/components/src/display/ImageViewer.tsx
    packages/@glyph/components/src/display/PDFViewer.tsx
  </files>
  <action>
**TextDisplay.tsx:**
```typescript
import { useMemo } from 'react';
import { cn } from '@/lib/utils';

export interface HighlightRange {
  start: number;
  end: number;
  color?: string;
  label?: string;
}

export interface TextDisplayProps {
  text: string;
  format?: 'plain' | 'markdown' | 'html';
  highlightRanges?: HighlightRange[];
  className?: string;
}

export function TextDisplay({
  text,
  format = 'plain',
  highlightRanges = [],
  className,
}: TextDisplayProps) {
  const content = useMemo(() => {
    if (format === 'markdown') {
      // Use marked or similar for markdown
      return renderMarkdown(text);
    }
    if (format === 'html') {
      return { __html: sanitizeHtml(text) };
    }
    return text;
  }, [text, format]);
  
  const renderedWithHighlights = useMemo(() => {
    if (highlightRanges.length === 0 || format !== 'plain') {
      return null;
    }
    
    // Sort highlights by start position
    const sorted = [...highlightRanges].sort((a, b) => a.start - b.start);
    const segments: React.ReactNode[] = [];
    let lastEnd = 0;
    
    sorted.forEach((range, i) => {
      // Add text before highlight
      if (range.start > lastEnd) {
        segments.push(
          <span key={`text-${i}`}>{text.slice(lastEnd, range.start)}</span>
        );
      }
      
      // Add highlighted text
      segments.push(
        <mark
          key={`hl-${i}`}
          className="px-0.5 rounded"
          style={{ backgroundColor: range.color || 'yellow' }}
          title={range.label}
        >
          {text.slice(range.start, range.end)}
        </mark>
      );
      
      lastEnd = range.end;
    });
    
    // Add remaining text
    if (lastEnd < text.length) {
      segments.push(<span key="text-end">{text.slice(lastEnd)}</span>);
    }
    
    return segments;
  }, [text, highlightRanges, format]);
  
  if (format === 'html') {
    return (
      <div 
        className={cn('prose dark:prose-invert max-w-none', className)}
        dangerouslySetInnerHTML={content as { __html: string }}
      />
    );
  }
  
  if (format === 'markdown') {
    return (
      <div 
        className={cn('prose dark:prose-invert max-w-none', className)}
        dangerouslySetInnerHTML={{ __html: content as string }}
      />
    );
  }
  
  return (
    <div className={cn('whitespace-pre-wrap font-mono text-sm', className)}>
      {renderedWithHighlights || text}
    </div>
  );
}

function renderMarkdown(text: string): string {
  // Placeholder - use marked.js in actual implementation
  return text
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/\n/g, '<br/>');
}

function sanitizeHtml(html: string): string {
  // Placeholder - use DOMPurify in actual implementation
  return html;
}
```

**ImageViewer.tsx:**
```typescript
import { useState, useRef, useEffect } from 'react';
import { cn } from '@/lib/utils';
import { ZoomIn, ZoomOut, RotateCw, Maximize2 } from 'lucide-react';

export interface ImageViewerProps {
  src: string;
  alt?: string;
  zoom?: number;
  fit?: 'contain' | 'cover' | 'none';
  enableControls?: boolean;
  className?: string;
}

export function ImageViewer({
  src,
  alt = 'Image',
  zoom: initialZoom = 1,
  fit = 'contain',
  enableControls = true,
  className,
}: ImageViewerProps) {
  const [zoom, setZoom] = useState(initialZoom);
  const [rotation, setRotation] = useState(0);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  
  const zoomIn = () => setZoom(z => Math.min(z * 1.25, 5));
  const zoomOut = () => setZoom(z => Math.max(z / 1.25, 0.25));
  const rotate = () => setRotation(r => (r + 90) % 360);
  const reset = () => {
    setZoom(1);
    setRotation(0);
    setPan({ x: 0, y: 0 });
  };
  
  // Pan handling
  const handleMouseDown = (e: React.MouseEvent) => {
    if (zoom > 1) {
      setIsPanning(true);
    }
  };
  
  const handleMouseMove = (e: React.MouseEvent) => {
    if (isPanning) {
      setPan(p => ({
        x: p.x + e.movementX,
        y: p.y + e.movementY,
      }));
    }
  };
  
  const handleMouseUp = () => setIsPanning(false);
  
  // Wheel zoom
  const handleWheel = (e: React.WheelEvent) => {
    if (e.ctrlKey) {
      e.preventDefault();
      if (e.deltaY < 0) zoomIn();
      else zoomOut();
    }
  };
  
  return (
    <div className={cn('relative overflow-hidden bg-muted rounded-lg', className)}>
      {enableControls && (
        <div className="absolute top-2 right-2 z-10 flex gap-1 bg-background/80 rounded-lg p-1">
          <button onClick={zoomIn} className="p-1.5 hover:bg-accent rounded" title="Zoom in">
            <ZoomIn className="w-4 h-4" />
          </button>
          <button onClick={zoomOut} className="p-1.5 hover:bg-accent rounded" title="Zoom out">
            <ZoomOut className="w-4 h-4" />
          </button>
          <button onClick={rotate} className="p-1.5 hover:bg-accent rounded" title="Rotate">
            <RotateCw className="w-4 h-4" />
          </button>
          <button onClick={reset} className="p-1.5 hover:bg-accent rounded" title="Reset">
            <Maximize2 className="w-4 h-4" />
          </button>
          <span className="px-2 py-1 text-xs">{Math.round(zoom * 100)}%</span>
        </div>
      )}
      
      <div
        ref={containerRef}
        className="w-full h-full flex items-center justify-center"
        style={{ cursor: zoom > 1 ? (isPanning ? 'grabbing' : 'grab') : 'default' }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
      >
        <img
          src={src}
          alt={alt}
          className={cn(
            'max-w-full max-h-full transition-transform',
            fit === 'contain' && 'object-contain',
            fit === 'cover' && 'object-cover',
          )}
          style={{
            transform: `scale(${zoom}) rotate(${rotation}deg) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`,
          }}
          draggable={false}
        />
      </div>
    </div>
  );
}
```

**PDFViewer.tsx:**
```typescript
// Use react-pdf or pdfjs-dist for PDF rendering
// Support page navigation, zoom, and highlight overlays

export interface PDFViewerProps {
  src: string;
  page?: number;
  scale?: number;
  highlights?: Array<{
    page: number;
    rect: { x: number; y: number; width: number; height: number };
    color?: string;
  }>;
  onPageChange?: (page: number) => void;
}

// Implementation using react-pdf
```
  </action>
  <verify>Display components render media correctly</verify>
  <done>Display components created</done>
</task>

<task type="auto">
  <name>Task 2: Create control flow components</name>
  <files>
    packages/@glyph/components/src/control/Show.tsx
    packages/@glyph/components/src/control/ForEach.tsx
    packages/@glyph/components/src/control/Button.tsx
  </files>
  <action>
**Show.tsx:**
```typescript
import { ReactNode } from 'react';

export interface ShowProps {
  when: boolean;
  fallback?: ReactNode;
  children: ReactNode;
}

/**
 * Conditional rendering component.
 * Renders children only when condition is true.
 */
export function Show({ when, fallback = null, children }: ShowProps) {
  return when ? <>{children}</> : <>{fallback}</>;
}
```

**ForEach.tsx:**
```typescript
import { ReactNode, Fragment } from 'react';

export interface ForEachProps<T> {
  items: T[];
  children: (item: T, index: number) => ReactNode;
  keyExtractor?: (item: T, index: number) => string | number;
  empty?: ReactNode;
}

/**
 * Iteration component for rendering lists.
 * Provides item and index to render function.
 */
export function ForEach<T>({
  items,
  children,
  keyExtractor,
  empty = null,
}: ForEachProps<T>) {
  if (items.length === 0) {
    return <>{empty}</>;
  }
  
  return (
    <>
      {items.map((item, index) => (
        <Fragment key={keyExtractor ? keyExtractor(item, index) : index}>
          {children(item, index)}
        </Fragment>
      ))}
    </>
  );
}
```

**Switch.tsx:**
```typescript
import { ReactNode } from 'react';

export interface SwitchProps<T extends string | number> {
  value: T;
  cases: Record<T, ReactNode>;
  default?: ReactNode;
}

/**
 * Switch/case component for multi-branch rendering.
 */
export function Switch<T extends string | number>({
  value,
  cases,
  default: defaultCase = null,
}: SwitchProps<T>) {
  return <>{cases[value] ?? defaultCase}</>;
}
```

**Button.tsx:**
```typescript
import { cn } from '@/lib/utils';
import { Loader2 } from 'lucide-react';

export interface ButtonProps {
  label: string;
  onClick?: () => void;
  variant?: 'default' | 'outline' | 'ghost' | 'destructive';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  type?: 'button' | 'submit';
  className?: string;
}

export function Button({
  label,
  onClick,
  variant = 'default',
  size = 'md',
  disabled = false,
  loading = false,
  type = 'button',
  className,
}: ButtonProps) {
  const variantClasses = {
    default: 'bg-primary text-primary-foreground hover:bg-primary/90',
    outline: 'border border-input bg-background hover:bg-accent',
    ghost: 'hover:bg-accent',
    destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
  };
  
  const sizeClasses = {
    sm: 'px-3 py-1 text-sm',
    md: 'px-4 py-2',
    lg: 'px-6 py-3 text-lg',
  };
  
  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled || loading}
      className={cn(
        'inline-flex items-center justify-center gap-2 rounded-md font-medium',
        'transition-colors focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2',
        'disabled:opacity-50 disabled:cursor-not-allowed',
        variantClasses[variant],
        sizeClasses[size],
        className
      )}
    >
      {loading && <Loader2 className="w-4 h-4 animate-spin" />}
      {label}
    </button>
  );
}
```

Also create SubmitButton.tsx (extends Button with submit behavior) and SkipButton.tsx (with confirmation).
  </action>
  <verify>Control components work in templates</verify>
  <done>Control flow components created</done>
</task>

<task type="auto">
  <name>Task 3: Export display and control modules</name>
  <files>
    packages/@glyph/components/src/display/index.ts
    packages/@glyph/components/src/control/index.ts
  </files>
  <action>
**display/index.ts:**
```typescript
export { TextDisplay, type TextDisplayProps, type HighlightRange } from './TextDisplay';
export { ImageViewer, type ImageViewerProps } from './ImageViewer';
export { PDFViewer, type PDFViewerProps } from './PDFViewer';
export { AudioPlayer, type AudioPlayerProps } from './AudioPlayer';
export { VideoPlayer, type VideoPlayerProps } from './VideoPlayer';
```

**control/index.ts:**
```typescript
export { Show, type ShowProps } from './Show';
export { ForEach, type ForEachProps } from './ForEach';
export { Switch, type SwitchProps } from './Switch';
export { Button, type ButtonProps } from './Button';
export { SubmitButton, type SubmitButtonProps } from './SubmitButton';
export { SkipButton, type SkipButtonProps } from './SkipButton';
```
  </action>
  <verify>Exports work correctly</verify>
  <done>Display and control modules exported</done>
</task>

</tasks>

<verification>
- TextDisplay renders plain, markdown, and HTML
- ImageViewer zoom, pan, rotate work
- Show/ForEach/Switch render correctly
- Button variants and sizes work
- All components work in dark/light mode
</verification>

<success_criteria>
- Display components render various media
- Control components enable conditional/iterative rendering
- Show evaluates boolean conditions
- ForEach iterates over arrays
</success_criteria>
