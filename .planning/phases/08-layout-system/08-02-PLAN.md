---
phase: 08-layout-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/@glyph/layout-runtime/src/shortcuts/registry.ts
  - packages/@glyph/layout-runtime/src/shortcuts/hooks.ts
  - packages/@glyph/layout-runtime/src/undo/manager.ts
  - packages/@glyph/layout-runtime/src/undo/context.tsx
  - packages/@glyph/layout-runtime/package.json
autonomous: true

must_haves:
  truths:
    - "Global shortcut registry prevents conflicts across components"
    - "Components receive shortcut bindings via props (not hardcoded)"
    - "Undo stack is layout-level using Y.js UndoManager"
    - "Undo only affects local changes (trackedOrigins filter)"
  artifacts:
    - path: "packages/@glyph/layout-runtime/src/shortcuts/registry.ts"
      provides: "Shortcut registration and conflict detection"
      exports: ["ShortcutRegistry", "createShortcutRegistry"]
    - path: "packages/@glyph/layout-runtime/src/undo/manager.ts"
      provides: "Y.js-based undo manager"
      exports: ["UndoManager", "createUndoManager"]
---

<objective>
Implement global shortcut registry and layout-level undo/redo system.

Purpose: Per CONTEXT decisions, shortcuts are defined at layout level (no conflicts), and undo operates on entire annotation output using Y.js UndoManager with trackedOrigins to only undo local changes.

Output: react-hotkeys-hook integration with conflict detection, Y.js UndoManager wrapper with WASM-compatible interface.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shortcut registry</name>
  <files>
    packages/@glyph/layout-runtime/src/shortcuts/registry.ts
    packages/@glyph/layout-runtime/src/shortcuts/hooks.ts
  </files>
  <action>
Install react-hotkeys-hook: `pnpm add react-hotkeys-hook`

**registry.ts:**
```typescript
interface ShortcutDefinition {
  id: string;           // e.g., 'nerTagger.addEntity'
  key: string;          // e.g., 'e', 'ctrl+z'
  description: string;
  scope?: string;       // Component that owns this shortcut
}

interface ShortcutRegistry {
  register(def: ShortcutDefinition): void;
  unregister(id: string): void;
  getBinding(id: string): string | undefined;
  getConflicts(): Array<{ key: string; ids: string[] }>;
  getAllBindings(): Map<string, ShortcutDefinition>;
}

// Default layout-level shortcuts
const LAYOUT_SHORTCUTS = {
  'layout.submit': 'ctrl+enter',
  'layout.save': 'ctrl+s',
  'layout.undo': 'ctrl+z',
  'layout.redo': 'ctrl+shift+z',
};
```

**hooks.ts:**
```typescript
// useShortcuts hook wrapping react-hotkeys-hook
export function useShortcuts(
  shortcuts: Record<string, () => void>,
  options?: { enabled?: boolean; scope?: string }
) {
  // Integrate with registry, warn on conflicts
}

// useLayoutShortcuts for standard layout shortcuts
export function useLayoutShortcuts(handlers: {
  onSubmit?: () => void;
  onSave?: () => void;
  onUndo?: () => void;
  onRedo?: () => void;
}) {
  // Wire to layout-level shortcuts
}
```
  </action>
  <verify>Registry detects conflicts when same key registered twice</verify>
  <done>Shortcut registry created with conflict detection</done>
</task>

<task type="auto">
  <name>Task 2: Implement Y.js undo manager</name>
  <files>packages/@glyph/layout-runtime/src/undo/manager.ts</files>
  <action>
Install yjs: `pnpm add yjs`

Create UndoManager wrapper:

```typescript
import { UndoManager as YUndoManager } from 'yjs';
import type * as Y from 'yjs';

interface UndoManagerOptions {
  outputMap: Y.Map<unknown>;
  trackedOrigins?: Set<string>;
  captureTimeout?: number;  // Group rapid changes
}

export function createUndoManager(options: UndoManagerOptions) {
  const manager = new YUndoManager([options.outputMap], {
    trackedOrigins: options.trackedOrigins ?? new Set(['user-action']),
    captureTimeout: options.captureTimeout ?? 500,
  });

  return {
    undo: () => manager.undo(),
    redo: () => manager.redo(),
    canUndo: () => manager.canUndo(),
    canRedo: () => manager.canRedo(),
    clear: () => manager.clear(),
    // WASM-compatible event interface
    onStackChange: (callback: (state: { canUndo: boolean; canRedo: boolean }) => void) => {
      manager.on('stack-item-added', () => callback({ canUndo: manager.canUndo(), canRedo: manager.canRedo() }));
      manager.on('stack-item-popped', () => callback({ canUndo: manager.canUndo(), canRedo: manager.canRedo() }));
    },
  };
}
```

Key: trackedOrigins filters to only undo local changes, not remote sync changes.
  </action>
  <verify>UndoManager only undoes changes with 'user-action' origin</verify>
  <done>Y.js UndoManager wrapper created with WASM-compatible interface</done>
</task>

<task type="auto">
  <name>Task 3: Create undo context provider</name>
  <files>packages/@glyph/layout-runtime/src/undo/context.tsx</files>
  <action>
Create React context for undo manager:

```typescript
interface UndoContextValue {
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
}

export const UndoContext = createContext<UndoContextValue | null>(null);

export function UndoProvider({ outputMap, children }: { outputMap: Y.Map<unknown>; children: ReactNode }) {
  const manager = useMemo(() => createUndoManager({ outputMap }), [outputMap]);
  const [state, setState] = useState({ canUndo: false, canRedo: false });

  useEffect(() => {
    manager.onStackChange(setState);
  }, [manager]);

  // Wire to keyboard shortcuts
  useLayoutShortcuts({
    onUndo: manager.undo,
    onRedo: manager.redo,
  });

  return (
    <UndoContext.Provider value={{ ...state, undo: manager.undo, redo: manager.redo }}>
      {children}
    </UndoContext.Provider>
  );
}

export function useUndo() {
  const context = useContext(UndoContext);
  if (!context) throw new Error('useUndo must be used within UndoProvider');
  return context;
}
```
  </action>
  <verify>useUndo hook provides undo/redo in nested components</verify>
  <done>UndoProvider and useUndo hook created</done>
</task>

<task type="auto">
  <name>Task 4: Export from package</name>
  <files>
    packages/@glyph/layout-runtime/src/index.ts
    packages/@glyph/layout-runtime/package.json
  </files>
  <action>
Create package if not exists:
```bash
mkdir -p packages/@glyph/layout-runtime/src/{shortcuts,undo}
```

**package.json:**
```json
{
  "name": "@glyph/layout-runtime",
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": "./src/index.ts",
    "./shortcuts": "./src/shortcuts/index.ts",
    "./undo": "./src/undo/index.ts"
  },
  "dependencies": {
    "react-hotkeys-hook": "^4.5.0",
    "yjs": "^13.6.0"
  },
  "peerDependencies": {
    "react": "^18.0.0 || ^19.0.0"
  }
}
```

**src/index.ts:**
```typescript
export * from './shortcuts';
export * from './undo';
```
  </action>
  <verify>Package exports work: `pnpm --filter @glyph/layout-runtime typecheck`</verify>
  <done>Package created and exports configured</done>
</task>

</tasks>

<verification>
- ShortcutRegistry detects key conflicts
- UndoManager only undoes user-action origin changes
- useUndo hook works in nested components
- Ctrl+Z/Ctrl+Shift+Z wired to undo/redo
- Package exports all modules correctly
</verification>

<success_criteria>
- Global shortcut registry prevents conflicts
- Components receive bindings via props (not hardcoded)
- Undo stack is layout-level with Y.js
- Only local changes are undoable (trackedOrigins)
</success_criteria>
