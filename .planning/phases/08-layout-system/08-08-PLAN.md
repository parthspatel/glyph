---
phase: 08-layout-system
plan: 08
type: execute
wave: 3
depends_on: [08-05]
files_modified:
  - packages/@glyph/components/src/annotation/NERTagger/index.tsx
  - packages/@glyph/components/src/annotation/NERTagger/VirtualizedText.tsx
  - packages/@glyph/components/src/annotation/NERTagger/SelectionManager.ts
  - packages/@glyph/components/src/annotation/NERTagger/EntityOverlay.tsx
  - packages/@glyph/components/src/annotation/NERTagger/types.ts
autonomous: true

must_haves:
  truths:
    - "Virtualized rendering for 50+ page documents"
    - "Rich selection: click-drag, double-click word, shift-click extend"
    - "Character offsets maintained independently of DOM"
    - "Selection state survives scroll across virtual boundaries"
  artifacts:
    - path: "packages/@glyph/components/src/annotation/NERTagger/VirtualizedText.tsx"
      provides: "react-window based text virtualization"
      exports: ["VirtualizedText"]
    - path: "packages/@glyph/components/src/annotation/NERTagger/SelectionManager.ts"
      provides: "Character-offset based selection"
      exports: ["SelectionManager", "useSelection"]
---

<objective>
Enhance NERTagger with virtualization and rich selection.

Purpose: Per CONTEXT, virtualized rendering handles 50+ page documents smoothly. Selection uses character offsets (not DOM ranges) to survive virtualization boundaries.

Output: Paragraph-level virtualization with react-window, character-offset selection manager, rich selection UX.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
@packages/@glyph/components/src/annotation/NERTagger.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and selection manager</name>
  <files>
    packages/@glyph/components/src/annotation/NERTagger/types.ts
    packages/@glyph/components/src/annotation/NERTagger/SelectionManager.ts
  </files>
  <action>
Install react-window: `pnpm add react-window @types/react-window`

**types.ts:**
```typescript
export interface Entity {
  id: string;
  type: string;
  start: number;  // Character offset
  end: number;    // Character offset
  text: string;
}

export interface EntityType {
  id: string;
  label: string;
  color: string;
  shortcut?: string;
}

export interface TextRange {
  start: number;
  end: number;
}

export interface Paragraph {
  index: number;
  text: string;
  startOffset: number;  // Character offset of paragraph start
  endOffset: number;    // Character offset of paragraph end
}

export interface SelectionState {
  range: TextRange | null;
  anchor: number | null;  // For shift-click extending
  isSelecting: boolean;
}
```

**SelectionManager.ts:**
```typescript
import { useState, useCallback, useRef } from 'react';
import type { TextRange, SelectionState, Paragraph } from './types';

/**
 * Character-offset based selection manager.
 * Maintains selection state independently of DOM.
 */
export class SelectionManager {
  private text: string;
  private paragraphs: Paragraph[];
  
  constructor(text: string) {
    this.text = text;
    this.paragraphs = this.splitIntoParagraphs(text);
  }
  
  private splitIntoParagraphs(text: string): Paragraph[] {
    const paragraphs: Paragraph[] = [];
    let offset = 0;
    const lines = text.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      paragraphs.push({
        index: i,
        text: line,
        startOffset: offset,
        endOffset: offset + line.length,
      });
      offset += line.length + 1; // +1 for newline
    }
    
    return paragraphs;
  }
  
  getParagraphs(): Paragraph[] {
    return this.paragraphs;
  }
  
  getParagraphAtOffset(offset: number): Paragraph | undefined {
    return this.paragraphs.find(p => offset >= p.startOffset && offset <= p.endOffset);
  }
  
  /**
   * Convert DOM selection to character offset range.
   */
  domToOffset(node: Node, domOffset: number, paragraphIndex: number): number {
    const paragraph = this.paragraphs[paragraphIndex];
    if (!paragraph) return 0;
    
    // Walk through text nodes to find offset
    let charOffset = paragraph.startOffset;
    // ... implementation details
    return charOffset + domOffset;
  }
  
  /**
   * Get word boundaries at offset (for double-click).
   */
  getWordAt(offset: number): TextRange | null {
    // Find word boundaries using regex
    const wordRegex = /\b\w+\b/g;
    let match;
    while ((match = wordRegex.exec(this.text)) !== null) {
      if (offset >= match.index && offset <= match.index + match[0].length) {
        return { start: match.index, end: match.index + match[0].length };
      }
    }
    return null;
  }
  
  /**
   * Extend selection from anchor to new offset (for shift-click).
   */
  extendSelection(anchor: number, newOffset: number): TextRange {
    return {
      start: Math.min(anchor, newOffset),
      end: Math.max(anchor, newOffset),
    };
  }
}

/**
 * React hook for selection state.
 */
export function useSelection(text: string) {
  const managerRef = useRef<SelectionManager>(new SelectionManager(text));
  const [state, setState] = useState<SelectionState>({
    range: null,
    anchor: null,
    isSelecting: false,
  });
  
  // Update manager when text changes
  if (managerRef.current.getParagraphs()[0]?.text !== text.split('\n')[0]) {
    managerRef.current = new SelectionManager(text);
  }
  
  const startSelection = useCallback((offset: number) => {
    setState({ range: { start: offset, end: offset }, anchor: offset, isSelecting: true });
  }, []);
  
  const updateSelection = useCallback((offset: number) => {
    setState(prev => {
      if (!prev.isSelecting || prev.anchor === null) return prev;
      return {
        ...prev,
        range: { start: Math.min(prev.anchor, offset), end: Math.max(prev.anchor, offset) },
      };
    });
  }, []);
  
  const endSelection = useCallback(() => {
    setState(prev => ({ ...prev, isSelecting: false }));
  }, []);
  
  const selectWord = useCallback((offset: number) => {
    const range = managerRef.current.getWordAt(offset);
    if (range) {
      setState({ range, anchor: range.start, isSelecting: false });
    }
  }, []);
  
  const extendTo = useCallback((offset: number) => {
    setState(prev => {
      const anchor = prev.anchor ?? offset;
      return {
        range: managerRef.current.extendSelection(anchor, offset),
        anchor,
        isSelecting: false,
      };
    });
  }, []);
  
  const clearSelection = useCallback(() => {
    setState({ range: null, anchor: null, isSelecting: false });
  }, []);
  
  return {
    ...state,
    manager: managerRef.current,
    startSelection,
    updateSelection,
    endSelection,
    selectWord,
    extendTo,
    clearSelection,
  };
}
```
  </action>
  <verify>useSelection tracks character offsets correctly</verify>
  <done>Selection manager with character offsets created</done>
</task>

<task type="auto">
  <name>Task 2: Create virtualized text renderer</name>
  <files>packages/@glyph/components/src/annotation/NERTagger/VirtualizedText.tsx</files>
  <action>
Create react-window based virtualization:

```typescript
import { useRef, useCallback, useMemo } from 'react';
import { VariableSizeList, ListChildComponentProps } from 'react-window';
import type { Entity, EntityType, Paragraph, TextRange } from './types';

interface VirtualizedTextProps {
  paragraphs: Paragraph[];
  entities: Entity[];
  entityTypes: EntityType[];
  selection: TextRange | null;
  selectedEntityId: string | null;
  onSelectionStart: (offset: number) => void;
  onSelectionMove: (offset: number) => void;
  onSelectionEnd: () => void;
  onDoubleClick: (offset: number) => void;
  onShiftClick: (offset: number) => void;
  onEntityClick: (entity: Entity) => void;
}

// Measure paragraph heights
function measureParagraph(text: string, width: number): number {
  // Approximate: ~20px per line, ~80 chars per line at standard width
  const charsPerLine = Math.floor(width / 8);
  const lines = Math.ceil(text.length / charsPerLine) || 1;
  return lines * 24 + 8; // 24px line height + 8px padding
}

export function VirtualizedText({
  paragraphs,
  entities,
  entityTypes,
  selection,
  selectedEntityId,
  onSelectionStart,
  onSelectionMove,
  onSelectionEnd,
  onDoubleClick,
  onShiftClick,
  onEntityClick,
}: VirtualizedTextProps) {
  const listRef = useRef<VariableSizeList>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Calculate row heights
  const getItemSize = useCallback((index: number) => {
    const width = containerRef.current?.clientWidth ?? 600;
    return measureParagraph(paragraphs[index].text, width);
  }, [paragraphs]);
  
  // Get entities for a specific paragraph
  const getEntitiesForParagraph = useCallback((paragraph: Paragraph): Entity[] => {
    return entities.filter(e => 
      e.start < paragraph.endOffset && e.end > paragraph.startOffset
    );
  }, [entities]);
  
  // Render a single paragraph
  const ParagraphRow = useCallback(({ index, style }: ListChildComponentProps) => {
    const paragraph = paragraphs[index];
    const paragraphEntities = getEntitiesForParagraph(paragraph);
    
    const handleMouseDown = (e: React.MouseEvent) => {
      if (e.shiftKey) {
        const offset = getOffsetFromEvent(e, paragraph);
        onShiftClick(offset);
      } else {
        const offset = getOffsetFromEvent(e, paragraph);
        onSelectionStart(offset);
      }
    };
    
    const handleMouseMove = (e: React.MouseEvent) => {
      if (e.buttons === 1) {
        const offset = getOffsetFromEvent(e, paragraph);
        onSelectionMove(offset);
      }
    };
    
    const handleDoubleClick = (e: React.MouseEvent) => {
      const offset = getOffsetFromEvent(e, paragraph);
      onDoubleClick(offset);
    };
    
    return (
      <div 
        style={style}
        className="px-2 py-1 select-none cursor-text"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={onSelectionEnd}
        onDoubleClick={handleDoubleClick}
      >
        <ParagraphContent
          paragraph={paragraph}
          entities={paragraphEntities}
          entityTypes={entityTypes}
          selection={selection}
          selectedEntityId={selectedEntityId}
          onEntityClick={onEntityClick}
        />
      </div>
    );
  }, [paragraphs, getEntitiesForParagraph, entityTypes, selection, selectedEntityId]);
  
  return (
    <div ref={containerRef} className="h-full w-full">
      <VariableSizeList
        ref={listRef}
        height={600}
        width="100%"
        itemCount={paragraphs.length}
        itemSize={getItemSize}
        overscanCount={5}
      >
        {ParagraphRow}
      </VariableSizeList>
    </div>
  );
}

// Helper to get character offset from mouse event
function getOffsetFromEvent(e: React.MouseEvent, paragraph: Paragraph): number {
  // Implementation: use Range API to find character position
  const target = e.currentTarget;
  const rect = target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  
  // Approximate character position
  const charWidth = 8;
  const charIndex = Math.floor(x / charWidth);
  
  return paragraph.startOffset + Math.min(charIndex, paragraph.text.length);
}
```
  </action>
  <verify>Virtualized list renders paragraphs correctly</verify>
  <done>Virtualized text component created with react-window</done>
</task>

<task type="auto">
  <name>Task 3: Create entity overlay component</name>
  <files>packages/@glyph/components/src/annotation/NERTagger/EntityOverlay.tsx</files>
  <action>
Create component for rendering entities and selection highlights:

```typescript
import type { Entity, EntityType, Paragraph, TextRange } from './types';

interface ParagraphContentProps {
  paragraph: Paragraph;
  entities: Entity[];
  entityTypes: EntityType[];
  selection: TextRange | null;
  selectedEntityId: string | null;
  onEntityClick: (entity: Entity) => void;
}

export function ParagraphContent({
  paragraph,
  entities,
  entityTypes,
  selection,
  selectedEntityId,
  onEntityClick,
}: ParagraphContentProps) {
  // Build segments: text runs and entity spans
  const segments = buildSegments(paragraph, entities, selection);
  
  return (
    <span className="whitespace-pre-wrap">
      {segments.map((segment, i) => {
        if (segment.type === 'text') {
          return <span key={i}>{segment.text}</span>;
        }
        
        if (segment.type === 'selection') {
          return (
            <span 
              key={i} 
              className="bg-primary/30"
            >
              {segment.text}
            </span>
          );
        }
        
        if (segment.type === 'entity') {
          const entityType = entityTypes.find(t => t.id === segment.entity!.type);
          const isSelected = segment.entity!.id === selectedEntityId;
          
          return (
            <span
              key={i}
              className={`
                relative cursor-pointer rounded px-0.5
                ${isSelected ? 'ring-2 ring-primary' : ''}
              `}
              style={{ 
                backgroundColor: `${entityType?.color}40`,
                borderBottom: `2px solid ${entityType?.color}`,
              }}
              onClick={(e) => {
                e.stopPropagation();
                onEntityClick(segment.entity!);
              }}
              title={entityType?.label}
            >
              {segment.text}
            </span>
          );
        }
        
        return null;
      })}
    </span>
  );
}

interface Segment {
  type: 'text' | 'selection' | 'entity';
  text: string;
  entity?: Entity;
}

function buildSegments(
  paragraph: Paragraph,
  entities: Entity[],
  selection: TextRange | null
): Segment[] {
  const segments: Segment[] = [];
  const { text, startOffset } = paragraph;
  
  // Build sorted list of boundaries
  const boundaries: Array<{ offset: number; type: 'start' | 'end'; kind: 'entity' | 'selection'; entity?: Entity }> = [];
  
  for (const entity of entities) {
    const localStart = Math.max(0, entity.start - startOffset);
    const localEnd = Math.min(text.length, entity.end - startOffset);
    if (localStart < localEnd) {
      boundaries.push({ offset: localStart, type: 'start', kind: 'entity', entity });
      boundaries.push({ offset: localEnd, type: 'end', kind: 'entity', entity });
    }
  }
  
  if (selection) {
    const localStart = Math.max(0, selection.start - startOffset);
    const localEnd = Math.min(text.length, selection.end - startOffset);
    if (localStart < localEnd) {
      boundaries.push({ offset: localStart, type: 'start', kind: 'selection' });
      boundaries.push({ offset: localEnd, type: 'end', kind: 'selection' });
    }
  }
  
  // Sort boundaries
  boundaries.sort((a, b) => a.offset - b.offset || (a.type === 'start' ? -1 : 1));
  
  // Build segments
  let pos = 0;
  let activeEntity: Entity | null = null;
  let inSelection = false;
  
  for (const boundary of boundaries) {
    if (boundary.offset > pos) {
      const segmentText = text.slice(pos, boundary.offset);
      if (activeEntity) {
        segments.push({ type: 'entity', text: segmentText, entity: activeEntity });
      } else if (inSelection) {
        segments.push({ type: 'selection', text: segmentText });
      } else {
        segments.push({ type: 'text', text: segmentText });
      }
    }
    
    if (boundary.kind === 'entity') {
      activeEntity = boundary.type === 'start' ? boundary.entity! : null;
    } else {
      inSelection = boundary.type === 'start';
    }
    
    pos = boundary.offset;
  }
  
  // Remaining text
  if (pos < text.length) {
    segments.push({ type: 'text', text: text.slice(pos) });
  }
  
  return segments;
}
```
  </action>
  <verify>Entity highlights render correctly</verify>
  <done>Entity overlay component created</done>
</task>

<task type="auto">
  <name>Task 4: Integrate into NERTagger component</name>
  <files>packages/@glyph/components/src/annotation/NERTagger/index.tsx</files>
  <action>
Create main NERTagger component with virtualization:

```typescript
import { useState, useCallback, useMemo } from 'react';
import { VirtualizedText } from './VirtualizedText';
import { useSelection } from './SelectionManager';
import type { Entity, EntityType, TextRange } from './types';

export interface NERTaggerProps {
  text: string;
  entityTypes: EntityType[];
  value: Entity[];
  onChange: (entities: Entity[]) => void;
  readOnly?: boolean;
  suggestions?: Entity[];
  onAcceptSuggestion?: (entity: Entity) => void;
  allowOverlapping?: boolean;
  enableHotkeys?: boolean;
  shortcuts?: {
    addEntity?: string;
    deleteEntity?: string;
    cycleLabel?: string;
  };
}

export function NERTagger({
  text,
  entityTypes,
  value,
  onChange,
  readOnly = false,
  suggestions = [],
  onAcceptSuggestion,
  allowOverlapping = false,
  enableHotkeys = true,
  shortcuts,
}: NERTaggerProps) {
  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null);
  const [activeEntityType, setActiveEntityType] = useState<string>(entityTypes[0]?.id ?? '');
  
  const selection = useSelection(text);
  
  // Add entity from selection
  const addEntity = useCallback(() => {
    if (readOnly || !selection.range) return;
    
    const { start, end } = selection.range;
    if (start === end) return;
    
    // Check for overlaps
    if (!allowOverlapping) {
      const overlaps = value.some(e => 
        (start < e.end && end > e.start)
      );
      if (overlaps) return;
    }
    
    const newEntity: Entity = {
      id: crypto.randomUUID(),
      type: activeEntityType,
      start,
      end,
      text: text.slice(start, end),
    };
    
    onChange([...value, newEntity]);
    selection.clearSelection();
  }, [readOnly, selection.range, allowOverlapping, activeEntityType, value, onChange, text]);
  
  // Delete selected entity
  const deleteEntity = useCallback(() => {
    if (readOnly || !selectedEntityId) return;
    onChange(value.filter(e => e.id !== selectedEntityId));
    setSelectedEntityId(null);
  }, [readOnly, selectedEntityId, value, onChange]);
  
  // Keyboard shortcuts
  useEffect(() => {
    if (!enableHotkeys) return;
    
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === (shortcuts?.addEntity ?? 'e') && selection.range) {
        e.preventDefault();
        addEntity();
      }
      if (e.key === (shortcuts?.deleteEntity ?? 'Backspace') && selectedEntityId) {
        e.preventDefault();
        deleteEntity();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [enableHotkeys, shortcuts, selection.range, selectedEntityId, addEntity, deleteEntity]);
  
  return (
    <div className="flex flex-col h-full">
      {/* Entity type selector */}
      <div className="flex gap-2 p-2 border-b">
        {entityTypes.map(type => (
          <button
            key={type.id}
            onClick={() => setActiveEntityType(type.id)}
            className={`
              px-3 py-1 rounded text-sm
              ${activeEntityType === type.id ? 'ring-2 ring-primary' : ''}
            `}
            style={{ backgroundColor: `${type.color}40` }}
          >
            {type.label}
            {type.shortcut && <kbd className="ml-1 text-xs opacity-60">{type.shortcut}</kbd>}
          </button>
        ))}
      </div>
      
      {/* Virtualized text */}
      <div className="flex-1 overflow-hidden">
        <VirtualizedText
          paragraphs={selection.manager.getParagraphs()}
          entities={value}
          entityTypes={entityTypes}
          selection={selection.range}
          selectedEntityId={selectedEntityId}
          onSelectionStart={selection.startSelection}
          onSelectionMove={selection.updateSelection}
          onSelectionEnd={selection.endSelection}
          onDoubleClick={selection.selectWord}
          onShiftClick={selection.extendTo}
          onEntityClick={(e) => setSelectedEntityId(e.id)}
        />
      </div>
      
      {/* Suggestions */}
      {suggestions.length > 0 && (
        <div className="p-2 border-t bg-muted/50">
          <p className="text-xs text-muted-foreground mb-1">Suggestions:</p>
          <div className="flex flex-wrap gap-1">
            {suggestions.slice(0, 5).map(s => (
              <button
                key={s.id}
                onClick={() => onAcceptSuggestion?.(s)}
                className="text-xs px-2 py-0.5 rounded bg-primary/20 hover:bg-primary/30"
              >
                {s.text} ({entityTypes.find(t => t.id === s.type)?.label})
              </button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

export type { Entity, EntityType, TextRange };
```
  </action>
  <verify>NERTagger renders and selection works</verify>
  <done>NERTagger with virtualization complete</done>
</task>

</tasks>

<verification>
- Scroll 50+ page document smoothly (check FPS)
- Click-drag creates selection
- Double-click selects word
- Shift-click extends selection
- Selection survives scroll
- Entities render correctly across paragraph boundaries
</verification>

<success_criteria>
- Virtualized rendering for large documents
- Rich selection with all gestures
- Character offsets maintained independently
- Selection survives virtual boundary scrolling
</success_criteria>
