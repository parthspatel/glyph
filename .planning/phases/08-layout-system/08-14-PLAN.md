---
phase: 08-layout-system
plan: 14
type: execute
wave: 5
depends_on: [08-12, 08-13]
files_modified:
  - apps/web/src/pages/admin/layouts/LayoutPreviewPage.tsx
  - apps/web/src/pages/admin/layouts/LayoutEditorPane.tsx
  - apps/web/src/pages/admin/layouts/DataSourceSelector.tsx
  - apps/web/src/pages/admin/layouts/PreviewPane.tsx
  - apps/web/src/pages/admin/layouts/index.ts
autonomous: false

must_haves:
  truths:
    - "Monaco editor with Nunjucks syntax highlighting"
    - "Live preview updates on template change"
    - "Three data sources: manual JSON, schema mock, task snapshot"
    - "Inline error display in preview area"
  artifacts:
    - path: "apps/web/src/pages/admin/layouts/LayoutPreviewPage.tsx"
      provides: "Layout authoring experience"
      exports: ["LayoutPreviewPage"]
---

<objective>
Build the layout preview page for template authoring.

Purpose: Per CONTEXT, layout authors need Monaco editing with live preview, multiple data sources, and device presets. This is the primary authoring experience for layouts.

Output: Admin page with split editor/preview panes, data source selector, and device presets.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout preview page</name>
  <files>apps/web/src/pages/admin/layouts/LayoutPreviewPage.tsx</files>
  <action>
Create main page component:

```typescript
import { useState, useCallback, useEffect, useMemo } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useQuery, useMutation } from '@tanstack/react-query';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import { LayoutEditorPane } from './LayoutEditorPane';
import { PreviewPane } from './PreviewPane';
import { DataSourceSelector } from './DataSourceSelector';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from '@/components/ui/select';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  Save, 
  Play, 
  Smartphone, 
  Tablet, 
  Monitor,
  Settings,
  Eye,
} from 'lucide-react';

const DEVICE_PRESETS = {
  desktop: { width: '100%', height: '100%', label: 'Desktop' },
  tablet: { width: '768px', height: '1024px', label: 'Tablet' },
  mobile: { width: '375px', height: '667px', label: 'Mobile' },
};

type DevicePreset = keyof typeof DEVICE_PRESETS;

export function LayoutPreviewPage() {
  const { layoutId, versionId } = useParams<{ layoutId: string; versionId?: string }>();
  const navigate = useNavigate();
  
  // Layout state
  const [content, setContent] = useState('');
  const [hasChanges, setHasChanges] = useState(false);
  const [devicePreset, setDevicePreset] = useState<DevicePreset>('desktop');
  const [previewData, setPreviewData] = useState<Record<string, unknown>>({});
  const [errors, setErrors] = useState<Array<{ line: number; message: string }>>([]);
  
  // Fetch layout version
  const { data: layoutVersion, isLoading } = useQuery({
    queryKey: ['layoutVersion', layoutId, versionId],
    queryFn: async () => {
      const res = await fetch(`/api/v1/layouts/${layoutId}/versions/${versionId || 'latest'}`);
      if (!res.ok) throw new Error('Failed to load layout');
      return res.json();
    },
    enabled: !!layoutId,
  });
  
  // Initialize content from loaded version
  useEffect(() => {
    if (layoutVersion?.content) {
      setContent(layoutVersion.content);
      setHasChanges(false);
    }
  }, [layoutVersion]);
  
  // Save mutation
  const saveMutation = useMutation({
    mutationFn: async (newContent: string) => {
      const res = await fetch(`/api/v1/layouts/${layoutId}/versions/${versionId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: newContent }),
      });
      if (!res.ok) throw new Error('Failed to save');
      return res.json();
    },
    onSuccess: () => {
      setHasChanges(false);
    },
  });
  
  // Handle content change
  const handleContentChange = useCallback((newContent: string) => {
    setContent(newContent);
    setHasChanges(true);
  }, []);
  
  // Handle validation errors from editor
  const handleValidationErrors = useCallback((errs: Array<{ line: number; message: string }>) => {
    setErrors(errs);
  }, []);
  
  // Save shortcut
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        if (hasChanges && layoutVersion?.status === 'draft') {
          saveMutation.mutate(content);
        }
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [hasChanges, content, layoutVersion?.status]);
  
  if (isLoading) {
    return <div className="flex items-center justify-center h-full">Loading...</div>;
  }
  
  return (
    <div className="h-screen flex flex-col">
      {/* Toolbar */}
      <header className="flex items-center justify-between px-4 py-2 border-b bg-background">
        <div className="flex items-center gap-4">
          <h1 className="text-lg font-semibold">{layoutVersion?.layout?.name || 'Layout Editor'}</h1>
          <Badge variant={layoutVersion?.status === 'draft' ? 'secondary' : 'default'}>
            {layoutVersion?.status}
          </Badge>
          <span className="text-sm text-muted-foreground">v{layoutVersion?.version}</span>
          {hasChanges && (
            <Badge variant="outline" className="text-warning">Unsaved changes</Badge>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          {/* Device presets */}
          <div className="flex border rounded-md">
            <button
              onClick={() => setDevicePreset('desktop')}
              className={`p-2 ${devicePreset === 'desktop' ? 'bg-muted' : ''}`}
              title="Desktop"
            >
              <Monitor className="w-4 h-4" />
            </button>
            <button
              onClick={() => setDevicePreset('tablet')}
              className={`p-2 ${devicePreset === 'tablet' ? 'bg-muted' : ''}`}
              title="Tablet"
            >
              <Tablet className="w-4 h-4" />
            </button>
            <button
              onClick={() => setDevicePreset('mobile')}
              className={`p-2 ${devicePreset === 'mobile' ? 'bg-muted' : ''}`}
              title="Mobile"
            >
              <Smartphone className="w-4 h-4" />
            </button>
          </div>
          
          {/* Save button */}
          <Button
            onClick={() => saveMutation.mutate(content)}
            disabled={!hasChanges || layoutVersion?.status !== 'draft' || saveMutation.isPending}
            size="sm"
          >
            <Save className="w-4 h-4 mr-2" />
            Save
          </Button>
          
          {/* Publish button (draft only) */}
          {layoutVersion?.status === 'draft' && (
            <Button
              variant="outline"
              onClick={() => {
                // Publish flow
              }}
              size="sm"
            >
              Publish
            </Button>
          )}
        </div>
      </header>
      
      {/* Main content */}
      <div className="flex-1 overflow-hidden">
        <PanelGroup direction="horizontal">
          {/* Editor panel */}
          <Panel defaultSize={50} minSize={30}>
            <LayoutEditorPane
              content={content}
              onChange={handleContentChange}
              onValidation={handleValidationErrors}
              inputSchema={layoutVersion?.inputSchema}
              outputSchema={layoutVersion?.outputSchema}
              allowedComponents={layoutVersion?.allowedComponents}
              readOnly={layoutVersion?.status !== 'draft'}
            />
          </Panel>
          
          <PanelResizeHandle className="w-1 bg-border hover:bg-primary/50 transition-colors" />
          
          {/* Preview panel */}
          <Panel defaultSize={50} minSize={30}>
            <div className="h-full flex flex-col">
              {/* Data source selector */}
              <DataSourceSelector
                inputSchema={layoutVersion?.inputSchema}
                projectTypeId={layoutVersion?.layout?.projectTypeId}
                value={previewData}
                onChange={setPreviewData}
              />
              
              {/* Preview */}
              <div className="flex-1 p-4 bg-muted/30 overflow-hidden">
                <div 
                  className="h-full mx-auto bg-background border rounded-lg overflow-auto"
                  style={{
                    width: DEVICE_PRESETS[devicePreset].width,
                    maxWidth: '100%',
                  }}
                >
                  <PreviewPane
                    content={content}
                    data={previewData}
                    errors={errors}
                    settings={layoutVersion?.settings}
                  />
                </div>
              </div>
            </div>
          </Panel>
        </PanelGroup>
      </div>
    </div>
  );
}
```
  </action>
  <verify>Page loads with split editor/preview</verify>
  <done>Layout preview page created</done>
</task>

<task type="auto">
  <name>Task 2: Create editor pane with Monaco</name>
  <files>apps/web/src/pages/admin/layouts/LayoutEditorPane.tsx</files>
  <action>
Create Monaco editor wrapper:

```typescript
import { useRef, useEffect, useMemo } from 'react';
import Editor, { OnMount, OnChange } from '@monaco-editor/react';
import { 
  initializeNunjucksMonaco, 
  validateTemplate 
} from '@glyph/layout-runtime/monaco';
import { ComponentInterfaces } from '@glyph/components/interfaces';

interface LayoutEditorPaneProps {
  content: string;
  onChange: (content: string) => void;
  onValidation: (errors: Array<{ line: number; message: string }>) => void;
  inputSchema?: Record<string, unknown>;
  outputSchema?: Record<string, unknown>;
  allowedComponents?: string[];
  readOnly?: boolean;
}

export function LayoutEditorPane({
  content,
  onChange,
  onValidation,
  inputSchema,
  outputSchema,
  allowedComponents,
  readOnly = false,
}: LayoutEditorPaneProps) {
  const editorRef = useRef<any>(null);
  const disposablesRef = useRef<any[]>([]);
  
  // Initialize Monaco when mounted
  const handleEditorMount: OnMount = (editor, monaco) => {
    editorRef.current = editor;
    
    // Initialize Nunjucks language support
    const { setupDiagnostics } = initializeNunjucksMonaco({
      inputSchema,
      outputSchema,
      componentInterfaces: ComponentInterfaces,
      allowedComponents,
    });
    
    // Set up diagnostics
    const diagnosticDisposable = setupDiagnostics(editor);
    if (diagnosticDisposable) {
      disposablesRef.current.push(diagnosticDisposable);
    }
    
    // Listen for marker changes
    const markerDisposable = monaco.editor.onDidChangeMarkers(([uri]) => {
      if (uri.toString() === editor.getModel()?.uri.toString()) {
        const markers = monaco.editor.getModelMarkers({ resource: uri });
        onValidation(markers.map(m => ({
          line: m.startLineNumber,
          message: m.message,
        })));
      }
    });
    disposablesRef.current.push(markerDisposable);
    
    // Focus editor
    editor.focus();
  };
  
  // Cleanup
  useEffect(() => {
    return () => {
      disposablesRef.current.forEach(d => d.dispose?.());
    };
  }, []);
  
  // Handle content changes
  const handleChange: OnChange = (value) => {
    if (value !== undefined) {
      onChange(value);
    }
  };
  
  return (
    <div className="h-full flex flex-col">
      <div className="px-3 py-2 border-b bg-muted/30 flex items-center justify-between">
        <span className="text-sm font-medium">Template Editor</span>
        <span className="text-xs text-muted-foreground">Nunjucks</span>
      </div>
      
      <div className="flex-1">
        <Editor
          height="100%"
          defaultLanguage="nunjucks"
          value={content}
          onChange={handleChange}
          onMount={handleEditorMount}
          options={{
            readOnly,
            minimap: { enabled: false },
            fontSize: 14,
            lineNumbers: 'on',
            renderLineHighlight: 'line',
            scrollBeyondLastLine: false,
            wordWrap: 'on',
            automaticLayout: true,
            tabSize: 2,
            folding: true,
            formatOnPaste: true,
            formatOnType: true,
          }}
          theme="vs-dark"
        />
      </div>
    </div>
  );
}
```
  </action>
  <verify>Monaco editor loads with Nunjucks highlighting</verify>
  <done>Editor pane created</done>
</task>

<task type="auto">
  <name>Task 3: Create data source selector</name>
  <files>apps/web/src/pages/admin/layouts/DataSourceSelector.tsx</files>
  <action>
Create component for selecting preview data:

```typescript
import { useState, useCallback, useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Wand2, Database, FileJson } from 'lucide-react';

type DataSource = 'manual' | 'mock' | 'snapshot';

interface DataSourceSelectorProps {
  inputSchema?: Record<string, unknown>;
  projectTypeId?: string;
  value: Record<string, unknown>;
  onChange: (data: Record<string, unknown>) => void;
}

export function DataSourceSelector({
  inputSchema,
  projectTypeId,
  value,
  onChange,
}: DataSourceSelectorProps) {
  const [source, setSource] = useState<DataSource>('manual');
  const [manualJson, setManualJson] = useState(JSON.stringify(value, null, 2));
  const [jsonError, setJsonError] = useState<string | null>(null);
  const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null);
  
  // Fetch task snapshots for "real data" option
  const { data: taskSnapshots } = useQuery({
    queryKey: ['taskSnapshots', projectTypeId],
    queryFn: async () => {
      if (!projectTypeId) return [];
      const res = await fetch(`/api/v1/projects/types/${projectTypeId}/sample-tasks?limit=10`);
      return res.json();
    },
    enabled: !!projectTypeId && source === 'snapshot',
  });
  
  // Generate mock data from schema
  const generateMockData = useCallback(() => {
    if (!inputSchema) {
      onChange({ text: 'Sample input text for annotation.' });
      return;
    }
    
    // Simple mock generator based on schema
    const mock = generateFromSchema(inputSchema);
    onChange(mock);
    setManualJson(JSON.stringify(mock, null, 2));
  }, [inputSchema, onChange]);
  
  // Handle manual JSON change
  const handleManualChange = useCallback((json: string) => {
    setManualJson(json);
    try {
      const parsed = JSON.parse(json);
      setJsonError(null);
      onChange(parsed);
    } catch (e) {
      setJsonError('Invalid JSON');
    }
  }, [onChange]);
  
  // Handle snapshot selection
  const handleSnapshotSelect = useCallback((taskId: string) => {
    setSelectedTaskId(taskId);
    const task = taskSnapshots?.find((t: any) => t.id === taskId);
    if (task?.input) {
      onChange(task.input);
      setManualJson(JSON.stringify(task.input, null, 2));
    }
  }, [taskSnapshots, onChange]);
  
  return (
    <div className="border-b p-3">
      <div className="flex items-center gap-2 mb-3">
        <span className="text-sm font-medium">Preview Data</span>
        <Badge variant="outline" className="text-xs">
          {Object.keys(value).length} fields
        </Badge>
      </div>
      
      <Tabs value={source} onValueChange={(v) => setSource(v as DataSource)}>
        <TabsList className="grid grid-cols-3 w-full">
          <TabsTrigger value="manual" className="text-xs">
            <FileJson className="w-3 h-3 mr-1" />
            Manual
          </TabsTrigger>
          <TabsTrigger value="mock" className="text-xs">
            <Wand2 className="w-3 h-3 mr-1" />
            Generate
          </TabsTrigger>
          <TabsTrigger value="snapshot" className="text-xs">
            <Database className="w-3 h-3 mr-1" />
            Real Task
          </TabsTrigger>
        </TabsList>
        
        <TabsContent value="manual" className="mt-2">
          <Textarea
            value={manualJson}
            onChange={(e) => handleManualChange(e.target.value)}
            placeholder='{"text": "Sample input..."}'
            className="font-mono text-xs h-24"
          />
          {jsonError && (
            <p className="text-xs text-destructive mt-1">{jsonError}</p>
          )}
        </TabsContent>
        
        <TabsContent value="mock" className="mt-2">
          <Button 
            onClick={generateMockData} 
            size="sm" 
            variant="outline"
            className="w-full"
          >
            <Wand2 className="w-4 h-4 mr-2" />
            Generate from Schema
          </Button>
          <p className="text-xs text-muted-foreground mt-2">
            {inputSchema 
              ? 'Generates mock data based on input schema'
              : 'No schema defined - generates default sample'
            }
          </p>
        </TabsContent>
        
        <TabsContent value="snapshot" className="mt-2">
          {projectTypeId ? (
            <Select value={selectedTaskId ?? ''} onValueChange={handleSnapshotSelect}>
              <SelectTrigger>
                <SelectValue placeholder="Select a task..." />
              </SelectTrigger>
              <SelectContent>
                {taskSnapshots?.map((task: any) => (
                  <SelectItem key={task.id} value={task.id}>
                    {task.id.slice(0, 8)}... - {task.status}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          ) : (
            <p className="text-xs text-muted-foreground">
              Save layout to a project type to load real tasks
            </p>
          )}
        </TabsContent>
      </Tabs>
    </div>
  );
}

// Simple mock data generator
function generateFromSchema(schema: Record<string, unknown>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  const properties = (schema as any).properties || {};
  
  for (const [key, prop] of Object.entries(properties)) {
    const p = prop as any;
    switch (p.type) {
      case 'string':
        result[key] = `Sample ${key}`;
        break;
      case 'number':
        result[key] = 42;
        break;
      case 'boolean':
        result[key] = true;
        break;
      case 'array':
        result[key] = [];
        break;
      case 'object':
        result[key] = {};
        break;
      default:
        result[key] = null;
    }
  }
  
  return result;
}
```
  </action>
  <verify>Data source tabs work correctly</verify>
  <done>Data source selector created</done>
</task>

<task type="checkpoint">
  <name>Task 4: Human verification of preview page</name>
  <description>
Verify the layout preview page works end-to-end:

1. Navigate to /admin/layouts and create/open a layout
2. Verify Monaco editor loads with Nunjucks syntax highlighting
3. Type a template and verify autocomplete works (input., component names)
4. Verify preview updates on template change
5. Test device preset switching (desktop/tablet/mobile)
6. Test all three data sources (manual JSON, generate, task snapshot)
7. Verify errors display inline in preview when template is invalid
8. Verify save/publish workflow
  </description>
  <action>
Ask user to verify:

"Please test the Layout Preview page at /admin/layouts/{layoutId}:

1. Does Monaco editor load with Nunjucks highlighting? (colors for {{ }}, {% %})
2. Does autocomplete show when typing 'input.' or 'output.'?
3. Does preview update as you type?
4. Do device presets change preview width?
5. Can you switch between manual JSON, generate mock, and task snapshot?
6. Do template errors show in preview area?"
  </action>
  <verify>User confirms all checks pass</verify>
  <done>Layout preview page verified by human</done>
</task>

</tasks>

<verification>
- Monaco loads with Nunjucks syntax highlighting
- Autocomplete works for bindings and components
- Preview updates on template change
- Device presets change preview viewport
- All three data sources work
- Errors display inline
- Save/publish workflow works
</verification>

<success_criteria>
- Monaco editor with Nunjucks syntax
- Live preview on change
- Three data sources available
- Inline error display
- Device preset switching
</success_criteria>
