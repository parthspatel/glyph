---
phase: 08-layout-system
plan: 06
type: execute
wave: 2
depends_on: [08-03]
files_modified:
  - packages/@glyph/layout-runtime/src/nunjucks/environment.ts
  - packages/@glyph/layout-runtime/src/nunjucks/extensions.ts
  - packages/@glyph/layout-runtime/src/nunjucks/security.ts
  - packages/@glyph/layout-runtime/src/nunjucks/filters.ts
autonomous: true

must_haves:
  truths:
    - "Nunjucks environment configured with autoescape and throwOnUndefined"
    - "Custom component tag renders React components"
    - "Security constraints enforce allowedComponents and expression patterns"
    - "Max depth and iteration limits prevent DoS"
  artifacts:
    - path: "packages/@glyph/layout-runtime/src/nunjucks/environment.ts"
      provides: "Configured Nunjucks environment"
      exports: ["createNunjucksEnv", "NunjucksEnv"]
    - path: "packages/@glyph/layout-runtime/src/nunjucks/security.ts"
      provides: "Security constraint enforcement"
      exports: ["SecurityConfig", "validateExpression"]
---

<objective>
Configure Nunjucks template environment with security constraints.

Purpose: Per PRD, Nunjucks is the primary template format. Per RESEARCH, Nunjucks has NO built-in sandboxing, so security must be enforced at the environment level with expression allowlists and iteration limits.

Output: Configured Nunjucks environment with custom component tag, security constraints, and helper filters.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create security configuration</name>
  <files>packages/@glyph/layout-runtime/src/nunjucks/security.ts</files>
  <action>
Install nunjucks: `pnpm add nunjucks @types/nunjucks`

Create security layer:

```typescript
export interface SecurityConfig {
  allowedComponents: string[];           // Whitelist of component names
  bindingPathPattern: RegExp;            // Allowed variable paths
  expressionAllowlist: string[];         // Allowed expression variables
  maxDepth: number;                      // Max template include depth
  maxIterations: number;                 // Max loop iterations
}

const DEFAULT_SECURITY: SecurityConfig = {
  allowedComponents: [],  // Must be explicitly set
  bindingPathPattern: /^(input|output|context|config|user)\.[a-zA-Z0-9_.[\]]+$/,
  expressionAllowlist: ['input', 'output', 'context', 'config', 'user', 'loop'],
  maxDepth: 10,
  maxIterations: 1000,
};

/**
 * Validate that a binding expression is safe.
 */
export function validateExpression(expr: string, config: SecurityConfig = DEFAULT_SECURITY): boolean {
  // Check against allowlist pattern
  if (!config.bindingPathPattern.test(expr)) {
    console.warn(`Expression "${expr}" does not match allowed pattern`);
    return false;
  }
  
  // Check root variable is allowed
  const root = expr.split('.')[0].split('[')[0];
  if (!config.expressionAllowlist.includes(root)) {
    console.warn(`Expression root "${root}" not in allowlist`);
    return false;
  }
  
  return true;
}

/**
 * Validate that a component name is allowed.
 */
export function validateComponent(name: string, config: SecurityConfig): boolean {
  if (config.allowedComponents.length === 0) {
    // Empty allowlist = all registered components allowed
    return true;
  }
  return config.allowedComponents.includes(name);
}

/**
 * Create a secure data context with only allowed variables.
 */
export function createSecureContext(
  data: Record<string, unknown>,
  config: SecurityConfig = DEFAULT_SECURITY
): Record<string, unknown> {
  const secure: Record<string, unknown> = {};
  for (const key of config.expressionAllowlist) {
    if (key in data) {
      secure[key] = data[key];
    }
  }
  return secure;
}

export { DEFAULT_SECURITY };
```
  </action>
  <verify>validateExpression rejects paths outside allowlist</verify>
  <done>Security configuration and validators created</done>
</task>

<task type="auto">
  <name>Task 2: Create Nunjucks environment</name>
  <files>packages/@glyph/layout-runtime/src/nunjucks/environment.ts</files>
  <action>
Create configured Nunjucks environment:

```typescript
import nunjucks from 'nunjucks';
import type { SecurityConfig } from './security';
import { DEFAULT_SECURITY, createSecureContext } from './security';

export interface NunjucksEnvOptions {
  security?: Partial<SecurityConfig>;
  templates?: Record<string, string>;  // Inline templates
}

export function createNunjucksEnv(options: NunjucksEnvOptions = {}) {
  const security: SecurityConfig = { ...DEFAULT_SECURITY, ...options.security };
  
  // Track iteration counts for DoS protection
  let iterationCount = 0;
  
  // Create environment with secure defaults
  const env = new nunjucks.Environment(
    // Use PrecompiledLoader for inline templates
    new nunjucks.PrecompiledLoader(options.templates),
    {
      autoescape: true,          // Escape HTML by default
      throwOnUndefined: true,    // Error on undefined variables
      trimBlocks: true,          // Trim first newline after block
      lstripBlocks: true,        // Strip leading whitespace from blocks
    }
  );
  
  // Add iteration counter to prevent DoS
  env.addGlobal('__checkIteration', () => {
    iterationCount++;
    if (iterationCount > security.maxIterations) {
      throw new Error(`Maximum iterations (${security.maxIterations}) exceeded`);
    }
  });
  
  // Reset iteration counter before each render
  const originalRender = env.render.bind(env);
  env.render = (name: string, context?: object) => {
    iterationCount = 0;
    const secureContext = createSecureContext(context ?? {}, security);
    return originalRender(name, secureContext);
  };
  
  const originalRenderString = env.renderString.bind(env);
  env.renderString = (src: string, context?: object) => {
    iterationCount = 0;
    const secureContext = createSecureContext(context ?? {}, security);
    return originalRenderString(src, secureContext);
  };
  
  return {
    env,
    security,
    render: env.render.bind(env),
    renderString: env.renderString.bind(env),
  };
}

export type NunjucksEnv = ReturnType<typeof createNunjucksEnv>;
```
  </action>
  <verify>Environment escapes HTML and throws on undefined</verify>
  <done>Nunjucks environment created with security</done>
</task>

<task type="auto">
  <name>Task 3: Create component extension</name>
  <files>packages/@glyph/layout-runtime/src/nunjucks/extensions.ts</files>
  <action>
Create custom tag for rendering React components:

```typescript
import nunjucks from 'nunjucks';
import type { ComponentRegistry } from '../registry';
import type { SecurityConfig } from './security';
import { validateComponent } from './security';

/**
 * Custom tag for rendering React components in Nunjucks templates.
 * 
 * Usage in template:
 * {% component "NERTagger" text=input.text entityTypes=config.entityTypes value=output.entities %}
 */
export class ComponentExtension implements nunjucks.Extension {
  tags = ['component'];
  
  constructor(
    private registry: ComponentRegistry,
    private security: SecurityConfig
  ) {}
  
  parse(parser: any, nodes: any, lexer: any) {
    const tok = parser.nextToken();
    const args = parser.parseSignature(null, true);
    parser.advanceAfterBlockEnd(tok.value);
    
    return new nodes.CallExtension(this, 'run', args);
  }
  
  run(context: any, componentName: string, props: Record<string, unknown>) {
    // Security check
    if (!validateComponent(componentName, this.security)) {
      return new nunjucks.runtime.SafeString(
        `<div class="error">Component "${componentName}" not allowed</div>`
      );
    }
    
    // Check registry
    if (!this.registry.has(componentName)) {
      return new nunjucks.runtime.SafeString(
        `<div class="error">Unknown component: "${componentName}"</div>`
      );
    }
    
    // Return placeholder for React hydration
    // The actual React component is rendered client-side
    const propsJson = JSON.stringify(props);
    return new nunjucks.runtime.SafeString(
      `<div data-component="${componentName}" data-props='${propsJson}'></div>`
    );
  }
}

/**
 * Add the component extension to a Nunjucks environment.
 */
export function addComponentExtension(
  env: nunjucks.Environment,
  registry: ComponentRegistry,
  security: SecurityConfig
) {
  env.addExtension('ComponentExtension', new ComponentExtension(registry, security));
}
```
  </action>
  <verify>Component tag outputs hydration placeholder</verify>
  <done>Component extension created for React integration</done>
</task>

<task type="auto">
  <name>Task 4: Create helper filters</name>
  <files>packages/@glyph/layout-runtime/src/nunjucks/filters.ts</files>
  <action>
Add useful filters for template authors:

```typescript
import nunjucks from 'nunjucks';

/**
 * Add common filters to Nunjucks environment.
 */
export function addFilters(env: nunjucks.Environment) {
  // JSON stringify (for debugging)
  env.addFilter('json', (value: unknown, indent = 0) => {
    return JSON.stringify(value, null, indent);
  });
  
  // Safe access to nested properties
  env.addFilter('get', (obj: Record<string, unknown>, path: string, defaultValue?: unknown) => {
    const parts = path.split('.');
    let current: unknown = obj;
    for (const part of parts) {
      if (current == null || typeof current !== 'object') {
        return defaultValue;
      }
      current = (current as Record<string, unknown>)[part];
    }
    return current ?? defaultValue;
  });
  
  // Format date
  env.addFilter('date', (value: string | Date, format = 'short') => {
    const date = typeof value === 'string' ? new Date(value) : value;
    if (format === 'short') return date.toLocaleDateString();
    if (format === 'long') return date.toLocaleDateString(undefined, { dateStyle: 'long' });
    if (format === 'time') return date.toLocaleTimeString();
    return date.toISOString();
  });
  
  // Truncate text
  env.addFilter('truncate', (value: string, length = 100, suffix = '...') => {
    if (value.length <= length) return value;
    return value.slice(0, length - suffix.length) + suffix;
  });
  
  // Pluralize
  env.addFilter('pluralize', (count: number, singular: string, plural?: string) => {
    return count === 1 ? singular : (plural ?? singular + 's');
  });
  
  // Highlight text (for search results)
  env.addFilter('highlight', (text: string, term: string) => {
    if (!term) return text;
    const regex = new RegExp(`(${term})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  });
}
```
  </action>
  <verify>Filters work correctly in templates</verify>
  <done>Helper filters added to environment</done>
</task>

<task type="auto">
  <name>Task 5: Export nunjucks module</name>
  <files>
    packages/@glyph/layout-runtime/src/nunjucks/index.ts
    packages/@glyph/layout-runtime/src/index.ts
  </files>
  <action>
**nunjucks/index.ts:**
```typescript
export { createNunjucksEnv, type NunjucksEnv, type NunjucksEnvOptions } from './environment';
export { SecurityConfig, DEFAULT_SECURITY, validateExpression, validateComponent, createSecureContext } from './security';
export { ComponentExtension, addComponentExtension } from './extensions';
export { addFilters } from './filters';
```

**Update src/index.ts:**
```typescript
export * from './shortcuts';
export * from './undo';
export * from './validation';
export * from './sync';
export * from './registry';
export * from './nunjucks';
```
  </action>
  <verify>Nunjucks exports work correctly</verify>
  <done>Nunjucks module exported from package</done>
</task>

</tasks>

<verification>
- Environment autoescapes HTML output
- Environment throws on undefined variables
- Component tag validates against allowlist
- Max iterations limit triggers error
- Filters work in template rendering
</verification>

<success_criteria>
- Nunjucks configured with autoescape and throwOnUndefined
- Component tag renders placeholders for React hydration
- Security constraints enforce allowlist and expression patterns
- DoS protection via max depth and iterations
</success_criteria>
