---
phase: 08-layout-system
plan: 05
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - packages/@glyph/layout-runtime/src/registry/registry.ts
  - packages/@glyph/layout-runtime/src/registry/resolver.ts
  - packages/@glyph/layout-runtime/src/registry/hooks.ts
autonomous: true

must_haves:
  truths:
    - "Component registry maps names to implementations"
    - "Registry supports async loading for code splitting"
    - "Unknown component names produce helpful errors"
    - "Security: Only allowlisted components can render"
  artifacts:
    - path: "packages/@glyph/layout-runtime/src/registry/registry.ts"
      provides: "Component registration and lookup"
      exports: ["ComponentRegistry", "createRegistry"]
    - path: "packages/@glyph/layout-runtime/src/registry/resolver.ts"
      provides: "Component resolution with security checks"
      exports: ["resolveComponent", "ComponentResolver"]
---

<objective>
Implement component registry for name-to-implementation mapping.

Purpose: Templates reference components by name (e.g., `<NERTagger>`). The registry maps these names to React components, enforces security allowlists, and supports async loading.

Output: ComponentRegistry with registration, lookup, allowlist enforcement, and code splitting support.
</objective>

<context>
@.planning/phases/08-layout-system/08-CONTEXT.md
@.planning/phases/08-layout-system/08-RESEARCH.md
@packages/@glyph/components/src/interfaces/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create component registry</name>
  <files>packages/@glyph/layout-runtime/src/registry/registry.ts</files>
  <action>
Create registry with sync and async component support:

```typescript
import type { ComponentType, LazyExoticComponent } from 'react';
import type { ComponentInterface } from '@glyph/components/interfaces';

type ComponentLoader = () => Promise<{ default: ComponentType<any> }>;

interface RegisteredComponent {
  name: string;
  category: 'annotation' | 'layout' | 'form' | 'display' | 'control';
  component: ComponentType<any> | LazyExoticComponent<any>;
  loader?: ComponentLoader;
  interface?: ComponentInterface;
}

export interface ComponentRegistry {
  register(name: string, component: ComponentType<any>, options?: Partial<RegisteredComponent>): void;
  registerLazy(name: string, loader: ComponentLoader, options?: Partial<RegisteredComponent>): void;
  get(name: string): RegisteredComponent | undefined;
  has(name: string): boolean;
  getAll(): Map<string, RegisteredComponent>;
  getByCategory(category: RegisteredComponent['category']): RegisteredComponent[];
}

export function createRegistry(): ComponentRegistry {
  const components = new Map<string, RegisteredComponent>();

  return {
    register(name, component, options = {}) {
      if (components.has(name)) {
        console.warn(`Component "${name}" already registered, overwriting`);
      }
      components.set(name, {
        name,
        category: options.category ?? 'annotation',
        component,
        interface: options.interface,
      });
    },

    registerLazy(name, loader, options = {}) {
      const lazy = React.lazy(loader);
      components.set(name, {
        name,
        category: options.category ?? 'annotation',
        component: lazy,
        loader,
        interface: options.interface,
      });
    },

    get(name) {
      return components.get(name);
    },

    has(name) {
      return components.has(name);
    },

    getAll() {
      return new Map(components);
    },

    getByCategory(category) {
      return Array.from(components.values()).filter(c => c.category === category);
    },
  };
}

// Default global registry
export const defaultRegistry = createRegistry();
```
  </action>
  <verify>Registry stores and retrieves components by name</verify>
  <done>Component registry created with lazy loading support</done>
</task>

<task type="auto">
  <name>Task 2: Create component resolver with security</name>
  <files>packages/@glyph/layout-runtime/src/registry/resolver.ts</files>
  <action>
Create resolver with allowlist enforcement:

```typescript
import type { ComponentType } from 'react';
import type { ComponentRegistry } from './registry';

export interface ResolverOptions {
  allowedComponents?: string[];  // If set, only these can be resolved
  onUnknownComponent?: (name: string) => void;
  onDisallowedComponent?: (name: string) => void;
}

export interface ComponentResolver {
  resolve(name: string): ComponentType<any> | null;
  canResolve(name: string): boolean;
  getAllowed(): string[];
}

export function createResolver(
  registry: ComponentRegistry,
  options: ResolverOptions = {}
): ComponentResolver {
  const { allowedComponents, onUnknownComponent, onDisallowedComponent } = options;

  // If allowlist provided, validate it
  if (allowedComponents) {
    for (const name of allowedComponents) {
      if (!registry.has(name)) {
        console.warn(`Allowlisted component "${name}" not found in registry`);
      }
    }
  }

  return {
    resolve(name: string): ComponentType<any> | null {
      // Check if component exists
      if (!registry.has(name)) {
        onUnknownComponent?.(name);
        console.error(`Unknown component: "${name}". Available: ${Array.from(registry.getAll().keys()).join(', ')}`);
        return null;
      }

      // Check allowlist
      if (allowedComponents && !allowedComponents.includes(name)) {
        onDisallowedComponent?.(name);
        console.error(`Component "${name}" not in allowlist for this layout`);
        return null;
      }

      const registered = registry.get(name)!;
      return registered.component;
    },

    canResolve(name: string): boolean {
      if (!registry.has(name)) return false;
      if (allowedComponents && !allowedComponents.includes(name)) return false;
      return true;
    },

    getAllowed(): string[] {
      if (allowedComponents) return [...allowedComponents];
      return Array.from(registry.getAll().keys());
    },
  };
}

/**
 * Error boundary component for unknown/disallowed components.
 */
export function UnknownComponent({ name }: { name: string }) {
  return (
    <div className="p-4 bg-destructive/10 border border-destructive rounded-md">
      <p className="text-destructive font-medium">Unknown component: {name}</p>
      <p className="text-sm text-muted-foreground">
        This component is not registered or not allowed in this layout.
      </p>
    </div>
  );
}

/**
 * Error boundary component for component render errors.
 */
export function ComponentError({ name, error }: { name: string; error: Error }) {
  return (
    <div className="p-4 bg-destructive/10 border border-destructive rounded-md">
      <p className="text-destructive font-medium">Error rendering: {name}</p>
      <pre className="text-xs mt-2 overflow-auto">{error.message}</pre>
    </div>
  );
}
```
  </action>
  <verify>Resolver rejects components not in allowlist</verify>
  <done>Component resolver created with security checks</done>
</task>

<task type="auto">
  <name>Task 3: Create registry hooks and register defaults</name>
  <files>packages/@glyph/layout-runtime/src/registry/hooks.ts</files>
  <action>
Create hooks and default registration:

```typescript
import { createContext, useContext, useMemo, ReactNode } from 'react';
import { createRegistry, defaultRegistry, type ComponentRegistry } from './registry';
import { createResolver, type ComponentResolver, type ResolverOptions } from './resolver';

// Import all default components
import { NERTagger, Classification, BoundingBox } from '@glyph/components/annotation';
import { Section, Grid, Box, Column, Header } from '@glyph/components/layout';
import { Select, TextArea, Checkbox, RadioGroup } from '@glyph/components/form';
import { TextDisplay, ImageViewer } from '@glyph/components/display';
import { Show, ForEach, Button } from '@glyph/components/control';

// Import interfaces
import { ComponentInterfaces } from '@glyph/components/interfaces';

/**
 * Register all default components.
 */
export function registerDefaultComponents(registry: ComponentRegistry = defaultRegistry) {
  // Annotation components
  registry.register('NERTagger', NERTagger, { category: 'annotation', interface: ComponentInterfaces.NERTagger });
  registry.register('Classification', Classification, { category: 'annotation', interface: ComponentInterfaces.Classification });
  registry.register('BoundingBox', BoundingBox, { category: 'annotation', interface: ComponentInterfaces.BoundingBox });

  // Layout components
  registry.register('Section', Section, { category: 'layout', interface: ComponentInterfaces.Section });
  registry.register('Grid', Grid, { category: 'layout', interface: ComponentInterfaces.Grid });
  registry.register('Box', Box, { category: 'layout', interface: ComponentInterfaces.Box });
  registry.register('Column', Column, { category: 'layout', interface: ComponentInterfaces.Column });
  registry.register('Header', Header, { category: 'layout', interface: ComponentInterfaces.Header });

  // Form components
  registry.register('Select', Select, { category: 'form', interface: ComponentInterfaces.Select });
  registry.register('TextArea', TextArea, { category: 'form', interface: ComponentInterfaces.TextArea });
  registry.register('Checkbox', Checkbox, { category: 'form', interface: ComponentInterfaces.Checkbox });
  registry.register('RadioGroup', RadioGroup, { category: 'form', interface: ComponentInterfaces.RadioGroup });

  // Display components
  registry.register('TextDisplay', TextDisplay, { category: 'display', interface: ComponentInterfaces.TextDisplay });
  registry.register('ImageViewer', ImageViewer, { category: 'display', interface: ComponentInterfaces.ImageViewer });

  // Control components
  registry.register('Show', Show, { category: 'control', interface: ComponentInterfaces.Show });
  registry.register('ForEach', ForEach, { category: 'control', interface: ComponentInterfaces.ForEach });
  registry.register('Button', Button, { category: 'control', interface: ComponentInterfaces.Button });
}

// Context for registry access
const RegistryContext = createContext<ComponentRegistry>(defaultRegistry);
const ResolverContext = createContext<ComponentResolver | null>(null);

export function RegistryProvider({ 
  registry = defaultRegistry,
  resolverOptions,
  children 
}: { 
  registry?: ComponentRegistry;
  resolverOptions?: ResolverOptions;
  children: ReactNode;
}) {
  const resolver = useMemo(
    () => createResolver(registry, resolverOptions),
    [registry, resolverOptions]
  );

  return (
    <RegistryContext.Provider value={registry}>
      <ResolverContext.Provider value={resolver}>
        {children}
      </ResolverContext.Provider>
    </RegistryContext.Provider>
  );
}

export function useRegistry() {
  return useContext(RegistryContext);
}

export function useResolver() {
  const resolver = useContext(ResolverContext);
  if (!resolver) throw new Error('useResolver must be used within RegistryProvider');
  return resolver;
}

export function useComponent(name: string) {
  const resolver = useResolver();
  return resolver.resolve(name);
}
```
  </action>
  <verify>useComponent resolves registered components</verify>
  <done>Registry hooks and default registration created</done>
</task>

<task type="auto">
  <name>Task 4: Export registry module</name>
  <files>
    packages/@glyph/layout-runtime/src/registry/index.ts
    packages/@glyph/layout-runtime/src/index.ts
  </files>
  <action>
**registry/index.ts:**
```typescript
export { createRegistry, defaultRegistry, type ComponentRegistry } from './registry';
export { createResolver, UnknownComponent, ComponentError, type ComponentResolver, type ResolverOptions } from './resolver';
export { registerDefaultComponents, RegistryProvider, useRegistry, useResolver, useComponent } from './hooks';
```

**Update src/index.ts:**
```typescript
export * from './shortcuts';
export * from './undo';
export * from './validation';
export * from './sync';
export * from './registry';
```
  </action>
  <verify>Registry exports work correctly</verify>
  <done>Registry module exported from package</done>
</task>

</tasks>

<verification>
- defaultRegistry has all components after registerDefaultComponents()
- Resolver rejects unknown components with helpful error
- Resolver rejects components not in allowlist
- useComponent returns correct React component
- Lazy components load on first use
</verification>

<success_criteria>
- Component registry maps names to implementations
- Async loading works for code splitting
- Unknown components produce helpful errors
- Allowlist enforcement works for security
</success_criteria>
