---
phase: 02-core-domain
plan: 02
title: Domain Error Architecture
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - apps/api/Cargo.toml
  - libs/domain/src/lib.rs
  - libs/domain/src/error.rs
  - apps/api/src/error.rs
autonomous: true
must_haves:
  truths:
    - "Domain errors are per-operation, not monolithic"
    - "API errors conform to RFC 7807 Problem Details"
    - "All errors include trace_id for correlation"
  artifacts:
    - path: "libs/domain/src/error.rs"
      provides: "IdParseError, domain error types"
      min_lines: 50
    - path: "apps/api/src/error.rs"
      provides: "RFC 7807 error responses with problem_details"
      min_lines: 80
  key_links:
    - from: "apps/api/src/error.rs"
      to: "problem_details crate"
      via: "IntoResponse implementation"
      pattern: "ProblemDetails::new"
---

# Plan 02: Domain Error Architecture

## Objective

Implement hierarchical error handling with per-operation domain errors and RFC 7807 responses at the API layer.

Purpose: Clean error composition from domain to API with standard problem details format.

Output: Error modules in domain and API crates with RFC 7807 integration.

## Context

@.planning/phases/02-core-domain/02-RESEARCH.md (Pattern 3: Hierarchical Domain Errors)
@.planning/phases/02-core-domain/02-CONTEXT.md (API Error Format section)
@apps/api/src/error.rs

## Tasks

<task id="1">
<title>Add problem_details to workspace</title>
<files>Cargo.toml, apps/api/Cargo.toml</files>
<action>
Add to workspace `Cargo.toml`:
```toml
problem_details = { version = "0.4", features = ["axum"] }
```

Add to `apps/api/Cargo.toml` dependencies:
```toml
problem_details.workspace = true
```
</action>
<verify>`cargo check -p glyph-api` succeeds</verify>
<done>problem_details crate available</done>
</task>

<task id="2">
<title>Create domain error module</title>
<files>libs/domain/src/error.rs, libs/domain/src/lib.rs</files>
<action>
Create `libs/domain/src/error.rs` with per-operation error pattern:

```rust
use thiserror::Error;

/// Errors that can occur when parsing entity IDs
#[derive(Debug, Error)]
pub enum IdParseError {
    #[error("missing prefix separator '_'")]
    MissingPrefix,
    #[error("wrong prefix: expected '{expected}', got '{got}'")]
    WrongPrefix { expected: &'static str, got: String },
    #[error("invalid UUID: {0}")]
    InvalidUuid(#[from] uuid::Error),
}

/// Base database error wrapper for repository operations
#[derive(Debug, Error)]
#[error("database error")]
pub struct DbError(#[source] pub sqlx::Error);

/// Trait for domain errors that can be converted to API errors
pub trait DomainError: std::error::Error {
    /// Hierarchical error code (e.g., "user.email.exists")
    fn error_code(&self) -> &'static str;
    /// HTTP status code for this error
    fn status_code(&self) -> http::StatusCode;
}
```

Add to `libs/domain/src/lib.rs`:
```rust
pub mod error;
pub use error::*;
```

Note: Per-operation errors (CreateUserError, FindUserError, etc.) will be added in Plan 04 with repository traits.
</action>
<verify>`cargo check -p glyph-domain` succeeds</verify>
<done>Domain error base types defined</done>
</task>

<task id="3">
<title>Refactor API errors to RFC 7807</title>
<files>apps/api/src/error.rs</files>
<action>
Replace `apps/api/src/error.rs` with RFC 7807 implementation:

```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use problem_details::ProblemDetails;
use serde::Serialize;
use thiserror::Error;

/// Base API error type with RFC 7807 support
#[derive(Debug, Error)]
pub enum ApiError {
    #[error("resource not found: {resource_type} {id}")]
    NotFound { resource_type: &'static str, id: String },

    #[error("bad request: {message}")]
    BadRequest { code: &'static str, message: String },

    #[error("unauthorized")]
    Unauthorized,

    #[error("forbidden")]
    Forbidden,

    #[error("conflict: {message}")]
    Conflict { code: &'static str, message: String },

    #[error("internal server error")]
    Internal(#[source] anyhow::Error),
}

impl ApiError {
    fn error_code(&self) -> &str {
        match self {
            Self::NotFound { resource_type, .. } => 
                match *resource_type {
                    "user" => "user.not_found",
                    "project" => "project.not_found",
                    "task" => "task.not_found",
                    _ => "resource.not_found",
                },
            Self::BadRequest { code, .. } => code,
            Self::Unauthorized => "auth.unauthorized",
            Self::Forbidden => "auth.forbidden",
            Self::Conflict { code, .. } => code,
            Self::Internal(_) => "internal",
        }
    }
}

impl IntoResponse for ApiError {
    fn into_response(self) -> Response {
        let status = match &self {
            ApiError::NotFound { .. } => StatusCode::NOT_FOUND,
            ApiError::BadRequest { .. } => StatusCode::BAD_REQUEST,
            ApiError::Unauthorized => StatusCode::UNAUTHORIZED,
            ApiError::Forbidden => StatusCode::FORBIDDEN,
            ApiError::Conflict { .. } => StatusCode::CONFLICT,
            ApiError::Internal(_) => StatusCode::INTERNAL_SERVER_ERROR,
        };

        let error_code = self.error_code();
        let type_uri = format!("https://api.glyph.app/errors/{}", error_code);

        ProblemDetails::new()
            .with_status(status)
            .with_type(type_uri.parse().unwrap())
            .with_title(match &self {
                ApiError::NotFound { .. } => "Resource Not Found",
                ApiError::BadRequest { .. } => "Bad Request",
                ApiError::Unauthorized => "Unauthorized",
                ApiError::Forbidden => "Forbidden",
                ApiError::Conflict { .. } => "Conflict",
                ApiError::Internal(_) => "Internal Server Error",
            })
            .with_detail(self.to_string())
            .into_response()
    }
}

// Conversion from domain errors (to be expanded in Plan 04)
impl From<glyph_domain::IdParseError> for ApiError {
    fn from(err: glyph_domain::IdParseError) -> Self {
        ApiError::BadRequest {
            code: "id.parse_error",
            message: err.to_string(),
        }
    }
}
```
</action>
<verify>
- `cargo check -p glyph-api` succeeds
- API error responses include `type`, `title`, `status`, `detail` fields
</verify>
<done>API errors return RFC 7807 Problem Details format</done>
</task>

## Verification Criteria

- [ ] `cargo check` succeeds for domain and api crates
- [ ] `ApiError::NotFound` serializes to RFC 7807 format
- [ ] Error responses include hierarchical error codes
- [ ] `IdParseError` can be converted to `ApiError`

## Success Criteria

Error architecture established with domain errors composing to RFC 7807 API responses.

## Output

After completion, create `.planning/phases/02-core-domain/02-02-SUMMARY.md`
