---
phase: 02-core-domain
plan: 04
title: Repository Traits and Pagination
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - libs/db/Cargo.toml
  - libs/db/src/lib.rs
  - libs/db/src/repo/mod.rs
  - libs/db/src/repo/traits.rs
  - libs/db/src/pagination.rs
autonomous: true
must_haves:
  truths:
    - "Repository traits define async CRUD operations"
    - "Per-operation error types exist for each repository"
    - "Pagination supports offset/limit with single sort field"
  artifacts:
    - path: "libs/db/src/repo/traits.rs"
      provides: "UserRepository, TeamRepository, ProjectRepository, TaskRepository, AnnotationRepository, WorkflowRepository traits"
      min_lines: 120
    - path: "libs/db/src/pagination.rs"
      provides: "Pagination, Page<T>, SortOrder"
      min_lines: 40
  key_links:
    - from: "libs/db/src/repo/traits.rs"
      to: "glyph_domain::ids"
      via: "prefixed ID types in signatures"
      pattern: "UserId|ProjectId|TaskId"
---

# Plan 04: Repository Traits and Pagination

## Objective

Define repository traits with async operations and per-operation error types. Implement pagination support.

Purpose: Clean abstraction layer between domain and database with explicit error handling.

Output: Repository trait definitions and pagination types in libs/db.

## Context

@.planning/phases/02-core-domain/02-RESEARCH.md (Pattern 2: Repository Trait)
@.planning/phases/02-core-domain/02-CONTEXT.md (Repository Pattern)
@.planning/phases/02-core-domain/02-01-SUMMARY.md
@.planning/phases/02-core-domain/02-02-SUMMARY.md
@libs/db/src/lib.rs

## Tasks

<task id="1">
<title>Create pagination types</title>
<files>libs/db/src/pagination.rs, libs/db/src/lib.rs</files>
<action>
Create `libs/db/src/pagination.rs`:

```rust
use serde::{Deserialize, Serialize};
use typeshare::typeshare;

/// Sort order for pagination
#[typeshare]
#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SortOrder {
    #[default]
    Asc,
    Desc,
}

/// Pagination parameters
#[typeshare]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pagination {
    #[serde(default = "default_limit")]
    pub limit: i64,
    #[serde(default)]
    pub offset: i64,
    pub sort_by: Option<String>,
    #[serde(default)]
    pub sort_order: SortOrder,
}

fn default_limit() -> i64 { 20 }

impl Default for Pagination {
    fn default() -> Self {
        Self {
            limit: 20,
            offset: 0,
            sort_by: None,
            sort_order: SortOrder::Asc,
        }
    }
}

/// Paginated result
#[typeshare]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Page<T> {
    pub items: Vec<T>,
    pub total: i64,
    pub limit: i64,
    pub offset: i64,
}

impl<T> Page<T> {
    pub fn new(items: Vec<T>, total: i64, pagination: &Pagination) -> Self {
        Self {
            items,
            total,
            limit: pagination.limit,
            offset: pagination.offset,
        }
    }
    
    pub fn has_more(&self) -> bool {
        self.offset + self.items.len() as i64 < self.total
    }
}
```

Add to `libs/db/src/lib.rs`:
```rust
pub mod pagination;
pub use pagination::*;
```
</action>
<verify>`cargo check -p glyph-db` succeeds</verify>
<done>Pagination types defined</done>
</task>

<task id="2">
<title>Create per-operation repository errors</title>
<files>libs/db/src/repo/mod.rs, libs/db/src/repo/errors.rs</files>
<action>
Create `libs/db/src/repo/` directory and `libs/db/src/repo/errors.rs`:

```rust
use glyph_domain::{UserId, ProjectId, TaskId, AnnotationId};
use thiserror::Error;

// User repository errors
#[derive(Debug, Error)]
pub enum CreateUserError {
    #[error("email already exists: {0}")]
    EmailExists(String),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum FindUserError {
    #[error("user not found: {0}")]
    NotFound(UserId),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum UpdateUserError {
    #[error("user not found: {0}")]
    NotFound(UserId),
    #[error("email already exists: {0}")]
    EmailExists(String),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum ListUsersError {
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

// Project repository errors
#[derive(Debug, Error)]
pub enum CreateProjectError {
    #[error("project name already exists: {0}")]
    NameExists(String),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum FindProjectError {
    #[error("project not found: {0}")]
    NotFound(ProjectId),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

// Task repository errors
#[derive(Debug, Error)]
pub enum CreateTaskError {
    #[error("project not found: {0}")]
    ProjectNotFound(ProjectId),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum FindTaskError {
    #[error("task not found: {0}")]
    NotFound(TaskId),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

// Annotation repository errors
#[derive(Debug, Error)]
pub enum CreateAnnotationError {
    #[error("task not found: {0}")]
    TaskNotFound(TaskId),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}

#[derive(Debug, Error)]
pub enum FindAnnotationError {
    #[error("annotation not found: {0}")]
    NotFound(AnnotationId),
    #[error("database error")]
    Database(#[source] sqlx::Error),
}
```

Create `libs/db/src/repo/mod.rs`:
```rust
pub mod errors;
pub mod traits;

pub use errors::*;
pub use traits::*;
```
</action>
<verify>`cargo check -p glyph-db` succeeds</verify>
<done>Per-operation error types defined</done>
</task>

<task id="3">
<title>Define repository traits</title>
<files>libs/db/src/repo/traits.rs, libs/db/src/lib.rs</files>
<action>
Create `libs/db/src/repo/traits.rs`:

```rust
use async_trait::async_trait;
use glyph_domain::{
    User, Project, Task, Annotation, Workflow,
    UserId, ProjectId, TaskId, AnnotationId, WorkflowId,
    UserStatus, ProjectStatus, TaskStatus,
};
use crate::pagination::{Page, Pagination};
use super::errors::*;

/// Input for creating a new user
pub struct NewUser {
    pub email: String,
    pub display_name: String,
}

/// Input for updating a user
pub struct UserUpdate {
    pub display_name: Option<String>,
    pub status: Option<UserStatus>,
}

#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn find_by_id(&self, id: &UserId) -> Result<Option<User>, FindUserError>;
    async fn find_by_email(&self, email: &str) -> Result<Option<User>, FindUserError>;
    async fn create(&self, user: &NewUser) -> Result<User, CreateUserError>;
    async fn update(&self, id: &UserId, update: &UserUpdate) -> Result<User, UpdateUserError>;
    async fn list(&self, pagination: Pagination) -> Result<Page<User>, ListUsersError>;
    async fn soft_delete(&self, id: &UserId) -> Result<(), UpdateUserError>;
}

/// Input for creating a new project
pub struct NewProject {
    pub name: String,
    pub description: Option<String>,
    pub created_by: UserId,
}

#[async_trait]
pub trait ProjectRepository: Send + Sync {
    async fn find_by_id(&self, id: &ProjectId) -> Result<Option<Project>, FindProjectError>;
    async fn create(&self, project: &NewProject) -> Result<Project, CreateProjectError>;
    async fn list(&self, pagination: Pagination) -> Result<Page<Project>, sqlx::Error>;
    async fn soft_delete(&self, id: &ProjectId) -> Result<(), sqlx::Error>;
}

/// Input for creating a new task
pub struct NewTask {
    pub project_id: ProjectId,
    pub input_data: serde_json::Value,
}

#[async_trait]
pub trait TaskRepository: Send + Sync {
    async fn find_by_id(&self, id: &TaskId) -> Result<Option<Task>, FindTaskError>;
    async fn create(&self, task: &NewTask) -> Result<Task, CreateTaskError>;
    async fn list_by_project(&self, project_id: &ProjectId, pagination: Pagination) -> Result<Page<Task>, sqlx::Error>;
    async fn soft_delete(&self, id: &TaskId) -> Result<(), sqlx::Error>;
}

/// Input for creating a new annotation
pub struct NewAnnotation {
    pub task_id: TaskId,
    pub created_by: UserId,
    pub data: serde_json::Value,
}

#[async_trait]
pub trait AnnotationRepository: Send + Sync {
    async fn find_by_id(&self, id: &AnnotationId) -> Result<Option<Annotation>, FindAnnotationError>;
    async fn create(&self, annotation: &NewAnnotation) -> Result<Annotation, CreateAnnotationError>;
    async fn list_by_task(&self, task_id: &TaskId, pagination: Pagination) -> Result<Page<Annotation>, sqlx::Error>;
}

#[async_trait]
pub trait WorkflowRepository: Send + Sync {
    async fn find_by_id(&self, id: &WorkflowId) -> Result<Option<Workflow>, sqlx::Error>;
    async fn list(&self, pagination: Pagination) -> Result<Page<Workflow>, sqlx::Error>;
}

/// Input for creating a new team
pub struct NewTeam {
    pub name: String,
    pub description: Option<String>,
    pub leader_id: UserId,
}

#[async_trait]
pub trait TeamRepository: Send + Sync {
    async fn find_by_id(&self, id: &TeamId) -> Result<Option<Team>, sqlx::Error>;
    async fn create(&self, team: &NewTeam) -> Result<Team, sqlx::Error>;
    async fn list(&self, pagination: Pagination) -> Result<Page<Team>, sqlx::Error>;
    async fn add_member(&self, team_id: &TeamId, user_id: &UserId, role: TeamRole) -> Result<(), sqlx::Error>;
    async fn remove_member(&self, team_id: &TeamId, user_id: &UserId) -> Result<(), sqlx::Error>;
    async fn soft_delete(&self, id: &TeamId) -> Result<(), sqlx::Error>;
}
```

Update `libs/db/src/lib.rs`:
```rust
pub mod cache;
pub mod pagination;
pub mod pool;
pub mod repo;

pub use cache::*;
pub use pagination::*;
pub use pool::*;
pub use repo::*;
```
</action>
<verify>
- `cargo check -p glyph-db` succeeds
- All repository traits compile with async_trait
</verify>
<done>Repository traits defined with explicit methods</done>
</task>

## Verification Criteria

- [ ] `cargo check -p glyph-db` succeeds
- [ ] `UserRepository` trait has find_by_id, create, update, list, soft_delete
- [ ] Pagination types work with `#[typeshare]`
- [ ] Per-operation errors are specific (not generic Error enum)

## Success Criteria

Repository layer abstraction defined with type-safe operations and pagination.

## Output

After completion, create `.planning/phases/02-core-domain/02-04-SUMMARY.md`
