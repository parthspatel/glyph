---
phase: 02-core-domain
plan: 06
title: OpenAPI and TypeScript Generation
wave: 4
depends_on: ["02-05"]
files_modified:
  - Cargo.toml
  - apps/api/Cargo.toml
  - apps/api/src/lib.rs
  - apps/api/src/routes/mod.rs
  - apps/api/src/routes/users.rs
  - apps/api/src/openapi.rs
  - package.json
  - packages/@glyph/types/package.json
  - packages/@glyph/types/src/index.ts
autonomous: true
must_haves:
  truths:
    - "OpenAPI spec auto-generated from route handlers"
    - "Swagger UI available at /swagger-ui"
    - "TypeScript types generated from Rust domain types"
    - "API routes return 501 for unimplemented endpoints"
  artifacts:
    - path: "apps/api/src/openapi.rs"
      provides: "OpenAPI document generation"
      min_lines: 40
    - path: "packages/@glyph/types/src/index.ts"
      provides: "Generated TypeScript types"
      min_lines: 20
  key_links:
    - from: "apps/api/src/routes/mod.rs"
      to: "utoipa_axum::OpenApiRouter"
      via: "OpenApiRouter for combined routing"
      pattern: "OpenApiRouter::new"
---

# Plan 06: OpenAPI and TypeScript Generation

## Objective

Set up OpenAPI spec generation with utoipa-axum and TypeScript type generation with typeshare.

Purpose: API documentation and frontend type safety from single Rust source of truth.

Output: Swagger UI at /swagger-ui, TypeScript types in packages/@glyph/types.

## Context

@.planning/phases/02-core-domain/02-RESEARCH.md (Pattern 5: OpenAPI with utoipa-axum)
@.planning/phases/02-core-domain/02-CONTEXT.md (TypeScript Generation)
@.planning/phases/02-core-domain/02-05-SUMMARY.md
@apps/api/src/routes/mod.rs

## Tasks

<task id="1">
<title>Add utoipa dependencies to workspace</title>
<files>Cargo.toml, apps/api/Cargo.toml</files>
<action>
Update workspace `Cargo.toml`:
```toml
[workspace.dependencies]
# OpenAPI
utoipa = { version = "5", features = ["axum_extras", "uuid", "chrono"] }
utoipa-axum = "0.2"
utoipa-swagger-ui = { version = "8", features = ["axum"] }
```

Update `apps/api/Cargo.toml`:
```toml
[dependencies]
utoipa.workspace = true
utoipa-axum.workspace = true
utoipa-swagger-ui.workspace = true
```
</action>
<verify>`cargo check -p glyph-api` succeeds</verify>
<done>utoipa dependencies available</done>
</task>

<task id="2">
<title>Refactor API routes with OpenApiRouter</title>
<files>apps/api/src/openapi.rs, apps/api/src/routes/mod.rs, apps/api/src/routes/users.rs, apps/api/src/lib.rs, apps/api/src/main.rs</files>
<action>
1. Create `apps/api/src/openapi.rs`:
```rust
use utoipa::OpenApi;

#[derive(OpenApi)]
#[openapi(
    info(
        title = "Glyph API",
        version = "1.0.0",
        description = "Data annotation platform API"
    ),
    tags(
        (name = "users", description = "User management"),
        (name = "projects", description = "Project management"),
        (name = "tasks", description = "Task management"),
        (name = "annotations", description = "Annotation management"),
        (name = "workflows", description = "Workflow management"),
        (name = "health", description = "Health checks")
    )
)]
pub struct ApiDoc;
```

2. Create `apps/api/src/routes/users.rs`:
```rust
use axum::{
    extract::{Path, State, Query},
    http::StatusCode,
    Json,
};
use glyph_domain::{User, UserId};
use glyph_db::{Pagination, Page};
use utoipa_axum::{router::OpenApiRouter, routes};
use std::sync::Arc;

use crate::ApiError;

/// List all users
#[utoipa::path(
    get,
    path = "/",
    tag = "users",
    params(
        ("limit" = Option<i64>, Query, description = "Max results (default 20)"),
        ("offset" = Option<i64>, Query, description = "Offset for pagination")
    ),
    responses(
        (status = 200, description = "List of users"),
        (status = 501, description = "Not implemented")
    )
)]
async fn list_users(
    Query(pagination): Query<Pagination>,
) -> Result<Json<serde_json::Value>, ApiError> {
    // Return 501 Not Implemented for now
    Err(ApiError::Internal(anyhow::anyhow!("Not implemented")))
}

/// Get user by ID
#[utoipa::path(
    get,
    path = "/{user_id}",
    tag = "users",
    params(
        ("user_id" = String, Path, description = "User ID (prefixed)")
    ),
    responses(
        (status = 200, description = "User found"),
        (status = 404, description = "User not found"),
        (status = 501, description = "Not implemented")
    )
)]
async fn get_user(
    Path(user_id): Path<String>,
) -> Result<Json<serde_json::Value>, ApiError> {
    // Parse prefixed ID
    let _id: UserId = user_id.parse().map_err(|e| ApiError::BadRequest {
        code: "user.id.invalid",
        message: format!("Invalid user ID: {}", e),
    })?;
    
    // Return 501 Not Implemented for now
    Err(ApiError::Internal(anyhow::anyhow!("Not implemented")))
}

pub fn router() -> OpenApiRouter {
    OpenApiRouter::new()
        .routes(routes!(list_users))
        .routes(routes!(get_user))
}
```

3. Update `apps/api/src/routes/mod.rs`:
```rust
mod annotations;
mod health;
mod projects;
mod tasks;
mod users;
mod workflows;

use utoipa_axum::router::OpenApiRouter;

pub fn api_v1_router() -> OpenApiRouter {
    OpenApiRouter::new()
        .nest("/users", users::router())
        .nest("/projects", projects::router())
        .nest("/tasks", tasks::router())
        .nest("/annotations", annotations::router())
        .nest("/workflows", workflows::router())
}

pub fn health_router() -> axum::Router {
    health::routes()
}
```

4. Update `apps/api/src/main.rs` to serve Swagger UI:
```rust
use utoipa_swagger_ui::SwaggerUi;
use glyph_api::{routes, openapi::ApiDoc};
use utoipa::OpenApi;

#[tokio::main]
async fn main() -> Result<()> {
    // ... existing setup ...

    let (api_router, api_doc) = routes::api_v1_router()
        .split_for_parts();

    let app = Router::new()
        .merge(routes::health_router())
        .nest("/api/v1", api_router)
        .merge(SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", api_doc))
        .layer(TraceLayer::new_for_http())
        .layer(CorsLayer::permissive());

    // ... rest of server setup ...
}
```

5. Update `apps/api/src/lib.rs`:
```rust
pub mod error;
pub mod extractors;
pub mod middleware;
pub mod openapi;
pub mod routes;

pub use error::ApiError;
```

Note: Update other route files (projects.rs, tasks.rs, annotations.rs, workflows.rs) to use OpenApiRouter pattern similarly. They can return 501 for now.
</action>
<verify>
- `cargo check -p glyph-api` succeeds
- Server starts and /swagger-ui is accessible
</verify>
<done>OpenAPI routes with Swagger UI</done>
</task>

<task id="3">
<title>Set up TypeScript generation pipeline</title>
<files>package.json, packages/@glyph/types/package.json, packages/@glyph/types/src/index.ts</files>
<action>
1. Ensure `packages/@glyph/types` directory exists with proper structure:
```
packages/@glyph/types/
  package.json
  tsconfig.json
  src/
    index.ts
```

2. Create/update `packages/@glyph/types/package.json`:
```json
{
  "name": "@glyph/types",
  "version": "0.1.0",
  "description": "TypeScript types generated from Glyph domain",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "generate": "typeshare --lang typescript --output-file src/generated.ts ../../libs/domain/src"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

3. Create `packages/@glyph/types/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "declaration": true,
    "outDir": "dist",
    "strict": true,
    "esModuleInterop": true
  },
  "include": ["src/**/*"]
}
```

4. Add typeshare script to root `package.json`:
```json
{
  "scripts": {
    "typegen": "pnpm --filter @glyph/types generate"
  }
}
```

5. Run typeshare to generate initial types:
```bash
cd packages/@glyph/types
pnpm generate
```

This will generate `src/generated.ts` with all types marked with `#[typeshare]`.

6. Create `packages/@glyph/types/src/index.ts`:
```typescript
// Re-export all generated types
export * from './generated';
```
</action>
<verify>
- `pnpm typegen` succeeds
- `packages/@glyph/types/src/generated.ts` contains UserId, User, etc.
- `pnpm --filter @glyph/types build` succeeds
</verify>
<done>TypeScript types auto-generated from Rust domain</done>
</task>

## Verification Criteria

- [ ] `cargo check -p glyph-api` succeeds
- [ ] Server starts and /swagger-ui loads
- [ ] OpenAPI spec includes all endpoints
- [ ] `pnpm typegen` generates TypeScript types
- [ ] Generated types include User, UserId, Project, etc.

## Success Criteria

API documentation auto-generated, TypeScript types in sync with Rust domain.

## Output

After completion, create `.planning/phases/02-core-domain/02-06-SUMMARY.md`
