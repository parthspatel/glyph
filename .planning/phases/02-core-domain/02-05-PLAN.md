---
phase: 02-core-domain
plan: 05
title: Repository Implementations and Audit Trail
wave: 3
depends_on: ["02-03", "02-04"]
files_modified:
  - libs/db/src/repo/pg_user.rs
  - libs/db/src/repo/pg_project.rs
  - libs/db/src/repo/pg_task.rs
  - libs/db/src/repo/mod.rs
  - libs/db/src/audit.rs
  - migrations/0008_create_audit_events.sql
  - migrations/0009_alter_id_columns.sql
autonomous: true
must_haves:
  truths:
    - "PgUserRepository fully implements UserRepository trait"
    - "Project, Task, Annotation, Workflow repositories have stub implementations"
    - "Audit events are recorded for all mutating operations"
    - "IDs stored as TEXT in database to preserve prefix"
  artifacts:
    - path: "libs/db/src/repo/pg_user.rs"
      provides: "PgUserRepository implementing UserRepository"
      min_lines: 100
    - path: "libs/db/src/audit.rs"
      provides: "AuditWriter, AuditEvent"
      min_lines: 60
    - path: "migrations/0008_create_audit_events.sql"
      provides: "audit_events table"
      contains: "CREATE TABLE audit_events"
  key_links:
    - from: "libs/db/src/repo/pg_user.rs"
      to: "libs/db/src/audit.rs"
      via: "AuditWriter calls on mutations"
      pattern: "audit_writer.record"
---

# Plan 05: Repository Implementations and Audit Trail

## Objective

Implement PostgreSQL repositories for all domain entities and add audit trail infrastructure.

Purpose: Working database layer with field-level change tracking for compliance.

Output: PostgreSQL repository implementations and audit event system.

## Context

@.planning/phases/02-core-domain/02-RESEARCH.md (Pattern 4: Audit Event Recording)
@.planning/phases/02-core-domain/02-CONTEXT.md (Audit Trail section)
@.planning/phases/02-core-domain/02-03-SUMMARY.md
@.planning/phases/02-core-domain/02-04-SUMMARY.md
@libs/db/src/repo/traits.rs

## Tasks

<task id="1">
<title>Create migrations for audit and ID columns</title>
<files>migrations/0008_create_audit_events.sql, migrations/0009_alter_id_columns.sql</files>
<action>
Create `migrations/0008_create_audit_events.sql`:

```sql
-- Audit events table for field-level change tracking
CREATE TYPE audit_action AS ENUM ('create', 'read', 'update', 'delete');
CREATE TYPE audit_actor_type AS ENUM ('user', 'system', 'api');

CREATE TABLE audit_events (
    event_id        UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_type     VARCHAR(50) NOT NULL,
    entity_id       TEXT NOT NULL,  -- Prefixed ID string
    action          audit_action NOT NULL,
    actor_id        TEXT NOT NULL,  -- Prefixed user ID or 'system'
    actor_type      audit_actor_type NOT NULL,
    data_snapshot   JSONB NOT NULL,
    changes         JSONB,  -- Field-level diff for updates
    request_id      TEXT,   -- Correlation ID
    occurred_at     TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes for common query patterns
CREATE INDEX idx_audit_entity ON audit_events (entity_type, entity_id);
CREATE INDEX idx_audit_actor ON audit_events (actor_id);
CREATE INDEX idx_audit_occurred ON audit_events (occurred_at DESC);
CREATE INDEX idx_audit_request ON audit_events (request_id) WHERE request_id IS NOT NULL;

COMMENT ON TABLE audit_events IS 'Field-level audit trail for all entity changes';
```

Create `migrations/0009_alter_id_columns.sql`:

```sql
-- Alter ID columns from UUID to TEXT for prefixed ID support
-- Note: This requires data migration if tables have existing data

ALTER TABLE users 
    ALTER COLUMN user_id TYPE TEXT USING user_id::text;

ALTER TABLE projects
    ALTER COLUMN project_id TYPE TEXT USING project_id::text,
    ALTER COLUMN created_by_user_id TYPE TEXT USING created_by_user_id::text;

ALTER TABLE tasks
    ALTER COLUMN task_id TYPE TEXT USING task_id::text,
    ALTER COLUMN project_id TYPE TEXT USING project_id::text;

ALTER TABLE annotations
    ALTER COLUMN annotation_id TYPE TEXT USING annotation_id::text,
    ALTER COLUMN task_id TYPE TEXT USING task_id::text,
    ALTER COLUMN created_by_user_id TYPE TEXT USING created_by_user_id::text;

-- Update foreign key references as needed
-- (Note: Existing FK constraints may need to be dropped and recreated)
```
</action>
<verify>Migration files exist with correct SQL</verify>
<done>Database schema supports prefixed IDs and audit events</done>
</task>

<task id="2">
<title>Create audit writer</title>
<files>libs/db/src/audit.rs, libs/db/src/lib.rs</files>
<action>
Create `libs/db/src/audit.rs`:

```rust
use serde::{Deserialize, Serialize};
use serde_json::Value;
use sqlx::PgPool;
use thiserror::Error;

#[derive(Debug, Clone, Copy, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "audit_action", rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum AuditAction {
    Create,
    Read,
    Update,
    Delete,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "audit_actor_type", rename_all = "snake_case")]
#[serde(rename_all = "snake_case")]
pub enum AuditActorType {
    User,
    System,
    Api,
}

#[derive(Debug, Clone, Serialize)]
pub struct AuditEvent {
    pub entity_type: &'static str,
    pub entity_id: String,
    pub action: AuditAction,
    pub actor_id: String,
    pub actor_type: AuditActorType,
    pub data_snapshot: Value,
    pub changes: Option<Value>,
    pub request_id: Option<String>,
}

#[derive(Debug, Error)]
pub enum AuditError {
    #[error("failed to record audit event: {0}")]
    Database(#[from] sqlx::Error),
}

pub struct AuditWriter {
    pool: PgPool,
}

impl AuditWriter {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    pub async fn record(&self, event: AuditEvent) -> Result<(), AuditError> {
        sqlx::query!(
            r#"INSERT INTO audit_events 
               (entity_type, entity_id, action, actor_id, actor_type, 
                data_snapshot, changes, request_id)
               VALUES ($1, $2, $3, $4, $5, $6, $7, $8)"#,
            event.entity_type,
            event.entity_id,
            event.action as AuditAction,
            event.actor_id,
            event.actor_type as AuditActorType,
            event.data_snapshot,
            event.changes,
            event.request_id,
        )
        .execute(&self.pool)
        .await?;
        Ok(())
    }

    /// Compute field-level diff between old and new values
    pub fn compute_changes(old: &Value, new: &Value) -> Option<Value> {
        let mut changes = serde_json::Map::new();
        if let (Value::Object(old_obj), Value::Object(new_obj)) = (old, new) {
            for (key, new_val) in new_obj {
                if old_obj.get(key) != Some(new_val) {
                    changes.insert(key.clone(), serde_json::json!({
                        "old": old_obj.get(key),
                        "new": new_val
                    }));
                }
            }
        }
        if changes.is_empty() { None } else { Some(Value::Object(changes)) }
    }
}

/// System actor ID for automated operations
pub const SYSTEM_ACTOR_ID: &str = "system";
```

Update `libs/db/src/lib.rs`:
```rust
pub mod audit;
pub use audit::*;
```
</action>
<verify>`cargo check -p glyph-db` succeeds</verify>
<done>Audit writer with field-level change tracking</done>
</task>

<task id="3">
<title>Implement PostgreSQL user repository</title>
<files>libs/db/src/repo/pg_user.rs, libs/db/src/repo/mod.rs</files>
<action>
Create `libs/db/src/repo/pg_user.rs`:

```rust
use async_trait::async_trait;
use sqlx::PgPool;
use glyph_domain::{User, UserId, UserStatus};
use crate::{
    audit::{AuditWriter, AuditEvent, AuditAction, AuditActorType, SYSTEM_ACTOR_ID},
    pagination::{Page, Pagination},
    repo::{
        traits::{UserRepository, NewUser, UserUpdate},
        errors::{CreateUserError, FindUserError, UpdateUserError, ListUsersError},
    },
};

pub struct PgUserRepository {
    pool: PgPool,
    audit: AuditWriter,
}

impl PgUserRepository {
    pub fn new(pool: PgPool) -> Self {
        let audit = AuditWriter::new(pool.clone());
        Self { pool, audit }
    }
}

// Internal row type for SQLx
struct UserRow {
    user_id: String,
    email: String,
    display_name: String,
    status: String,
    skills: serde_json::Value,
    roles: serde_json::Value,
    quality_profile: serde_json::Value,
    created_at: chrono::DateTime<chrono::Utc>,
    updated_at: chrono::DateTime<chrono::Utc>,
}

impl TryFrom<UserRow> for User {
    type Error = glyph_domain::IdParseError;
    
    fn try_from(row: UserRow) -> Result<Self, Self::Error> {
        Ok(User {
            user_id: row.user_id.parse()?,
            email: row.email,
            display_name: row.display_name,
            status: serde_json::from_str(&format!("\"{}\"", row.status)).unwrap_or(UserStatus::Active),
            skills: serde_json::from_value(row.skills).unwrap_or_default(),
            roles: serde_json::from_value(row.roles).unwrap_or_default(),
            quality_profile: serde_json::from_value(row.quality_profile).unwrap_or_default(),
            created_at: row.created_at,
            updated_at: row.updated_at,
        })
    }
}

#[async_trait]
impl UserRepository for PgUserRepository {
    async fn find_by_id(&self, id: &UserId) -> Result<Option<User>, FindUserError> {
        let row = sqlx::query_as!(
            UserRow,
            r#"SELECT user_id, email, display_name, status::text as "status!",
                      skills, roles, quality_profile, created_at, updated_at
               FROM users WHERE user_id = $1 AND status != 'deleted'"#,
            id.to_string()
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(FindUserError::Database)?;

        row.map(User::try_from)
            .transpose()
            .map_err(|_| FindUserError::NotFound(id.clone()))
    }

    async fn find_by_email(&self, email: &str) -> Result<Option<User>, FindUserError> {
        let row = sqlx::query_as!(
            UserRow,
            r#"SELECT user_id, email, display_name, status::text as "status!",
                      skills, roles, quality_profile, created_at, updated_at
               FROM users WHERE email = $1 AND status != 'deleted'"#,
            email
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(FindUserError::Database)?;

        row.map(User::try_from)
            .transpose()
            .map_err(|_| FindUserError::Database(sqlx::Error::RowNotFound))
    }

    async fn create(&self, new_user: &NewUser) -> Result<User, CreateUserError> {
        // Check for existing email
        let existing = sqlx::query_scalar!(
            "SELECT user_id FROM users WHERE email = $1",
            &new_user.email
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(CreateUserError::Database)?;

        if existing.is_some() {
            return Err(CreateUserError::EmailExists(new_user.email.clone()));
        }

        let id = UserId::new();
        let row = sqlx::query_as!(
            UserRow,
            r#"INSERT INTO users (user_id, email, display_name)
               VALUES ($1, $2, $3)
               RETURNING user_id, email, display_name, status::text as "status!",
                         skills, roles, quality_profile, created_at, updated_at"#,
            id.to_string(),
            &new_user.email,
            &new_user.display_name
        )
        .fetch_one(&self.pool)
        .await
        .map_err(CreateUserError::Database)?;

        let user = User::try_from(row).map_err(|_| CreateUserError::Database(sqlx::Error::RowNotFound))?;

        // Record audit event
        let _ = self.audit.record(AuditEvent {
            entity_type: "user",
            entity_id: user.user_id.to_string(),
            action: AuditAction::Create,
            actor_id: SYSTEM_ACTOR_ID.to_string(),
            actor_type: AuditActorType::System,
            data_snapshot: serde_json::to_value(&user).unwrap_or_default(),
            changes: None,
            request_id: None,
        }).await;

        Ok(user)
    }

    async fn update(&self, id: &UserId, update: &UserUpdate) -> Result<User, UpdateUserError> {
        // Implementation with audit tracking
        todo!("Implement update with audit")
    }

    async fn list(&self, pagination: Pagination) -> Result<Page<User>, ListUsersError> {
        let total = sqlx::query_scalar!(
            "SELECT COUNT(*) FROM users WHERE status != 'deleted'"
        )
        .fetch_one(&self.pool)
        .await
        .map_err(ListUsersError::Database)?
        .unwrap_or(0);

        let rows = sqlx::query_as!(
            UserRow,
            r#"SELECT user_id, email, display_name, status::text as "status!",
                      skills, roles, quality_profile, created_at, updated_at
               FROM users WHERE status != 'deleted'
               ORDER BY created_at DESC
               LIMIT $1 OFFSET $2"#,
            pagination.limit,
            pagination.offset
        )
        .fetch_all(&self.pool)
        .await
        .map_err(ListUsersError::Database)?;

        let users: Vec<User> = rows
            .into_iter()
            .filter_map(|r| User::try_from(r).ok())
            .collect();

        Ok(Page::new(users, total, &pagination))
    }

    async fn soft_delete(&self, id: &UserId) -> Result<(), UpdateUserError> {
        let result = sqlx::query!(
            "UPDATE users SET status = 'deleted', updated_at = NOW() WHERE user_id = $1",
            id.to_string()
        )
        .execute(&self.pool)
        .await
        .map_err(UpdateUserError::Database)?;

        if result.rows_affected() == 0 {
            return Err(UpdateUserError::NotFound(id.clone()));
        }

        // Record audit event
        let _ = self.audit.record(AuditEvent {
            entity_type: "user",
            entity_id: id.to_string(),
            action: AuditAction::Delete,
            actor_id: SYSTEM_ACTOR_ID.to_string(),
            actor_type: AuditActorType::System,
            data_snapshot: serde_json::json!({}),
            changes: None,
            request_id: None,
        }).await;

        Ok(())
    }
}
```

Update `libs/db/src/repo/mod.rs`:
```rust
pub mod errors;
pub mod traits;
pub mod pg_user;

pub use errors::*;
pub use traits::*;
pub use pg_user::*;
```

4. Create stub implementations for other repositories in `libs/db/src/repo/`:

**pg_project.rs, pg_task.rs, pg_annotation.rs, pg_workflow.rs:**
Create stub files that define the struct and implement the trait with `todo!()` for each method:

```rust
// Example: pg_project.rs
use async_trait::async_trait;
use sqlx::PgPool;
use glyph_domain::{Project, ProjectId};
use crate::{pagination::{Page, Pagination}, repo::traits::*};

pub struct PgProjectRepository {
    pool: PgPool,
}

impl PgProjectRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl ProjectRepository for PgProjectRepository {
    async fn find_by_id(&self, _id: &ProjectId) -> Result<Option<Project>, FindProjectError> {
        todo!("Implement in Phase 5")
    }
    // ... other methods with todo!()
}
```

Update `libs/db/src/repo/mod.rs` to export all repository implementations.
</action>
<verify>
- `cargo check -p glyph-db` succeeds
- PgUserRepository compiles with audit integration
</verify>
<done>PostgreSQL user repository implemented with audit trail</done>
</task>

## Verification Criteria

- [ ] `cargo check -p glyph-db` succeeds
- [ ] Migrations exist for audit_events table and ID column changes
- [ ] AuditWriter can record events
- [ ] PgUserRepository implements UserRepository trait

## Success Criteria

Database layer functional with working user repository and audit trail.

## Output

After completion, create `.planning/phases/02-core-domain/02-05-SUMMARY.md`
